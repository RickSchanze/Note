{"ID":"20240309165141-2rv3495","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240309165141-2rv3495","title":"Chapter1 你好，并发世界！","updated":"20240309172559"},"Children":[{"ID":"20240309165203-s97urwe","Type":"NodeParagraph","Properties":{"id":"20240309165203-s97urwe"}},{"ID":"20240309165141-k562gov","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240309165141-k562gov","updated":"20240309165249"},"Children":[{"Type":"NodeText","Data":"1.1 何谓并发"}]},{"ID":"20240309165250-vzqvvgf","Type":"NodeParagraph","Properties":{"id":"20240309165250-vzqvvgf","updated":"20240309165510"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"计算机的并发，指在单个系统里同时执行多个独立的任务。"}]},{"ID":"20240309165511-3bzlu8c","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240309165511-3bzlu8c","updated":"20240309165923"},"Children":[{"Type":"NodeText","Data":"1.2 并发的方式"}]},{"ID":"20240309165923-94pkmqq","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240309165923-94pkmqq","updated":"20240309170817"},"Children":[{"ID":"20240309170817-j7tm1fb","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240309170817-j7tm1fb","updated":"20240309170817"},"Children":[{"ID":"20240309170817-d3x9prd","Type":"NodeParagraph","Properties":{"id":"20240309170817-d3x9prd","updated":"20240309170826"},"Children":[{"Type":"NodeText","Data":"将应用程序分为多个独立的进程同时运行"}]},{"ID":"20240309170827-nh3ub6v","Type":"NodeParagraph","Properties":{"id":"20240309170827-nh3ub6v","updated":"20240309170837"},"Children":[{"Type":"NodeText","Data":"独立的进程可以通过进程间的通信渠道传递讯息(信号、套接字、文件、管道等等)。不过，这种进程间的通信通常非常复杂，或是速度很慢。这是因为操作系统会对进程进行保护，以避免一个进程去修改另一个进程的数据。还有一个缺点是运行多个进程的固定开销：需要时间启动进程，操作系统需要资源来管理进程等等。"}]}]},{"ID":"20240309170839-yf559qv","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240309170839-yf559qv"},"Children":[{"ID":"20240309170839-w5gw3bv","Type":"NodeParagraph","Properties":{"id":"20240309170839-w5gw3bv","updated":"20240309170855"},"Children":[{"Type":"NodeText","Data":"在单进程中运行多个线程。"}]},{"ID":"20240309170856-qb24xc5","Type":"NodeParagraph","Properties":{"id":"20240309170856-qb24xc5","updated":"20240309170907"},"Children":[{"Type":"NodeText","Data":"每个线程相互独立运行，并且可以在不同的指令序列中运行。不过，进程中的所有线程都共享地址空间，并且能访问到大部分数据———全局变量仍然是全局的，指针、对象的引用或数据可以在线程之间传递。"}]}]}]},{"ID":"20240309170946-cfr5jau","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240309170946-cfr5jau","updated":"20240309170956"},"Children":[{"Type":"NodeText","Data":"1.3 为什么要使用并发？"}]},{"ID":"20240309170956-15yp2vv","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240309170956-15yp2vv","updated":"20240309171003"},"Children":[{"ID":"20240309171003-aceg9mc","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240309171003-aceg9mc","updated":"20240309171003"},"Children":[{"ID":"20240309171006-rduu000","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240309171006-rduu000","updated":"20240309171921"},"Children":[{"Type":"NodeText","Data":"分离关注点"}]},{"ID":"20240309171007-va6pae1","Type":"NodeParagraph","Properties":{"id":"20240309171007-va6pae1","updated":"20240309171152"},"Children":[{"Type":"NodeText","Data":"编写软件时，分离关注点是个好办法。通过将相关的代码与无关的代码分离，可以使程序更容易理解和测试，从而减少出错的可能。"}]}]},{"ID":"20240309171153-zob792p","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240309171153-zob792p"},"Children":[{"ID":"20240309171156-el4vpow","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240309171156-el4vpow","updated":"20240309171925"},"Children":[{"Type":"NodeText","Data":"性能"}]},{"ID":"20240309171159-k2vsnh7","Type":"NodeParagraph","Properties":{"id":"20240309171159-k2vsnh7","updated":"20240309171218"},"Children":[{"Type":"NodeText","Data":"有两种利用并发来提高性能的方式："}]},{"ID":"20240309171219-47mna5m","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240309171219-47mna5m","updated":"20240309171221"},"Children":[{"ID":"20240309171221-xehacra","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240309171221-xehacra","updated":"20240309171221"},"Children":[{"ID":"20240309171221-rl47439","Type":"NodeParagraph","Properties":{"id":"20240309171221-rl47439","updated":"20240309171230"},"Children":[{"Type":"NodeText","Data":"将一个单个任务分成几部分并行运行，从而降低总运行时间，这就是任务并行(task parallelism)。"}]}]},{"ID":"20240309171231-ydktaun","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240309171231-ydktaun"},"Children":[{"ID":"20240309171231-j6u4xsz","Type":"NodeParagraph","Properties":{"id":"20240309171231-j6u4xsz","updated":"20240309171354"},"Children":[{"Type":"NodeText","Data":"利用并行来解决更大的问题：每次只处理一个文件，不如处理2个、10个或20个。"}]}]}]}]},{"ID":"20240309171355-r572rep","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20240309171355-r572rep"},"Children":[{"ID":"20240309171355-lpes0v3","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240309171355-lpes0v3","updated":"20240309171930"},"Children":[{"Type":"NodeText","Data":"什么时候不使用并发（使用线程的注意）？"}]},{"ID":"20240309171402-5zs70eh","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240309171402-5zs70eh","updated":"20240309171540"},"Children":[{"ID":"20240309171540-a9cexhh","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240309171540-a9cexhh","updated":"20240309171540"},"Children":[{"ID":"20240309171540-entdlno","Type":"NodeParagraph","Properties":{"id":"20240309171540-entdlno","updated":"20240309171540"},"Children":[{"Type":"NodeText","Data":"不使用并发的唯一原因就是收益比不上成本。"}]},{"ID":"20240309171543-sks1gw5","Type":"NodeParagraph","Properties":{"id":"20240309171543-sks1gw5","updated":"20240309171543"},"Children":[{"Type":"NodeText","Data":"除非潜在的性能增益足够大或关注点分离地足够清晰，能抵消为确保正确开发所需的额外时间，以及维护代码的额外成本；否则，勿用并发。"}]}]},{"ID":"20240309171548-xhj7lpf","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240309171548-xhj7lpf"},"Children":[{"ID":"20240309171548-etyviin","Type":"NodeParagraph","Properties":{"id":"20240309171548-etyviin","updated":"20240309171559"},"Children":[{"Type":"NodeText","Data":"性能增益可能会小于预期。"}]},{"ID":"20240309171600-qyzr9tz","Type":"NodeParagraph","Properties":{"id":"20240309171600-qyzr9tz","updated":"20240309171608"},"Children":[{"Type":"NodeText","Data":"启动线程时存在固有开销，因为操作系统需要分配内核资源和堆栈空间，才能把新线程加入调度器中。如果在线程上的任务完成得很快，那么实际执行任务的时间要比启动线程的时间小很多，这会导致应用的整体性能不如直接使用单线程。"}]}]},{"ID":"20240309171610-9w825fi","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20240309171610-9w825fi"},"Children":[{"ID":"20240309171610-16a12t0","Type":"NodeParagraph","Properties":{"id":"20240309171610-16a12t0","updated":"20240309171614"},"Children":[{"Type":"NodeText","Data":"线程的资源有限。"}]},{"ID":"20240309171614-d7rx8me","Type":"NodeParagraph","Properties":{"id":"20240309171614-d7rx8me","updated":"20240309171735"},"Children":[{"Type":"NodeText","Data":"如果太多的线程同时运行，则会消耗很多操作系统资源，从而使得操作系统整体上运行得更加缓慢。"}]}]},{"ID":"20240309171745-08gphaw","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20240309171745-08gphaw"},"Children":[{"ID":"20240309171745-h9fjvay","Type":"NodeParagraph","Properties":{"id":"20240309171745-h9fjvay","updated":"20240309171749"},"Children":[{"Type":"NodeText","Data":"最后，运行越多的线程，操作系统就需要越多的上下文切换，每一次切换都需要耗费时间。"}]}]}]},{"ID":"20240309171818-raauwvv","Type":"NodeParagraph","Properties":{"id":"20240309171818-raauwvv","updated":"20240309171824"},"Children":[{"Type":"NodeText","Data":"应用中只有性能关键部分，才值得并发化。当然，如果性能收益仅次于设计清晰或分离关注点，也可以使用多线程。"}]}]}]},{"ID":"20240309172148-556guzr","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240309172148-556guzr","updated":"20240309172159"},"Children":[{"Type":"NodeText","Data":"1.4 入门"}]},{"ID":"20240309172200-tvanjem","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240309172200-tvanjem","updated":"20240309172458"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"#include \u003ciostream\u003e\n#include \u003cthread\u003e\n\nvoid hello() {\n    std::cout \u003c\u003c \"hello concurrent world!\";\n}\n\nint main() {\n    std::thread t(hello);\n    t.join();\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240309171418-qzjzp07","Type":"NodeParagraph","Properties":{"id":"20240309171418-qzjzp07","updated":"20240309172526"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"初始线程是main()，但是对于其他线程，可以在"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::thread"},{"Type":"NodeText","Data":"​对象的构造函数中指定——本例中命名为"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"t"},{"Type":"NodeText","Data":"​的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::thread"},{"Type":"NodeText","Data":"​对象拥有新函数hello()作为其执行函数"}]},{"ID":"20240309172527-obw02pl","Type":"NodeParagraph","Properties":{"id":"20240309172527-obw02pl","updated":"20240309172536"},"Children":[{"Type":"NodeText","Data":"与直接写入标准输出或是从main()调用hello()不同，该程序启动了一个全新的线程来实现，将线程数量一分为二——初始线程始于main()，而新线程始于hello()。"}]},{"ID":"20240309172556-mrki88k","Type":"NodeParagraph","Properties":{"id":"20240309172556-mrki88k","updated":"20240309172559"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"新的线程启动之后③，初始线程继续执行。如果它不等待新线程结束，就运行到main()函数结束——有可能发生在新线程运行之前。这就是为什么在④这里调用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"join()"},{"Type":"NodeText","Data":"​的原因。"}]}]}