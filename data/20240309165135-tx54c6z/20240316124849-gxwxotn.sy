{"ID":"20240316124849-gxwxotn","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240316124849-gxwxotn","title":"Chapter3 共享数据","type":"doc","updated":"20240509101542"},"Children":[{"ID":"20240316124849-6mqjeli","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240316124849-6mqjeli","updated":"20240317114636"},"Children":[{"Type":"NodeText","Data":"3.1 共享数据的问题"}]},{"ID":"20240317114657-hmlcomc","Type":"NodeParagraph","Properties":{"id":"20240317114657-hmlcomc","updated":"20240317114712"},"Children":[{"Type":"NodeText","Data":"问题主要是共享数据的修改引起。如果共享数据只读，那么不会影响到数据，更不会对数据进行修改，所有线程都会获得同样的数据。"}]},{"ID":"20240317114754-df034rd","Type":"NodeParagraph","Properties":{"id":"20240317114754-df034rd","updated":"20240317114802"},"Children":[{"Type":"NodeText","Data":"共享数据的更新通常会破坏不变量，特别是复杂的数据结构。"}]},{"ID":"20240317114806-nhrusu1","Type":"NodeParagraph","Properties":{"id":"20240317114806-nhrusu1","updated":"20240317114814"},"Children":[{"Type":"NodeText","Data":"线程间的问题在于修改共享数据，会使不变量遭到破坏。"}]},{"ID":"20240317114835-dm8ykwc","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240317114835-dm8ykwc","updated":"20240317114849"},"Children":[{"Type":"NodeText","Data":"3.1.2 条件竞争"}]},{"ID":"20240317114849-it9e6pb","Type":"NodeParagraph","Properties":{"id":"20240317114849-it9e6pb","updated":"20240317114909"},"Children":[{"Type":"NodeText","Data":"并发中的竞争条件，取决于一个以上线程的执行顺序，每个线程都抢着完成自己的任务。大多数情况下，即使改变执行顺序，也是良性竞争，结果是可以接受的。"}]},{"ID":"20240317114922-cgzgkqi","Type":"NodeParagraph","Properties":{"id":"20240317114922-cgzgkqi","updated":"20240317114937"},"Children":[{"Type":"NodeText","Data":"当不变量遭到破坏时，才会产生条件竞争。恶性条件竞争通常发生于对多个数据块的修改。"}]},{"ID":"20240317114950-xztdvbu","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240317114950-xztdvbu","updated":"20240317114959"},"Children":[{"Type":"NodeText","Data":"3.1.2 避免条件竞争"}]},{"ID":"20240317115000-v7q1e5f","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240317115000-v7q1e5f","updated":"20240317115135"},"Children":[{"ID":"20240317115004-i8f6ctx","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240317115004-i8f6ctx","updated":"20240317115004"},"Children":[{"ID":"20240317115004-k1x6z1q","Type":"NodeParagraph","Properties":{"id":"20240317115004-k1x6z1q","updated":"20240317115010"},"Children":[{"Type":"NodeText","Data":"最简单的办法就是对数据结构采用某种保护机制，确保只有修改线程才能看到不变量的中间状态。"}]}]},{"ID":"20240317115024-9tfy85e","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240317115024-9tfy85e"},"Children":[{"ID":"20240317115024-t8uikeq","Type":"NodeParagraph","Properties":{"id":"20240317115024-t8uikeq","updated":"20240317115024"},"Children":[{"Type":"NodeText","Data":"对数据结构和不变量进行修改，修改完的结构必须能完成一系列不可分割的变化，也就保证了每个不变量的状态，这就是所谓的无锁编程。"}]}]},{"ID":"20240317115048-9ky4kr7","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20240317115048-9ky4kr7","updated":"20240317115135"},"Children":[{"ID":"20240317115048-he5bw7d","Type":"NodeParagraph","Properties":{"id":"20240317115048-he5bw7d","updated":"20240317115135"},"Children":[{"Type":"NodeText","Data":"使用事务的方式去处理数据结构的更新。所需的一些数据和读取都存储在事务日志中，然后将之前的操作进行合并，再进行提交。当数据结构被另一个线程修改后，或处理已经重启的情况下，提交就会无法进行，这称作为“"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color6);"},"TextMarkType":"text","TextMarkTextContent":"软件事务内存"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color6);\"}"},{"Type":"NodeText","Data":"”(software transactional memory (STM))。"}]}]}]},{"ID":"20240317115133-qqjlpxh","Type":"NodeParagraph","Properties":{"id":"20240317115133-qqjlpxh","updated":"20240317115142"},"Children":[{"Type":"NodeText","Data":"保护共享数据结构的最基本的方式，使用C++标准库提供的互斥量。"}]},{"ID":"20240317115147-i4ubfhf","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240317115147-i4ubfhf","updated":"20240317115152"},"Children":[{"Type":"NodeText","Data":"3.2 使用互斥量"}]},{"ID":"20240317115152-n0401xm","Type":"NodeParagraph","Properties":{"id":"20240317115152-n0401xm","updated":"20240317115236"},"Children":[{"Type":"NodeText","Data":"互斥量是C++保护数据最通用的机制。"}]},{"ID":"20240317115236-tsjj6q9","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240317115236-tsjj6q9","updated":"20240317115257"},"Children":[{"Type":"NodeText","Data":"3.2.1 互斥量"}]},{"ID":"20240317115257-37y2376","Type":"NodeParagraph","Properties":{"id":"20240317115257-37y2376","updated":"20240317115427"},"Children":[{"Type":"NodeText","Data":"通过实例化"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::mutex"},{"Type":"NodeText","Data":"​创建互斥量实例，成员函数lock()可对互斥量上锁，unlock()为解锁。C++标准库为互斥量提供了RAII模板类"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::lock_guard"},{"Type":"NodeText","Data":"​，在构造时就能提供已锁的互斥量，并在析构时进行解锁，从而保证了互斥量能被正确解锁。如下"}]},{"ID":"20240317115331-ngamkvj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240317115331-ngamkvj","updated":"20240317115702"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"std::list\u003cint\u003e some_list;\nstd::mutex some_mutex;\n\nvoid add_to_list(int new_val) {\n    std::lock_guard\u003cstd::mutex\u003e guard(some_mutex);\n    some_list.push_back(new_val);\n}\n\nbool list_contains(int value_to_find)\n{\n  std::lock_guard\u003cstd::mutex\u003e guard(some_mutex);  \n  return std::find(some_list.begin(),some_list.end(),value_to_find) != some_list.end();\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240317115703-ryvsms0","Type":"NodeParagraph","Properties":{"id":"20240317115703-ryvsms0","updated":"20240317120528"},"Children":[{"Type":"NodeText","Data":"在C++17的环境中，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::lock_guard\u0026lt;std::mutex\u0026gt; guard(some_mutex);"},{"Type":"NodeText","Data":"​可以简化为"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::lock_guard guard(some_mutex);"},{"Type":"NodeText","Data":"​C++17还提供了加强的数据保护机制"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::scoped_lock"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20240317120327-e1zqu9p","Type":"NodeParagraph","Properties":{"id":"20240317120327-e1zqu9p","updated":"20240317120526"},"Children":[{"Type":"NodeText","Data":"某些情况下使用全局变量没问题，但大多数情况下，互斥量通常会与需要保护的数据放在同一类中，而不是定义成全局变量。"}]},{"ID":"20240317120550-dsgb3mq","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240317120550-dsgb3mq","updated":"20240317120557"},"Children":[{"Type":"NodeText","Data":"3.2.2 保护共享数据"}]},{"ID":"20240317120558-r1perxt","Type":"NodeParagraph","Properties":{"id":"20240317120558-r1perxt","updated":"20240317120643"},"Children":[{"Type":"NodeText","Data":"请看下述代码："}]},{"ID":"20240317120643-z42fvzd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240317120643-z42fvzd","updated":"20240317120650"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"class some_data\n{\n  int a;\n  std::string b;\npublic:\n  void do_something();\n};\n\nclass data_wrapper\n{\nprivate:\n  some_data data;\n  std::mutex m;\npublic:\n  template\u003ctypename Function\u003e\n  void process_data(Function func)\n  {\n    std::lock_guard\u003cstd::mutex\u003e l(m);\n    func(data);    // 1 传递“保护”数据给用户函数\n  }\n};\n\nsome_data* unprotected;\n\nvoid malicious_function(some_data\u0026 protected_data)\n{\n  unprotected=\u0026protected_data;\n}\n\ndata_wrapper x;\nvoid foo()\n{\n  x.process_data(malicious_function);    // 2 传递一个恶意函数\n  unprotected-\u003edo_something();    // 3 在无保护的情况下访问保护数据\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240317120755-5ravh17","Type":"NodeParagraph","Properties":{"id":"20240317120755-5ravh17","updated":"20240317120944"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"foo()"},{"Type":"NodeText","Data":"​绕过了保护机制将函数"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"malicious_function"},{"Type":"NodeText","Data":"​传递进取，这样就会在没有互斥锁下调用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"do_something"},{"Type":"NodeText","Data":"​(③处)。"}]},{"ID":"20240317120944-a5g5s27","Type":"NodeParagraph","Properties":{"id":"20240317120944-a5g5s27","updated":"20240317121012"},"Children":[{"Type":"NodeText","Data":"想要杜绝此问题牢记："}]},{"ID":"20240317121012-f0jks3l","Type":"NodeParagraph","Properties":{"id":"20240317121012-f0jks3l","updated":"20240317121019"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color6);"},"TextMarkType":"strong em text","TextMarkTextContent":"切勿将受保护数据的指针或引用传递到互斥锁作用域之外。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color6);\"}"}]},{"ID":"20240317121021-01ygqog","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240317121021-01ygqog","updated":"20240317121037"},"Children":[{"Type":"NodeText","Data":"3.2.3 接口间的条件竞争"}]},{"ID":"20240317121037-qpti9zq","Type":"NodeParagraph","Properties":{"id":"20240317121037-qpti9zq","updated":"20240317121144"},"Children":[{"Type":"NodeText","Data":"请看下面的代码："}]},{"ID":"20240317121144-ffq8vy8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240317121144-ffq8vy8","updated":"20240317121151"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"template\u003ctypename T,typename Container=std::deque\u003cT\u003e \u003e\nclass stack\n{\npublic:\n  explicit stack(const Container\u0026);\n  explicit stack(Container\u0026\u0026 = Container());\n  template \u003cclass Alloc\u003e explicit stack(const Alloc\u0026);\n  template \u003cclass Alloc\u003e stack(const Container\u0026, const Alloc\u0026);\n  template \u003cclass Alloc\u003e stack(Container\u0026\u0026, const Alloc\u0026);\n  template \u003cclass Alloc\u003e stack(stack\u0026\u0026, const Alloc\u0026);\n  \n  bool empty() const;\n  size_t size() const;\n  T\u0026 top();\n  T const\u0026 top() const;\n  void push(T const\u0026);\n  void push(T\u0026\u0026);\n  void pop();\n  void swap(stack\u0026\u0026);\n  template \u003cclass... Args\u003e void emplace(Args\u0026\u0026... args); // C++14的新特性\n};\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240317121153-4nse7uo","Type":"NodeParagraph","Properties":{"id":"20240317121153-4nse7uo","updated":"20240317121308"},"Children":[{"Type":"NodeText","Data":"虽然"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"empty()"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"size()"},{"Type":"NodeText","Data":"​返回时可能是正确的，但是结果并不可靠。返回后其他线程就可以自由访问栈并可能"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"push()"},{"Type":"NodeText","Data":"​多个和元素到栈中。这样之前从"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"empty()"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"size()"},{"Type":"NodeText","Data":"​得到的数据就有问题了。"}]},{"ID":"20240317121340-wbcmp03","Type":"NodeParagraph","Properties":{"id":"20240317121340-wbcmp03","updated":"20240317121406"},"Children":[{"Type":"NodeText","Data":"在非共享栈对象下，下面代码是安全的"}]},{"ID":"20240317121406-tecb3xb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240317121406-tecb3xb","updated":"20240317121418"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"stack\u003cint\u003e s;\nif (! s.empty()){   \t\t\t// 1\n  int const value = s.top();    // 2\n  s.pop();    \t\t\t\t\t// 3\n  do_something(value);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240317121419-h1mb548","Type":"NodeParagraph","Properties":{"id":"20240317121419-h1mb548","updated":"20240317121539"},"Children":[{"Type":"NodeText","Data":"但是在共享栈对象下，1和2之间可能有其他线程进行"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"pop()"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20240317121734-gfo8obu","Type":"NodeParagraph","Properties":{"id":"20240317121734-gfo8obu","updated":"20240317122222"},"Children":[{"Type":"NodeText","Data":"一个全局互斥量要去保护全部共享数据，在一个系统中存在有大量的共享数据时，线程可以强制运行，甚至可以访问不同位置的数据，抵消了并发带来的性能提升。"}]},{"ID":"20240317122240-ruabb8c","Type":"NodeParagraph","Properties":{"id":"20240317122240-ruabb8c","updated":"20240317122241"},"Children":[{"Type":"NodeText","Data":"一个给定操作需要两个或两个以上的互斥量时，另一个潜在的问题将出现：死锁。与条件竞争完全相反——不同的两个线程会互相等待，从而什么都没做。"}]},{"ID":"20240317122245-k6k10nx","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240317122245-k6k10nx","updated":"20240317122250"},"Children":[{"Type":"NodeText","Data":"3.2.4 死锁"}]},{"ID":"20240317122251-e0o0n2d","Type":"NodeParagraph","Properties":{"id":"20240317122251-e0o0n2d","updated":"20240317122334"},"Children":[{"Type":"NodeText","Data":"线程有对锁的竞争："},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color6);"},"TextMarkType":"text","TextMarkTextContent":"一对线程需要对他们所有的互斥量做一些操作，其中每个线程都有一个互斥量，且等待另一个解锁。因为他们都在等待对方释放互斥量，没有线程能工作。这种情况就是死锁，它的问题就是由两个或两个以上的互斥量进行锁定。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color6);\"}"}]},{"ID":"20240317122343-f3p1iqk","Type":"NodeParagraph","Properties":{"id":"20240317122343-f3p1iqk","updated":"20240317122402"},"Children":[{"Type":"NodeText","Data":"避免死锁的一般建议，就是"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color6);"},"TextMarkType":"text","TextMarkTextContent":"让两个互斥量以相同的顺序上锁"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color6);\"}"},{"Type":"NodeText","Data":"：总在互斥量B之前锁住互斥量A，就永远不会死锁。"}]},{"ID":"20240317122534-ahszg7o","Type":"NodeBlockquote","Properties":{"id":"20240317122534-ahszg7o","updated":"20240317122545"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240317122545-naqn9ii","Type":"NodeParagraph","Properties":{"id":"20240317122545-naqn9ii","updated":"20240317122545"},"Children":[{"Type":"NodeText","Data":"某些情况下是可以这样用，因为不同的互斥量用于不同的地方。不过，当有多个互斥量保护同一个类的独立实例时，一个操作对同一个类的两个不同实例进行数据的交换操作，为了保证数据交换操作的正确性，就要避免并发修改数据，并确保每个实例上的互斥量都能锁住自己要保护的区域。不过，选择一个固定的顺序(例如，实例提供的第一互斥量作为第一个参数，提供的第二个互斥量为第二个参数)，可能会适得其反：在参数交换了之后，两个线程试图在相同的两个实例间进行数据交换时，程序又死锁了！"}]}]},{"ID":"20240317122547-ln1bjab","Type":"NodeParagraph","Properties":{"id":"20240317122547-ln1bjab","updated":"20240317122650"},"Children":[{"Type":"NodeText","Data":"很幸运，C++标准库有办法解决这个问题"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::lock"},{"Type":"NodeText","Data":"​——可以一次性锁住多个(两个以上)的互斥量，并且没有副作用(死锁风险)。"}]},{"ID":"20240317122651-6dl43wr","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240317122651-6dl43wr","updated":"20240317123015"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"class SomeBigObject {\n}\n\nvoid swap(SomeBigObject\u0026 lhs, SomeBigObject\u0026 rhs);\n\nclass X {\nprivate:\n    SomeBigObject obj;\n    std::mutex m;\n\npublic:\n    X(const SomeBigObject\u0026 sd)\n        : obj(sd)\n    {\n    }\n\n    friend void swap(X\u0026 lhs, X\u0026 rhs)\n    {\n        if (\u0026lhs == \u0026rhs)\n            return;\n        std::lock(lhs.m, rhs.m); \t\t\t\t\t\t// 1\n        std::lock_guard lock_a(lhs.m, std::adopt_lock); // 2\n        std::lock_guard lock_b(rhs.m, std::adopt_lock); // 3\n        swap(lhs.obj, rhs.obj);\n    }\n};\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240317123018-1j69afi","Type":"NodeList","ListData":{},"Properties":{"id":"20240317123018-1j69afi","updated":"20240317123214"},"Children":[{"ID":"20240317123105-dcpkndg","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240317123105-dcpkndg","updated":"20240317123105"},"Children":[{"ID":"20240317123105-8alm7r8","Type":"NodeParagraph","Properties":{"id":"20240317123105-8alm7r8","updated":"20240317123121"},"Children":[{"Type":"NodeText","Data":"①：锁住两个互斥量"}]}]},{"ID":"20240317123122-df50hsl","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240317123122-df50hsl","updated":"20240317123214"},"Children":[{"ID":"20240317123122-ovvddj5","Type":"NodeParagraph","Properties":{"id":"20240317123122-ovvddj5","updated":"20240317123214"},"Children":[{"Type":"NodeText","Data":"②③：创建两个"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::lock_guard"},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::adopt_lock"},{"Type":"NodeText","Data":"​参数除了表示"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::lock_guard"},{"Type":"NodeText","Data":"​可获取锁之外，还将锁交由"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::lock_guard"},{"Type":"NodeText","Data":"​管理，就不需要"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::lock_guard"},{"Type":"NodeText","Data":"​再去构建新的锁了。"}]}]}]},{"ID":"20240317123304-voosaso","Type":"NodeParagraph","Properties":{"id":"20240317123304-voosaso","updated":"20240317123351"},"Children":[{"Type":"NodeText","Data":"如果"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::lock"},{"Type":"NodeText","Data":"​获取其中一个锁时抛出异常，那么之前获得的锁会自动析构，所以要么全锁上，要么全不锁。"}]},{"ID":"20240317123407-3ncou46","Type":"NodeParagraph","Properties":{"id":"20240317123407-3ncou46","updated":"20240317123419"},"Children":[{"Type":"NodeText","Data":"C++17提供了方便的支持，例如："}]},{"ID":"20240317123420-8f6apl8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240317123420-8f6apl8","updated":"20240317123515"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"friend void swap(X\u0026 lhs, X\u0026 rhs)\n{\n    if (\u0026lhs == \u0026rhs)\n        return;\n    std::scoped_lock guard(lhs.m, rhs.m);\n    swap(lhs.obj, rhs.obj);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240317123539-tazycqe","Type":"NodeParagraph","Properties":{"id":"20240317123539-tazycqe","updated":"20240317123539"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::scoped_lock"},{"Type":"NodeText","Data":"​的好处在于，可以将所有"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::lock"},{"Type":"NodeText","Data":"​替换掉，从而减少错误的发生。"}]},{"ID":"20240317123547-ypp3kle","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240317123547-ypp3kle","updated":"20240317123556"},"Children":[{"Type":"NodeText","Data":"3.2.5 避免死锁的进阶指导"}]},{"ID":"20240317123557-46drl2m","Type":"NodeParagraph","Properties":{"id":"20240317123557-46drl2m","updated":"20240317123834"},"Children":[{"Type":"NodeText","Data":"死锁通常是对锁的使用不当造成。无锁的情况下，仅需要两个线程"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::thread"},{"Type":"NodeText","Data":"​对象互相调用join()就能产生死锁。"}]},{"ID":"20240317123835-vy9mzgp","Type":"NodeParagraph","Properties":{"id":"20240317123835-vy9mzgp","updated":"20240317123852"},"Children":[{"Type":"NodeText","Data":"下面是一些建议："}]},{"ID":"20240317123852-71fy5g9","Type":"NodeList","ListData":{},"Properties":{"id":"20240317123852-71fy5g9","updated":"20240509101542"},"Children":[{"ID":"20240317123853-adfkfdr","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240317123853-adfkfdr","updated":"20240317123853"},"Children":[{"ID":"20240317123853-cx7iaoh","Type":"NodeParagraph","Properties":{"id":"20240317123853-cx7iaoh","updated":"20240317123859"},"Children":[{"Type":"NodeText","Data":"避免嵌套锁"}]},{"ID":"20240317123909-7aich68","Type":"NodeParagraph","Properties":{"id":"20240317123909-7aich68","updated":"20240317123911"},"Children":[{"Type":"NodeText","Data":"线程获得一个锁时，就别再去获取第二个。每个线程只持有一个锁，就不会产生死锁。"}]}]},{"ID":"20240317123911-9vnn92j","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240317123911-9vnn92j","updated":"20240509101542"},"Children":[{"ID":"20240317123911-mbv95a9","Type":"NodeParagraph","Properties":{"id":"20240317123911-mbv95a9","updated":"20240509101542"},"Children":[{"Type":"NodeText","Data":"避免在持有锁时调用外部代码"}]},{"ID":"20240317123922-rex00i1","Type":"NodeParagraph","Properties":{"id":"20240317123922-rex00i1","updated":"20240317123952"},"Children":[{"Type":"NodeText","Data":"第二个建议是次简单的：因为代码是外部提供的，所以没有办法确定外部要做什么。外部程序可能做任何事情，包括获取锁。在持有锁的情况下，如果用外部代码要获取一个锁，就会违反第一个指导意见，并造成死锁(有时这是无法避免的)。"}]}]},{"ID":"20240317124003-5enro85","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240317124003-5enro85","updated":"20240317124124"},"Children":[{"ID":"20240317124003-bz86fl3","Type":"NodeParagraph","Properties":{"id":"20240317124003-bz86fl3","updated":"20240317124007"},"Children":[{"Type":"NodeText","Data":"使用固定顺序获取锁"}]},{"ID":"20240317124120-n47kggx","Type":"NodeParagraph","Properties":{"id":"20240317124120-n47kggx","updated":"20240317124124"},"Children":[{"Type":"NodeText","Data":"当硬性要求获取两个或两个以上的锁，并且不能使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::lock"},{"Type":"NodeText","Data":"​单独操作来获取它们时，最好在每个线程上，用固定的顺序获取它们(锁)。"}]}]}]},{"ID":"20240317124125-vxzw4hg","Type":"NodeList","ListData":{},"Properties":{"id":"20240317124125-vxzw4hg","updated":"20240319123149"},"Children":[{"ID":"20240317124655-cjdrga8","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240317124655-cjdrga8","updated":"20240319123149"},"Children":[{"ID":"20240317124655-sl82pgw","Type":"NodeParagraph","Properties":{"id":"20240317124655-sl82pgw","updated":"20240317124701"},"Children":[{"Type":"NodeText","Data":"使用层次锁结构"}]},{"ID":"20240319121215-gq6v0ph","Type":"NodeParagraph","Properties":{"id":"20240319121215-gq6v0ph","updated":"20240319121553"},"Children":[{"Type":"NodeText","Data":"虽然，定义锁的顺序是一种特殊情况，但层次锁的意义在于，在运行时会约定是否进行检查。这个建议需要对应用进行分层，并且识别在给定层上所有互斥量。当代码试图对互斥量上锁，而低层已持有该层锁时，不允许锁定."}]},{"ID":"20240319121604-1k67qeb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240319121604-1k67qeb","updated":"20240319121608"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qw=="},{"Type":"NodeCodeBlockCode","Data":"hierarchical_mutex high_level_mutex(10000); // 1\nhierarchical_mutex low_level_mutex(5000);  // 2\nhierarchical_mutex other_mutex(6000); // 3\n\nint do_low_level_stuff();\n\nint low_level_func()\n{\n  std::lock_guard\u003chierarchical_mutex\u003e lk(low_level_mutex); // 4\n  return do_low_level_stuff();\n}\n\nvoid high_level_stuff(int some_param);\n\nvoid high_level_func()\n{\n  std::lock_guard\u003chierarchical_mutex\u003e lk(high_level_mutex); // 6\n  high_level_stuff(low_level_func()); // 5\n}\n\nvoid thread_a()  // 7\n{\n  high_level_func();\n}\n\nvoid do_other_stuff();\n\nvoid other_stuff()\n{\n  high_level_func();  // 10\n  do_other_stuff();\n}\n\nvoid thread_b() // 8\n{\n  std::lock_guard\u003chierarchical_mutex\u003e lk(other_mutex); // 9\n  other_stuff();\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240319121559-rq5xlgz","Type":"NodeParagraph","Properties":{"id":"20240319121559-rq5xlgz","updated":"20240319121702"},"Children":[{"Type":"NodeText","Data":"①②③处定义了三个层次锁示例，假如将这三个实例中的一个上锁，那么只能获得更底层次实例上的锁。"}]},{"ID":"20240319121703-h6g8d22","Type":"NodeParagraph","Properties":{"id":"20240319121703-h6g8d22","updated":"20240319122000"},"Children":[{"Type":"NodeText","Data":"假设"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"do_low_level_staff()"},{"Type":"NodeText","Data":"​不会对任何互斥量进行上锁，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"low_level_func"},{"Type":"NodeText","Data":"​为层次最低的函数，且会对"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"low_level_mutex"},{"Type":"NodeText","Data":"​进行上锁（④），"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"high_level_func"},{"Type":"NodeText","Data":"​调用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"low_level_func"},{"Type":"NodeText","Data":"​时会同时持有"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"high_level_mutex"},{"Type":"NodeText","Data":"​与"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"low_level_mutex"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20240319122046-w9f71xa","Type":"NodeParagraph","Properties":{"id":"20240319122046-w9f71xa","updated":"20240319122059"},"Children":[{"Type":"NodeText","Data":"而⑧处无视规则，运行时会失效。"}]},{"ID":"20240319122150-q4snai0","Type":"NodeBlockquote","Properties":{"id":"20240319122150-q4snai0","updated":"20240319122150"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240319122150-4g6neuz","Type":"NodeParagraph","Properties":{"id":"20240319122150-4g6neuz","updated":"20240319122213"},"Children":[{"Type":"NodeText","Data":"首先，thread_b锁住了"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"other_mutex"},{"Type":"NodeText","Data":"​⑨，这个互斥量的层级值只有6000③。这就意味着，中层级的数据已被保护。当"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"other_stuff()"},{"Type":"NodeText","Data":"​调用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"high_level_func()"},{"Type":"NodeText","Data":"​⑧时，就违反了层级结构："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"high_level_func()"},{"Type":"NodeText","Data":"​试图获取"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"high_level_mutex"},{"Type":"NodeText","Data":"​，这个互斥量的层级值是10000，要比当前层级值6000大很多。因此"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"hierarchical_mutex"},{"Type":"NodeText","Data":"​将会产生一个错误，可能会是抛出一个异常或直接终止程序。"}]}]},{"ID":"20240319122059-kimnghl","Type":"NodeParagraph","Properties":{"id":"20240319122059-kimnghl","updated":"20240319122227"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color6);"},"TextMarkType":"text","TextMarkTextContent":"层级互斥量不可能死锁，因为互斥量本身会严格遵循约定进行上锁。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color6);\"}"}]},{"ID":"20240319122242-kivirkt","Type":"NodeParagraph","Properties":{"id":"20240319122242-kivirkt","updated":"20240319122252"},"Children":[{"Type":"NodeText","Data":"一个简答的层次互斥锁的实现："}]},{"ID":"20240319122253-c1alzxt","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240319122253-c1alzxt","updated":"20240319123149"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"class hierarchical_mutex\n{\n  std::mutex internal_mutex;\n  \n  unsigned long const hierarchy_value;\n  unsigned long previous_hierarchy_value;\n  \n  static thread_local unsigned long this_thread_hierarchy_value;  // 1\n  \n  void check_for_hierarchy_violation()\n  {\n    if(this_thread_hierarchy_value \u003c= hierarchy_value)  // 2\n    {\n      throw std::logic_error(“mutex hierarchy violated”);\n    }\n  }\n  \n  void update_hierarchy_value()\n  {\n    previous_hierarchy_value=this_thread_hierarchy_value;  // 3\n    this_thread_hierarchy_value=hierarchy_value;\n  }\n  \npublic:\n  explicit hierarchical_mutex(unsigned long value):\n      hierarchy_value(value),\n      previous_hierarchy_value(0)\n  {}\n  \n  void lock()\n  {\n    check_for_hierarchy_violation();\n    internal_mutex.lock();  // 4\n    update_hierarchy_value();  // 5\n  }\n  \n  void unlock()\n  {\n    if(this_thread_hierarchy_value!=hierarchy_value)\n      throw std::logic_error(“mutex hierarchy violated”);  // 9\n    this_thread_hierarchy_value=previous_hierarchy_value;  // 6\n    internal_mutex.unlock();\n  }\n  \n  bool try_lock()\n  {\n    check_for_hierarchy_violation();\n    if(!internal_mutex.try_lock())  // 7\n      return false;\n    update_hierarchy_value();\n    return true;\n  }\n};\nthread_local unsigned long\n     hierarchical_mutex::this_thread_hierarchy_value(ULONG_MAX);  // 8\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}]},{"ID":"20240319121530-vuhmcl1","Type":"NodeList","ListData":{},"Properties":{"id":"20240319121530-vuhmcl1","updated":"20240319123152"},"Children":[{"ID":"20240319123152-orsjjyl","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240319123152-orsjjyl","updated":"20240319123152"},"Children":[{"ID":"20240319123152-5s5dtg3","Type":"NodeParagraph","Properties":{"id":"20240319123152-5s5dtg3","updated":"20240319123156"},"Children":[{"Type":"NodeText","Data":"超越锁"}]}]}]},{"ID":"20240319123249-ruj35qb","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240319123249-ruj35qb","updated":"20240319123310"},"Children":[{"Type":"NodeText","Data":"3.2.6 std::unique_lock 灵活的锁"}]},{"ID":"20240319123621-v7f5smg","Type":"NodeParagraph","Properties":{"id":"20240319123621-v7f5smg","updated":"20240319123621"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::unqiue_lock"},{"Type":"NodeText","Data":"​使用起来更为自由，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::unique_lock"},{"Type":"NodeText","Data":"​实例不会总与互斥量的数据类型相关，使用起来要比"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std:lock_guard"},{"Type":"NodeText","Data":"​更加灵活。"}]},{"ID":"20240319123643-nw9448f","Type":"NodeList","ListData":{},"Properties":{"id":"20240319123643-nw9448f","updated":"20240319123856"},"Children":[{"ID":"20240319123644-57zt4h7","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240319123644-57zt4h7","updated":"20240319123644"},"Children":[{"ID":"20240319123644-er1bysv","Type":"NodeParagraph","Properties":{"id":"20240319123644-er1bysv","updated":"20240319123644"},"Children":[{"Type":"NodeText","Data":"首先，可将"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::adopt_lock"},{"Type":"NodeText","Data":"​作为第二个参数传入构造函数，对互斥量进行管理。"}]}]},{"ID":"20240319123648-i5t2946","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240319123648-i5t2946"},"Children":[{"ID":"20240319123648-tc7e27g","Type":"NodeParagraph","Properties":{"id":"20240319123648-tc7e27g","updated":"20240319123705"},"Children":[{"Type":"NodeText","Data":"也可以将"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::defer_lock"},{"Type":"NodeText","Data":"​作为第二个参数传递进去，表明互斥量应保持解锁状态。"}]}]},{"ID":"20240319123655-ysclejm","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240319123655-ysclejm","updated":"20240319123735"},"Children":[{"ID":"20240319123655-l3c72r9","Type":"NodeParagraph","Properties":{"id":"20240319123655-l3c72r9","updated":"20240319123735"},"Children":[{"Type":"NodeText","Data":"可以将"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::unique_lock"},{"Type":"NodeText","Data":"​对象传递到到"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::lock()"},{"Type":"NodeText","Data":"​中。"}]}]},{"ID":"20240319123732-fd1z32v","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240319123732-fd1z32v","updated":"20240319123856"},"Children":[{"ID":"20240319123732-l1fah0v","Type":"NodeParagraph","Properties":{"id":"20240319123732-l1fah0v","updated":"20240319123856"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::unique_lock"},{"Type":"NodeText","Data":"​会占用比较多的空间，并且比"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::lock_guard"},{"Type":"NodeText","Data":"​稍慢一些。保证灵活性要付出代价，这个代价就是允许"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::unique_lock"},{"Type":"NodeText","Data":"​实例不带互斥量：信息已存储，且已更新(携带lock的指针)。"}]}]}]},{"ID":"20240319123621-dql3khi","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240319123621-dql3khi","updated":"20240319123635"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":" class some_big_object;\n void swap(some_big_object\u0026 lhs,some_big_object\u0026 rhs);\n class X\n {\n private:\n   some_big_object some_detail;\n   std::mutex m;\n public:\n   X(some_big_object const\u0026 sd):some_detail(sd){}\n   friend void swap(X\u0026 lhs, X\u0026 rhs)\n   {\n     if(\u0026lhs==\u0026rhs)\n       return;\n     std::unique_lock\u003cstd::mutex\u003e lock_a(lhs.m,std::defer_lock); // 1 \n     std::unique_lock\u003cstd::mutex\u003e lock_b(rhs.m,std::defer_lock); // 1 std::defer_lock 留下未上锁的互斥量\n     std::lock(lock_a,lock_b); // 2 互斥量在这里上锁\n     swap(lhs.some_detail,rhs.some_detail);\n   }\n };\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240319123621-n8sujnh","Type":"NodeParagraph","Properties":{"id":"20240319123621-n8sujnh","updated":"20240319123932"},"Children":[{"Type":"NodeText","Data":"除非想将"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::unique_lock"},{"Type":"NodeText","Data":"​的所有权进行转让，最好使用C++17中提供的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::scoped_lock"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20240319123923-m5ni53r","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240319123923-m5ni53r","updated":"20240319124000"},"Children":[{"Type":"NodeText","Data":"3.2.7 不同域中互斥量的传递"}]},{"ID":"20240319124001-4kaga0b","Type":"NodeParagraph","Properties":{"id":"20240319124001-4kaga0b","updated":"20240319124011"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::unique_lock"},{"Type":"NodeText","Data":"​实例没有与自身相关的互斥量，互斥量的所有权可以通过移动操作，在不同的实例中进行传递。"}]},{"ID":"20240319124029-rrqw3hs","Type":"NodeParagraph","Properties":{"id":"20240319124029-rrqw3hs","updated":"20240319124029"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::unique_lock"},{"Type":"NodeText","Data":"​是可移动，但不可赋值的类型。"}]},{"ID":"20240319124357-n0qkhqv","Type":"NodeParagraph","Properties":{"id":"20240319124357-n0qkhqv","updated":"20240319124358"},"Children":[{"Type":"NodeText","Data":"一种使用可能是允许函数去锁住一个互斥量，并且将所有权移到调用者上，所以调用者可以在这个锁保护的范围内执行额外的动作。"}]},{"ID":"20240319124359-5a26w6z","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240319124359-5a26w6z","updated":"20240319124402"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"std::unique_lock\u003cstd::mutex\u003e get_lock()\n{\n  extern std::mutex some_mutex;\n  std::unique_lock\u003cstd::mutex\u003e lk(some_mutex);\n  prepare_data();\n  return lk;  // 1\n}\nvoid process_data()\n{\n  std::unique_lock\u003cstd::mutex\u003e lk(get_lock());  // 2\n  do_something();\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240319124403-e67ym7t","Type":"NodeParagraph","Properties":{"id":"20240319124403-e67ym7t","updated":"20240319124531"},"Children":[{"Type":"NodeText","Data":"上面的代码中，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"process_data()函数直接转移"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::unique_lock"},{"Type":"NodeText","Data":"​实例的所有权②，调用do_something()可使用的正确数据(数据没有受到其他线程的修改)。"}]},{"ID":"20240319124547-jdc0vot","Type":"NodeParagraph","Properties":{"id":"20240319124547-jdc0vot","updated":"20240319124557"},"Children":[{"Type":"NodeText","Data":"通常这种模式会"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color6);"},"TextMarkType":"text","TextMarkTextContent":"用于已锁的互斥量"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color6);\"}"},{"Type":"NodeText","Data":"，其依赖于当前程序的状态，或依赖于传入返回类型为"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::unique_lock"},{"Type":"NodeText","Data":"​的函数(或以参数返回)。"}]},{"ID":"20240319124612-0faupqn","Type":"NodeParagraph","Properties":{"id":"20240319124612-0faupqn","updated":"20240319124615"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::unique_lock"},{"Type":"NodeText","Data":"​的灵活性同样也允许实例在销毁之前放弃拥有的锁。可以使用unlock()来做这件事。"}]},{"ID":"20240319124639-f9f9fxm","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240319124639-f9f9fxm","updated":"20240319124940"},"Children":[{"Type":"NodeText","Data":"3.3 保护共享数据的方式"}]},{"ID":"20240331101447-y2mff6p","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240331101447-y2mff6p","updated":"20240331101505"},"Children":[{"Type":"NodeText","Data":"3.2.1 保护共享数据的初始化过程"}]},{"ID":"20240319124648-g7hicg0","Type":"NodeParagraph","Properties":{"id":"20240319124648-g7hicg0","updated":"20240331101505"},"Children":[{"Type":"NodeText","Data":"对于双重检查锁模式："}]},{"ID":"20240331100631-x6y735a","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240331100631-x6y735a","updated":"20240331101505"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"void undefined_behaviour_with_double_checked_locking()\n{\n  if(!resource_ptr)  // 1\n  {\n    std::lock_guard\u003cstd::mutex\u003e lk(resource_mutex);\n    if(!resource_ptr)  // 2\n    {\n      resource_ptr.reset(new some_resource);  // 3\n    }\n  }\n  resource_ptr-\u003edo_something();  // 4\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240331100643-lseo1jp","Type":"NodeParagraph","Properties":{"id":"20240331100643-lseo1jp","updated":"20240331101505"},"Children":[{"Type":"NodeText","Data":"存在着潜在的条件竞争，未被锁保护的读取操作①没有与其他线程里被锁保护的写入操作③进行同步，因此就会产生条件竞争，这个条件竞争不仅覆盖指针本身，还会影响到其指向的对象；即使一个线程知道另一个线程完成对指针进行写入，它可能没有看到新创建的some_resource实例，然后调用do_something()④后，得到不正确的结果。"}]},{"ID":"20240331100910-rlpmg9z","Type":"NodeParagraph","Properties":{"id":"20240331100910-rlpmg9z","updated":"20240331101505"},"Children":[{"Type":"NodeText","Data":"为避免这种情况C++提供了"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::once_flag"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::call_once。"},{"Type":"NodeText","Data":"​"}]},{"ID":"20240331100927-yx7ve85","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240331100927-yx7ve85","updated":"20240331101505"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"std::shared_ptr\u003csome_resource\u003e resource_ptr;\nstd::once_flag resource_flag;  // 1\n\nvoid init_resource()\n{\n  resource_ptr.reset(new some_resource);\n}\n\nvoid foo()\n{\n  std::call_once(resource_flag,init_resource);  // 可以完整的进行一次初始化\n  resource_ptr-\u003edo_something();\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240331100922-yytq0u3","Type":"NodeParagraph","Properties":{"id":"20240331100922-yytq0u3","updated":"20240331101505"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::mutex"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::once_flag"},{"Type":"NodeText","Data":"​的实例不能拷贝和移动。"}]},{"ID":"20240331101314-ty1ic4n","Type":"NodeParagraph","Properties":{"id":"20240331101314-ty1ic4n","updated":"20240331101505"},"Children":[{"Type":"NodeText","Data":"还有一种初始化过程中潜存着条件竞争："},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color6);"},"TextMarkType":"text","TextMarkTextContent":"其中一个局部变量为static类型，这种变量的在声明后就已经完成初始化。对于多线程调用的函数，这就意味着这里有条件竞争——抢着去定义这个变量。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color6);\"}"}]},{"ID":"20240331101328-2aap86f","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240331101328-2aap86f","updated":"20240331101531"},"Children":[{"Type":"NodeText","Data":"3.3.2 保护不常更新的数据结构"}]},{"ID":"20240331101531-0az9cx8","Type":"NodeParagraph","Properties":{"id":"20240331101531-0az9cx8","updated":"20240331102059"},"Children":[{"Type":"NodeText","Data":"比如其他线程对一个变量只读，只有一个线程可以修改。"}]},{"ID":"20240331102059-kv9zc0o","Type":"NodeParagraph","Properties":{"id":"20240331102059-kv9zc0o","updated":"20240331102306"},"Children":[{"Type":"NodeText","Data":"可视使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::shared_mutex"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::shared_timed_mutex"},{"Type":"NodeText","Data":"​，更新操作可以使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::lock_guard\u0026lt;std::shared_mutex\u0026gt;"},{"Type":"NodeText","Data":"​上锁，只读操作可以使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::shared_lock\u0026lt;std::shared_mutex\u0026gt;"},{"Type":"NodeText","Data":"​获得读取权限。"}]},{"ID":"20240331102346-yzf2izl","Type":"NodeParagraph","Properties":{"id":"20240331102346-yzf2izl","updated":"20240331102358"},"Children":[{"Type":"NodeText","Data":"唯一的限制："},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color6);"},"TextMarkType":"text","TextMarkTextContent":"当有线程拥有共享锁时，尝试获取独占锁的线程会被阻塞，直到所有其他线程放弃锁。当任一线程拥有一个独占锁时，其他线程就无法获得共享锁或独占锁，直到第一个线程放弃其拥有的锁。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color6);\"}"}]},{"ID":"20240331102406-9lnlth8","Type":"NodeParagraph","Properties":{"id":"20240331102406-9lnlth8","updated":"20240331102412"},"Children":[{"Type":"NodeText","Data":"下例："}]},{"ID":"20240331102412-lbe39y8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240331102412-lbe39y8","updated":"20240331102417"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"#include \u003cmap\u003e\n#include \u003cstring\u003e\n#include \u003cmutex\u003e\n#include \u003cshared_mutex\u003e\n\nclass dns_entry;\n\nclass dns_cache\n{\n  std::map\u003cstd::string,dns_entry\u003e entries;\n  mutable std::shared_mutex entry_mutex;\npublic:\n  dns_entry find_entry(std::string const\u0026 domain) const\n  {\n    std::shared_lock\u003cstd::shared_mutex\u003e lk(entry_mutex);  // 1\n    std::map\u003cstd::string,dns_entry\u003e::const_iterator const it=\n       entries.find(domain);\n    return (it==entries.end())?dns_entry():it-\u003esecond;\n  }\n  void update_or_add_entry(std::string const\u0026 domain,\n                           dns_entry const\u0026 dns_details)\n  {\n    std::lock_guard\u003cstd::shared_mutex\u003e lk(entry_mutex);  // 2\n    entries[domain]=dns_details;\n  }\n};\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240331102726-nkq1694","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240331102726-nkq1694","updated":"20240331102736"},"Children":[{"Type":"NodeText","Data":"3.3.3 嵌套锁"}]},{"ID":"20240331102736-fxxu768","Type":"NodeParagraph","Properties":{"id":"20240331102736-fxxu768","updated":"20240331103454"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"线程对已经获取的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::mutex"},{"Type":"NodeText","Data":"​(已经上锁)再次上锁是错误的，尝试这样做会导致未定义行为。在某些情况下，一个线程会尝试在释放一个互斥量前多次获取。因此，C++标准库提供了"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::recursive_mutex"},{"Type":"NodeText","Data":"​类。除了可以在同一线程的单个实例上多次上锁，其他功能与"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::mutex"},{"Type":"NodeText","Data":"​相同。其他线程对互斥量上锁前，当前线程必须释放拥有的所有锁，所以如果你调用lock()三次，也必须调用unlock()三次。正确使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::lock_guard[std::recursive_mutex](std::recursive_mutex)"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::unique_lock[std::recursive_mutex](std::recursive_mutex)"},{"Type":"NodeText","Data":"​可以帮你处理这些问题。"}]},{"ID":"20240331103512-6lsngqj","Type":"NodeParagraph","Properties":{"id":"20240331103512-6lsngqj","updated":"20240331103516"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color6);"},"TextMarkType":"text","TextMarkTextContent":"这种方式过于草率和不合理，所以不推荐这样的使用方式。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color6);\"}"}]}]}