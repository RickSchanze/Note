{"ID":"20240309172611-4xxy9cc","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240309172611-4xxy9cc","title":"Chapter2 线程管理","updated":"20240316124839"},"Children":[{"ID":"20240309172611-r0hhlhp","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240309172611-r0hhlhp","updated":"20240309172702"},"Children":[{"Type":"NodeText","Data":"一. 线程的基本操作"}]},{"ID":"20240309172646-ihn7b7r","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240309172646-ihn7b7r","updated":"20240309172707"},"Children":[{"Type":"NodeText","Data":"1. 启动线程"}]},{"ID":"20240309172707-h8m669q","Type":"NodeParagraph","Properties":{"id":"20240309172707-h8m669q","updated":"20240309172721"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"使用C++线程库启动线程，就是构造"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::thread"},{"Type":"NodeText","Data":"​对象："}]},{"ID":"20240309172722-hsccmnn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240309172722-hsccmnn","updated":"20240309172727"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"void do_some_work();\nstd::thread my_thread(do_some_work);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240309172728-5iwozgn","Type":"NodeParagraph","Properties":{"id":"20240309172728-5iwozgn","updated":"20240309172805"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::thread"},{"Type":"NodeText","Data":"​可以通过有函数操作符类型的实例进行构造："}]},{"ID":"20240309172907-j1l22ab","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240309172907-j1l22ab","updated":"20240309172909"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"class background_task\n{\n    public:\n    void operator()() const {\n        // do something\n    }\n};\n\nbackground_task f;\nstd::thread my_thread(f);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240309172917-3xqddk0","Type":"NodeParagraph","Properties":{"id":"20240309172917-3xqddk0","updated":"20240309172930"},"Children":[{"Type":"NodeText","Data":"提供的函数对象会"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color6);"},"TextMarkType":"strong em text","TextMarkTextContent":"复制到新线程的存储空间中"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color6);\"}"},{"Type":"NodeText","Data":"，函数对象的执行和调用都在线程的内存空间中进行。"}]},{"ID":"20240309172922-2kukgid","Type":"NodeParagraph","Properties":{"id":"20240309172922-2kukgid","updated":"20240309173048"},"Children":[{"Type":"NodeText","Data":"线程启动后是决定要等待线程结束，还是让其自主运行。"}]},{"ID":"20240309173051-9399v5e","Type":"NodeParagraph","Properties":{"id":"20240309173051-9399v5e","updated":"20240309173434"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"当"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::thread"},{"Type":"NodeText","Data":"​对象销毁之前还没有做出决定，程序就会终止("},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::thread"},{"Type":"NodeText","Data":"​的析构函数会调用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::terminate()"},{"Type":"NodeText","Data":"​)。因此，即便是有异常存在，也需要确保线程能够正确"},{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":"汇入"},{"Type":"NodeText","Data":"(joined)"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"或"},{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":"分离"},{"Type":"NodeText","Data":"(detached)。"}]},{"ID":"20240309173443-qj54984","Type":"NodeParagraph","Properties":{"id":"20240309173443-qj54984","updated":"20240309173454"},"Children":[{"Type":"NodeText","Data":"如果不等待线程汇入 ，就必须保证线程结束之前，访问数据的有效性。"}]},{"ID":"20240309173614-qv68g7x","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240309173614-qv68g7x","updated":"20240309173616"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"struct func\n{\n  int\u0026 i;\n  func(int\u0026 i_) : i(i_) {}\n  void operator() ()\n  {\n    for (unsigned j=0 ; j\u003c1000000 ; ++j)\n    {\n      do_something(i);           // 1 潜在访问隐患：空引用\n    }\n  }\n};\n\nvoid oops()\n{\n  int some_local_state=0;\n  func my_func(some_local_state);\n  std::thread my_thread(my_func);\n  my_thread.detach();          // 2 不等待线程结束\n}                              // 3 新线程可能还在运行\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240309173618-5njw6of","Type":"NodeParagraph","Properties":{"id":"20240309173618-5njw6of","updated":"20240309173710"},"Children":[{"Type":"NodeText","Data":"detach()后函数返回，但是线程仍然在运行，会访问已经销毁的some_local_state导致未定义行为。"}]},{"ID":"20240309173715-1js3ua6","Type":"NodeParagraph","Properties":{"id":"20240309173715-1js3ua6","updated":"20240309173717"},"Children":[{"Type":"NodeText","Data":"处理方法："}]},{"ID":"20240309173718-qqdbj5v","Type":"NodeParagraph","Properties":{"id":"20240309173718-qqdbj5v","updated":"20240309173744"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color6);"},"TextMarkType":"strong em text","TextMarkTextContent":"将数据复制到线程中。如果使用一个可调用的对象作为线程函数，这个对象就会复制到线程中，而后原始对象会立即销毁。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color6);\"}"}]},{"ID":"20240309173741-a7ug1q8","Type":"NodeParagraph","Properties":{"id":"20240309173741-a7ug1q8","updated":"20240309173807"},"Children":[{"Type":"NodeText","Data":"可以通过join()函数确保线程在主函数完成前结束。"}]},{"ID":"20240309175017-aft5q13","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240309175017-aft5q13","updated":"20240309175057"},"Children":[{"Type":"NodeText","Data":"2. 等待线程完成"}]},{"ID":"20240309175057-rb6hna4","Type":"NodeParagraph","Properties":{"id":"20240309175057-rb6hna4","updated":"20240309175143"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"如需等待线程，需要使用join"},{"Type":"NodeText","Data":"()。使用join可以确保上面的例子的局部变量在线程完成后才销毁。"}]},{"ID":"20240309175239-g4cucft","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240309175239-g4cucft","updated":"20240309175253"},"Children":[{"Type":"NodeText","Data":"3. 特殊情况下的等待"}]},{"ID":"20240309175253-jl0k7sp","Type":"NodeParagraph","Properties":{"id":"20240309175253-jl0k7sp","updated":"20240309175312"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"如果等待线程，则需要细心挑选使用join"},{"Type":"NodeText","Data":"()"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"的位置。当在线程运行后产生的异常，会在join"},{"Type":"NodeText","Data":"()"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"调用之前抛出，这样就会跳过join()。"}]},{"ID":"20240309175316-i4u5do9","Type":"NodeParagraph","Properties":{"id":"20240309175316-i4u5do9","updated":"20240309175358"},"Children":[{"Type":"NodeText","Data":"应当避免应用被抛出的异常终止。通常在无异常的情况下使用join()时，需要在异常处理过程中调用join()从而避免生命周期的问题。"}]},{"ID":"20240309175358-9j8nhpn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240309175358-9j8nhpn","updated":"20240309175503"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"struct func; // 定义在代码2.1中\nvoid f()\n{\n  int some_local_state=0;\n  func my_func(some_local_state);\n  std::thread t(my_func);\n  try\n  {\n    do_something_in_current_thread();\n  }\n  catch(...)\n  {\n    t.join();  // 1 抛出异常时执行\n    throw;\n  }\n  t.join();  // 2 正常退出时执行\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240309175430-q2h3s21","Type":"NodeParagraph","Properties":{"id":"20240309175430-q2h3s21","updated":"20240316113814"},"Children":[{"Type":"NodeText","Data":"另一种方法是RAII"}]},{"ID":"20240316113759-dloqgw6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240316113759-dloqgw6","updated":"20240316113812"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"class thread_guard {\n    std::thread\u0026 t;\n\npublic:\n    explicit thread_guard(std::thread\u0026 t_)\n        : t(t_)\n    {\n    }\n\n    ~thread_guard()\n    {\n        if (t.joinable()) {\n            t.join();\n        }\n    }\n};\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240309175517-b71s2ln","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240309175517-b71s2ln","updated":"20240316114217"},"Children":[{"Type":"NodeText","Data":"4. 后台运行线程"}]},{"ID":"20240316113854-2cvrcvf","Type":"NodeParagraph","Properties":{"id":"20240316113854-2cvrcvf","updated":"20240316114217"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"使用detach"},{"Type":"NodeText","Data":"()"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"会让线程在后台运行，这就意味着与主线程不能直接交互。"}]},{"ID":"20240316113913-q1tlxed","Type":"NodeParagraph","Properties":{"id":"20240316113913-q1tlxed","updated":"20240316114217"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color6);"},"TextMarkType":"strong text","TextMarkTextContent":"分离线程通常称为"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color6);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color6);"},"TextMarkType":"em text","TextMarkTextContent":"守护线程"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color6);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color6);"},"TextMarkType":"text","TextMarkTextContent":"(daemon threads)。UNIX中守护线程，是指没有任何显式的接口，并在后台运行的线程，这种线程的特点就是长时间运行。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color6);\"}"}]},{"ID":"20240316113919-pm9wlp7","Type":"NodeParagraph","Properties":{"id":"20240316113919-pm9wlp7","updated":"20240316114217"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"分离线程只能确定线程什么时候结束，"},{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":"发后即忘"},{"Type":"NodeText","Data":"("},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"fire and forget"},{"Type":"NodeText","Data":")"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"的任务使用到就是分离线程。"}]},{"ID":"20240316113938-dhhq7sg","Type":"NodeParagraph","Properties":{"id":"20240316113938-dhhq7sg","updated":"20240316114217"},"Children":[{"Type":"NodeText","Data":"下面是一个使用分离线程处理文档的例子"}]},{"ID":"20240316114057-17uoryb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240316114057-17uoryb","updated":"20240316114217"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qw=="},{"Type":"NodeCodeBlockCode","Data":"void edit_document(std::string const\u0026 filename)\n{\n  open_document_and_display_gui(filename);\n  while(!done_editing())\n  {\n    user_command cmd=get_user_input();\n    if(cmd.type==open_new_document)\n    {\n      std::string const new_name=get_filename_from_user();\n      std::thread t(edit_document,new_name);  // 1\n      t.detach();  // 2\n    }\n    else\n    {\n       process_user_input(cmd);\n    }\n  }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240316114124-8oahr3l","Type":"NodeParagraph","Properties":{"id":"20240316114124-8oahr3l","updated":"20240316114217"},"Children":[{"Type":"NodeText","Data":"加入用户打开一个新文档，那么就好启动一个新线程取处理并进行分离。"}]},{"ID":"20240316114219-y8l99jk","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240316114219-y8l99jk","updated":"20240316114226"},"Children":[{"Type":"NodeText","Data":"二、传递参数"}]},{"ID":"20240316114227-fq32wl2","Type":"NodeParagraph","Properties":{"id":"20240316114227-fq32wl2","updated":"20240316114337"},"Children":[{"Type":"NodeText","Data":"向可调用对象或函数传递参数很简单，只需要将这些参数作为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::thread"},{"Type":"NodeText","Data":"​构造函数的附加参数即可。需要注意的是，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color6);"},"TextMarkType":"text","TextMarkTextContent":"这些参数会拷贝至新线程的内存空间中(同临时变量一样)。即使函数中的参数是引用的形式，拷贝操作也会执行。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color6);\"}"}]},{"ID":"20240316114311-lrwysmv","Type":"NodeParagraph","Properties":{"id":"20240316114311-lrwysmv","updated":"20240316114943"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::thread"},{"Type":"NodeText","Data":"​实例具有"},{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":"可移动"},{"Type":"NodeText","Data":"且"},{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":"不可复制"},{"Type":"NodeText","Data":"性。"}]},{"ID":"20240316114957-ohvp4ii","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240316114957-ohvp4ii","updated":"20240316115004"},"Children":[{"Type":"NodeText","Data":"三、转移所有权"}]},{"ID":"20240316115004-84w50hk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240316115004-84w50hk","updated":"20240316115518"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"void some_function();\nvoid some_other_function();\nstd::thread t1(some_function);            // 1\nstd::thread t2=std::move(t1);            // 2\nt1=std::thread(some_other_function);    // 3\nstd::thread t3;                            // 4\nt3=std::move(t2);                        // 5\nt1=std::move(t3);                        // 6 赋值操作将使程序崩溃\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240316115519-ajpfjqf","Type":"NodeList","ListData":{},"Properties":{"id":"20240316115519-ajpfjqf","updated":"20240316120602"},"Children":[{"ID":"20240316115646-f1jthm7","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240316115646-f1jthm7","updated":"20240316115646"},"Children":[{"ID":"20240316115646-c4cxoes","Type":"NodeParagraph","Properties":{"id":"20240316115646-c4cxoes","updated":"20240316115809"},"Children":[{"Type":"NodeText","Data":"①: 新线程与t1"}]}]},{"ID":"20240316115653-m1fax61","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240316115653-m1fax61"},"Children":[{"ID":"20240316115653-y0yaz32","Type":"NodeParagraph","Properties":{"id":"20240316115653-y0yaz32","updated":"20240316115812"},"Children":[{"Type":"NodeText","Data":"②:"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"当显式使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::move()"},{"Type":"NodeText","Data":"​创建t2后t1的所有权就转移给了t2。"}]}]},{"ID":"20240316115705-36hmapi","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240316115705-36hmapi"},"Children":[{"ID":"20240316115705-exaezfl","Type":"NodeParagraph","Properties":{"id":"20240316115705-exaezfl","updated":"20240316115815"},"Children":[{"Type":"NodeText","Data":"③:"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"临时"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::thread"},{"Type":"NodeText","Data":"​对象相关的线程启动了"}]},{"ID":"20240316115714-0xtiqjg","Type":"NodeParagraph","Properties":{"id":"20240316115714-0xtiqjg","updated":"20240316115740"},"Children":[{"Type":"NodeText","Data":"这里没有显示调用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::move"},{"Type":"NodeText","Data":"​是因为所有者是一个临时对象，移动操作将会隐私调用"}]}]},{"ID":"20240316115740-phb5osd","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240316115740-phb5osd"},"Children":[{"ID":"20240316115740-nroyebx","Type":"NodeParagraph","Properties":{"id":"20240316115740-nroyebx","updated":"20240316115818"},"Children":[{"Type":"NodeText","Data":"④:t3使用默认构造方式，没有与任何线程进行关联"}]}]},{"ID":"20240316115751-f1ud9nc","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240316115751-f1ud9nc"},"Children":[{"ID":"20240316115751-lhqt3xs","Type":"NodeParagraph","Properties":{"id":"20240316115751-lhqt3xs","updated":"20240316115821"},"Children":[{"Type":"NodeText","Data":"⑤:"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"调用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::move()"},{"Type":"NodeText","Data":"​将t2关联线程的所有权转移到t3中"}]},{"ID":"20240316115822-k6r91ys","Type":"NodeParagraph","Properties":{"id":"20240316115822-k6r91ys","updated":"20240316115942"},"Children":[{"Type":"NodeText","Data":"此时t1与执行some_other_function的线程相关联，t2与任何线程都无关联，t3与执行some_function的线程相关联。"}]}]},{"ID":"20240316115925-ecm1mll","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240316115925-ecm1mll","updated":"20240316120602"},"Children":[{"ID":"20240316115925-9mzuuzk","Type":"NodeParagraph","Properties":{"id":"20240316115925-9mzuuzk","updated":"20240316120456"},"Children":[{"Type":"NodeText","Data":"⑥将some_function线程的所有权转移给t1,不过此时t1已经有一个关联线程了，所以调用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::terminate()"},{"Type":"NodeText","Data":"​ 终止运行。"}]},{"ID":"20240316120509-8x7xeyh","Type":"NodeParagraph","Properties":{"id":"20240316120509-8x7xeyh","updated":"20240316120517"},"Children":[{"Type":"NodeText","Data":"不能通过赋新值给"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::thread"},{"Type":"NodeText","Data":"​对象的方式来\"丢弃\"一个线程。"}]},{"ID":"20240316120554-op8n209","Type":"NodeParagraph","Properties":{"id":"20240316120554-op8n209","updated":"20240316120602"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color6);"},"TextMarkType":"text","TextMarkTextContent":"需要在线程对象析构前，显式的等待线程完成，或者分离它。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color6);\"}"}]}]}]},{"ID":"20240316120517-we8nfia","Type":"NodeParagraph","Properties":{"id":"20240316120517-we8nfia","updated":"20240316120842"},"Children":[{"Type":"NodeText","Data":"线程的所有权可以在函数外进行转移。"}]},{"ID":"20240316120842-2yg4v69","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240316120842-2yg4v69","updated":"20240316120850"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"std::thread f()\n{\n  void some_function();\n  return std::thread(some_function);\n}\n\nstd::thread g()\n{\n  void some_other_function(int);\n  std::thread t(some_other_function,42);\n  return t;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240316120852-9p4nyto","Type":"NodeParagraph","Properties":{"id":"20240316120852-9p4nyto","updated":"20240316121033"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"为了确保线程在程序退出前完成，定义scoped"},{"Type":"NodeText","Data":"_"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"thread类:"}]},{"ID":"20240316121033-x30ky6y","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240316121033-x30ky6y","updated":"20240316121301"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"class scoped_thread\n{\n  std::thread t;\npublic:\n  explicit scoped_thread(std::thread t_): // 1\n    t(std::move(t_))\n  {\n    if(!t.joinable())  // 2\n      throw std::logic_error(“No thread”);\n  }\n  ~scoped_thread()\n  {\n    t.join(); // 3\n  }\n  scoped_thread(scoped_thread const\u0026)=delete;\n  scoped_thread\u0026 operator=(scoped_thread const\u0026)=delete;\n};\n\nvoid f()\n{\n  int some_local_state;\n  scoped_thread t(std::thread(func(some_local_state)));    // 4\n  do_something_in_current_thread();\n} // 5\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240316121125-nt9arvb","Type":"NodeParagraph","Properties":{"id":"20240316121125-nt9arvb","updated":"20240316121322"},"Children":[{"Type":"NodeText","Data":"新线程会直接传递到scoped_thread中当主线程到达f()末尾时⑤，scoped_thread对象就会销毁，然后在析构函数中完成汇入。"}]},{"ID":"20240316121328-f2char0","Type":"NodeParagraph","Properties":{"id":"20240316121328-f2char0","updated":"20240316121336"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::thread"},{"Type":"NodeText","Data":"​中对移动语义的支持，也适用于使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::thread"},{"Type":"NodeText","Data":"​的"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"移动敏感"},{"Type":"NodeText","Data":"(move-aware)容器(比如，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::vector\u0026lt;\u0026gt;"},{"Type":"NodeText","Data":"​)。"}]},{"ID":"20240316121341-fs0paad","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240316121341-fs0paad","updated":"20240316121358"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"void do_work(unsigned id);\n\nvoid f()\n{\n  std::vector\u003cstd::thread\u003e threads;\n  for (unsigned i = 0; i \u003c 20; ++i)\n  {\n    threads.emplace_back(do_work,i); // 产生线程\n  } \n  for (auto\u0026 entry : threads) // 对每个线程调用 join()\n    entry.join();     \n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240316121351-qjszl1k","Type":"NodeParagraph","Properties":{"id":"20240316121351-qjszl1k","updated":"20240316122216"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"将"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::thread"},{"Type":"NodeText","Data":"​放入"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::vector"},{"Type":"NodeText","Data":"​是向线程自动化管理迈出的第一步：并非为这些线程创建独立的变量，而是把它们当做一个组（线程池）。"}]},{"ID":"20240316122222-gwe46e1","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240316122222-gwe46e1","updated":"20240316122229"},"Children":[{"Type":"NodeText","Data":"四、确定线程数量"}]},{"ID":"20240316122229-5ev33et","Type":"NodeParagraph","Properties":{"id":"20240316122229-5ev33et","updated":"20240316123806"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::thread::hardware_concurrency()"},{"Type":"NodeText","Data":"​在新版C++中非常有用，其会返回并发线程的数量。返回值仅仅是一个标识，当无法获取时，函数返回0。"}]},{"ID":"20240316123749-vqph2bt","Type":"NodeParagraph","Properties":{"id":"20240316123749-vqph2bt","updated":"20240316123827"},"Children":[{"Type":"NodeText","Data":"下面是一个并行版的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::accumulate"},{"Type":"NodeText","Data":"​的例子。"}]},{"ID":"20240316123829-xsqqa08","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240316123829-xsqqa08","updated":"20240316124446"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"template \u003ctypename Iterator, typename T\u003e\nstruct accumulate_block {\n    void operator()(Iterator first, Iterator last, T\u0026 res)\n    {\n        res = std::accumulate(first, last, res);\n    }\n};\n\ntemplate \u003ctypename Iter, typename T\u003e\nT parallel_accucmulate(Iter first, Iter last, T init)\n{\n    uint64_t length = std::distance(first, last);\n    // 输入为空则直接返回init\n    if (!length) {\n        return init;\n    }\n    uint64_t min_per_thread = 25;\n    // 范围元素多于一个则寻找线程最大数量(元素内总数量初一线程中最小任务数)\n    uint64_t max_threads = (length + min_per_thread - 1) / min_per_thread;\n    uint64_t hardware_threads = std::thread::hardware_concurrency();\n    // 计算线程最大值和硬件支持线程数的较小值，因为频繁上下文切换会降低线程性能\n    uint64_t num_threads = std::min(hardware_threads != 0 ? hardware_threads : 2, max_threads);\n    // 得出每个线程中处理的元素数量\n    uint64_t blocak_size = length / num_threads;\n    // 存放每个线程的结果\n    std::vector\u003cT\u003e results(num_threads);\n    // 存放线程\n    std::vector\u003cstd::thread\u003e threads(num_threads -1);\n    Iter block_start = first;\n    for (uint64_t i = 0; i \u003c num_threads - 1; i++) {\n        Iter block_end = block_start;\n        std::advance(block_end, blocak_size);\n        // 启动线程\n        threads[i] = std::thread(\n            accumulate_block\u003cIter, T\u003e(),\n            block_start,\n            block_end,\n            std::ref(results[i])\n        );\n        block_start = block_end;\n    }\n    accumulate_block\u003cIter, T\u003e()(block_start, last, results[num_threads - 1]);\n\n    for (auto\u0026 t: threads) {\n        t.join();\n    }\n    return std::accumulate(results.begin(), results.end(), init);\n}"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240316124449-1qmdtxj","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240316124449-1qmdtxj","updated":"20240316124534"},"Children":[{"Type":"NodeText","Data":"五、线程标识"}]},{"ID":"20240316124534-vhtjo3k","Type":"NodeParagraph","Properties":{"id":"20240316124534-vhtjo3k","updated":"20240316124550"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"线程标识为"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::thread::id"},{"Type":"NodeText","Data":"​类型，可以通过两种方式进行检索。"}]},{"ID":"20240316124554-sep19cf","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240316124554-sep19cf","updated":"20240316124610"},"Children":[{"ID":"20240316124555-qjtj7xj","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240316124555-qjtj7xj","updated":"20240316124610"},"Children":[{"ID":"20240316124555-tzmpimo","Type":"NodeParagraph","Properties":{"id":"20240316124555-tzmpimo","updated":"20240316124559"},"Children":[{"Type":"NodeText","Data":"可以通过调用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::thread"},{"Type":"NodeText","Data":"​对象的成员函数"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"get_id()"},{"Type":"NodeText","Data":"​来直接获取。"}]},{"ID":"20240316124610-muvt91m","Type":"NodeParagraph","Properties":{"id":"20240316124610-muvt91m","updated":"20240316124610"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"如果"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::thread"},{"Type":"NodeText","Data":"​对象没有与任何执行线程相关联，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"get_id()"},{"Type":"NodeText","Data":"​将返回"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::thread::type"},{"Type":"NodeText","Data":"​默认构造值，这个值表示“无线程”。"}]}]},{"ID":"20240316124557-jcntx58","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240316124557-jcntx58"},"Children":[{"ID":"20240316124557-h8jmoip","Type":"NodeParagraph","Properties":{"id":"20240316124557-h8jmoip","updated":"20240316124600"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"当前线程中调用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::this_thread::get_id()"},{"Type":"NodeText","Data":"​(这个函数定义在"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026lt;thread\u0026gt;"},{"Type":"NodeText","Data":"​头文件中)也可以获得线程标识。"}]}]}]},{"ID":"20240316124637-wr67wq2","Type":"NodeParagraph","Properties":{"id":"20240316124637-wr67wq2","updated":"20240316124732"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::thread::id"},{"Type":"NodeText","Data":"​实例常用作检测线程是否需要进行一些操作。比如当使用线程分割工作时，主线程可能要做一些与其他线程不同的工作，那么其他线程启动前就可"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"以通过"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::this_thread::get_id()"},{"Type":"NodeText","Data":"​得到自己的线程ID。进行检查。"}]},{"ID":"20240316124732-85g1muf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240316124732-85g1muf","updated":"20240316124828"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"std::thread::id master_thread;\nvoid some_core_part_of_algorithm()\n{\n  if(std::this_thread::get_id()==master_thread)\n  {\n    do_master_thread_work();\n  }\n  do_common_work();\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240316124826-322q6qr","Type":"NodeParagraph","Properties":{"id":"20240316124826-322q6qr","updated":"20240316124826"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::thread::id"},{"Type":"NodeText","Data":"​可以作为线程的通用标识符"}]},{"ID":"20240316124829-39a2gop","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240316124829-39a2gop","updated":"20240316124835"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"std::cout\u003c\u003cstd::this_thread::get_id();\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240316124836-fk63h31","Type":"NodeParagraph","Properties":{"id":"20240316124836-fk63h31","updated":"20240316124839"},"Children":[{"Type":"NodeText","Data":"具体的输出结果是严格依赖于具体实现的，C++标准的要求就是保证ID相同的线程必须有相同的输出。"}]}]}