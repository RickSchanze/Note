{"ID":"20240507091117-yu9tjuq","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240507091117-yu9tjuq","title":"Chatper5 内存模型和原子操作","type":"doc","updated":"20240510100214"},"Children":[{"ID":"20240507091218-efa275q","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240507091218-efa275q","updated":"20240507091456"},"Children":[{"Type":"NodeText","Data":"5.2 原子操作和原子类型"}]},{"ID":"20240507091456-2gpchh2","Type":"NodeParagraph","Properties":{"id":"20240507091456-2gpchh2","updated":"20240507091506"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color4);"},"TextMarkType":"text","TextMarkTextContent":"原子操作是个不可分割的操作"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color4);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240507091507-rv2awuk","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240507091507-rv2awuk","updated":"20240507091521"},"Children":[{"Type":"NodeText","Data":"5.2.1 标准原子类型"}]},{"ID":"20240507091521-1uaghm8","Type":"NodeParagraph","Properties":{"id":"20240507091521-1uaghm8","updated":"20240507091553"},"Children":[{"Type":"NodeText","Data":"标准原子类型定义在头文件"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026lt;atomic\u0026gt;"},{"Type":"NodeText","Data":"​中。它们(几乎)都有一个"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"is_lock_free()"},{"Type":"NodeText","Data":"​成员函数，这个函数可以让用户查询某原子类型的操作是直接用的原子指令("},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"x.is_lock_free()"},{"Type":"NodeText","Data":"​返回"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"true"},{"Type":"NodeText","Data":"​)，还是内部用了一个锁结构("},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"x.is_lock_free()"},{"Type":"NodeText","Data":"​返回"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"false"},{"Type":"NodeText","Data":"​)。"}]},{"ID":"20240507091545-id96drp","Type":"NodeParagraph","Properties":{"id":"20240507091545-id96drp","updated":"20240507091604"},"Children":[{"Type":"NodeText","Data":"原子操作可以替代互斥量，来完成同步操作。"}]},{"ID":"20240507091638-u91u0zj","Type":"NodeParagraph","Properties":{"id":"20240507091638-u91u0zj","updated":"20240507091638"},"Children":[{"Type":"NodeText","Data":"标准库提供了一组宏，在编译时对各种整型原子操作是否无锁进行判别。"}]},{"ID":"20240507091649-7o0tecq","Type":"NodeParagraph","Properties":{"id":"20240507091649-7o0tecq","updated":"20240507091649"},"Children":[{"Type":"NodeText","Data":"C++17中，所有原子类型有一个static constexpr成员变量，如果相应硬件上的原子类型X是无锁类型，那么X::is_always_lock_free将返回true。"}]},{"ID":"20240507091650-02fpehc","Type":"NodeBlockquote","Properties":{"id":"20240507091650-02fpehc","updated":"20240507091658"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240507091651-8k1j72y","Type":"NodeParagraph","Properties":{"id":"20240507091651-8k1j72y","updated":"20240507091658"},"Children":[{"Type":"NodeText","Data":"例如：给定目标硬件平台"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic\u0026lt;int\u0026gt;"},{"Type":"NodeText","Data":"​无锁，那么"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic\u0026lt;int\u0026gt;::is_always_lock_free"},{"Type":"NodeText","Data":"​将会返回true。不过"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic\u0026lt;uintmax_t\u0026gt;"},{"Type":"NodeText","Data":"​因为这是一个运行时属性，所以"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic\u0026lt;uintmax_t\u0026gt;::is_always_lock_free"},{"Type":"NodeText","Data":"​在该平台编译时可能为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"false"},{"Type":"NodeText","Data":"​。"}]}]},{"ID":"20240507091658-0r0ukfk","Type":"NodeParagraph","Properties":{"id":"20240507091658-0r0ukfk","updated":"20240507091909"},"Children":[{"Type":"NodeText","Data":"此外，还定义了一些宏来确定内置原子类型的无锁状态和无符号对应类型。"}]},{"ID":"20240507091909-cxf21vx","Type":"NodeBlockquote","Properties":{"id":"20240507091909-cxf21vx","updated":"20240507091919"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240507091911-jhv355s","Type":"NodeParagraph","Properties":{"id":"20240507091911-jhv355s","updated":"20240507091919"},"Children":[{"Type":"NodeText","Data":"宏都有"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ATOMIC_BOOL_LOCK_FREE"},{"Type":"NodeText","Data":"​ ,  "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ATOMIC_CHAR_LOCK_FREE"},{"Type":"NodeText","Data":"​ ,  "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ATOMIC_CHAR16_T_LOCK_FREE"},{"Type":"NodeText","Data":"​ ,  "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ATOMIC_CHAR32_T_LOCK_FREE"},{"Type":"NodeText","Data":"​ ，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ATOMIC_WCHAR_T_LOCK_FREE"},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ATOMIC_SHORT_LOCK_FREE"},{"Type":"NodeText","Data":"​ ,  "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ATOMIC_INT_LOCK_FREE"},{"Type":"NodeText","Data":"​ ,  "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ATOMIC_LONG_LOCK_FREE"},{"Type":"NodeText","Data":"​ , "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ATOMIC_LLONG_LOCK_FREE"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ATOMIC_POINTER_LOCK_FREE"},{"Type":"NodeText","Data":"​。"}]}]},{"ID":"20240507091920-46dz0a6","Type":"NodeParagraph","Properties":{"id":"20240507091920-46dz0a6","updated":"20240507091943"},"Children":[{"Type":"NodeText","Data":"如果值为0则不是无锁，2则无锁，1则在运行时才能确定。"}]},{"ID":"20240507091944-a01shmk","Type":"NodeParagraph","Properties":{"id":"20240507091944-a01shmk","updated":"20240507092013"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"只有"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"code text","TextMarkTextContent":"std::atomic_flag"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"类型不提供 "},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"code text","TextMarkTextContent":"is_lock_free()"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"该类型是一个简单的布尔标志，并且在这种类型上的操作都是无锁的。"}]},{"ID":"20240507092031-1d5kkai","Type":"NodeParagraph","Properties":{"id":"20240507092031-1d5kkai","updated":"20240507092036"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"对"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"code text","TextMarkTextContent":"std::atomic_flag"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"明确初始化后，做查询和设置(使用test_and_set()成员函数)，或清除(使用clear()成员函数)都很容易：无赋值，无拷贝，没有测试和清除，没有任何多余操作。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"}]},{"ID":"20240507092117-6graktq","Type":"NodeParagraph","Properties":{"id":"20240507092117-6graktq","updated":"20240507092125"},"Children":[{"Type":"NodeText","Data":"剩下的原子类型都可以通过特化"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic\u0026lt;\u0026gt;"},{"Type":"NodeText","Data":"​得到，并且拥有更多的功能，但不可能都是无锁的(如之前解释的那样)。"}]},{"ID":"20240507092126-7pmrel8","Type":"NodeBlockquote","Properties":{"id":"20240507092126-7pmrel8","updated":"20240507092141"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240507092137-tw4x38y","Type":"NodeParagraph","Properties":{"id":"20240507092137-tw4x38y","updated":"20240507092141"},"Children":[{"Type":"NodeText","Data":"主流平台上，原子变量是无锁的内置类型(例如"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic\u0026lt;int\u0026gt;"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic\u0026lt;void*\u0026gt;"},{"Type":"NodeText","Data":"​)。"}]}]},{"ID":"20240507092141-ohat7pd","Type":"NodeParagraph","Properties":{"id":"20240507092141-ohat7pd","updated":"20240507092209"},"Children":[{"Type":"NodeText","Data":"除了直接使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic\u0026lt;\u0026gt;"},{"Type":"NodeText","Data":"​模板外，也可以使用在表5.1中所示的原子类型集。"}]},{"ID":"20240507092216-cygelxi","Type":"NodeParagraph","Properties":{"id":"20240507092216-cygelxi","updated":"20240507092216"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"表5.1 标准原子类型的备选名和与其相关的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic\u0026lt;\u0026gt;"},{"Type":"NodeText","Data":"​特化类"}]},{"ID":"20240507092216-qg2doku","Type":"NodeTable","TableAligns":[0,0],"Properties":{"colgroup":"|","id":"20240507092216-qg2doku","updated":"20240507092239"},"Children":[{"Type":"NodeTableHead","Data":"thead","Children":[{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"原子类型"}]},{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"相关特化类"}]}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"atomic_bool"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"std::atomic\u003cbool\u003e"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"atomic_char"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"std::atomic"},{"Type":"NodeText","Data":"\u003c"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"char\u0026gt;"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"atomic_schar"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"std::atomic"},{"Type":"NodeText","Data":"\u003c"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"signed char\u0026gt;"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"atomic_uchar"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"std::atomic"},{"Type":"NodeText","Data":"\u003c"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"unsigned char\u0026gt;"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"atomic_int"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"std::atomic"},{"Type":"NodeText","Data":"\u003c"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"int\u0026gt;"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"atomic_uint"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"std::atomic"},{"Type":"NodeText","Data":"\u003c"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"unsigned\u0026gt;"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"atomic_short"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"std::atomic"},{"Type":"NodeText","Data":"\u003c"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"short\u0026gt;"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"atomic_ushort"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"std::atomic"},{"Type":"NodeText","Data":"\u003c"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"unsigned short\u0026gt;"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"atomic_long"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"std::atomic"},{"Type":"NodeText","Data":"\u003c"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"long\u0026gt;"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"atomic_ulong"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"std::atomic"},{"Type":"NodeText","Data":"\u003c"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"unsigned long\u0026gt;"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"atomic_llong"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"std::atomic"},{"Type":"NodeText","Data":"\u003c"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"long long\u0026gt;"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"atomic_ullong"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"std::atomic"},{"Type":"NodeText","Data":"\u003c"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"unsigned long long\u0026gt;"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"atomic_char16_t"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"std::atomic"},{"Type":"NodeText","Data":"\u003c"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"char16_t\u0026gt;"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"atomic_char32_t"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"std::atomic"},{"Type":"NodeText","Data":"\u003c"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"char32_t\u0026gt;"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"atomic_wchar_t"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"std::atomic"},{"Type":"NodeText","Data":"\u003c"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"wchar_t\u0026gt;"}]}]}]},{"ID":"20240507092216-x4zojpj","Type":"NodeParagraph","Properties":{"id":"20240507092216-x4zojpj","updated":"20240507092306"},"Children":[{"Type":"NodeText","Data":"C++标准库不仅提供基本原子类型，还定义了与原子类型对应的非原子类型。"}]},{"ID":"20240507092413-xlplglp","Type":"NodeParagraph","Properties":{"id":"20240507092413-xlplglp","updated":"20240507092415"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240507092413-81n22uk.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240507092717-qznkxbe","Type":"NodeParagraph","Properties":{"id":"20240507092717-qznkxbe","updated":"20240507092900"},"Children":[{"Type":"NodeText","Data":"通常，标准原子类型不能进行拷贝和赋值，它们没有拷贝构造函数和拷贝赋值操作符。但是，可以隐式转化成对应的内置类型，所以这些类型依旧支持赋值，可以使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"load()"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"store()"},{"Type":"NodeText","Data":"​、"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"exchange()"},{"Type":"NodeText","Data":"​、"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"compare_exchange_weak()"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"compare_exchange_strong()"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20240507092743-wafe2hr","Type":"NodeParagraph","Properties":{"id":"20240507092743-wafe2hr","updated":"20240507093100"},"Children":[{"Type":"NodeText","Data":"每种函数操作都有一个内存序（memory order）参数，用来指定存储顺序。"}]},{"ID":"20240507093101-y0alhoc","Type":"NodeList","ListData":{},"Properties":{"id":"20240507093101-y0alhoc","updated":"20240507093106"},"Children":[{"ID":"20240507093106-52241fm","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240507093106-52241fm","updated":"20240507093106"},"Children":[{"ID":"20240507093106-1ka8hiu","Type":"NodeParagraph","Properties":{"id":"20240507093106-1ka8hiu","updated":"20240507093412"},"Children":[{"Type":"NodeText","Data":"Store操作可选："}]},{"ID":"20240507093414-q7eq9cj","Type":"NodeParagraph","Properties":{"id":"20240507093414-q7eq9cj","updated":"20240507093428"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"memory_order_release"},{"Type":"NodeText","Data":"​, "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"memory_order_seq_cst"},{"Type":"NodeText","Data":"​。"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"memory_order_relaxed"},{"Type":"NodeText","Data":"​"}]}]}]},{"ID":"20240507092955-k3z5yrf","Type":"NodeList","ListData":{},"Properties":{"id":"20240507092955-k3z5yrf","updated":"20240507093508"},"Children":[{"ID":"20240507093433-1pbcje1","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240507093433-1pbcje1","updated":"20240507093433"},"Children":[{"ID":"20240507093433-nn3baqz","Type":"NodeParagraph","Properties":{"id":"20240507093433-nn3baqz","updated":"20240507093438"},"Children":[{"Type":"NodeText","Data":"Load操作可选："}]},{"ID":"20240507093438-c3xncxr","Type":"NodeParagraph","Properties":{"id":"20240507093438-c3xncxr","updated":"20240507093443"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"memory_order_relaxed"},{"Type":"NodeText","Data":"​, "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"memory_order_consume"},{"Type":"NodeText","Data":"​, "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"memory_order_acquire"},{"Type":"NodeText","Data":"​, "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"memory_order_seq_cst"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20240507093444-haayimg","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240507093444-haayimg","updated":"20240507093508"},"Children":[{"ID":"20240507093444-3o2q5sh","Type":"NodeParagraph","Properties":{"id":"20240507093444-3o2q5sh","updated":"20240507093503"},"Children":[{"Type":"NodeText","Data":"Read-Modify-Write（读-改-写）操作可选："}]},{"ID":"20240507093503-9st6i63","Type":"NodeParagraph","Properties":{"id":"20240507093503-9st6i63","updated":"20240507093508"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"memory_order_relaxed"},{"Type":"NodeText","Data":"​, "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"memory_order_consume"},{"Type":"NodeText","Data":"​, "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"memory_order_acquire"},{"Type":"NodeText","Data":"​, "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"memory_order_release"},{"Type":"NodeText","Data":"​, "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"memory_order_acq_rel"},{"Type":"NodeText","Data":"​, "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"memory_order_seq_cst"},{"Type":"NodeText","Data":"​。"}]}]}]},{"ID":"20240507093510-fj8c8zt","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240507093510-fj8c8zt","updated":"20240507093531"},"Children":[{"Type":"NodeText","Data":"5.2.2 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic_flag"},{"Type":"NodeText","Data":"​"}]},{"ID":"20240507093525-52i7ye6","Type":"NodeParagraph","Properties":{"id":"20240507093525-52i7ye6","updated":"20240507093538"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic_flag"},{"Type":"NodeText","Data":"​是最简单的原子类型，这个类型的对象可以在两个状态间切换：设置和清除。"}]},{"ID":"20240507093553-c6zvnoq","Type":"NodeParagraph","Properties":{"id":"20240507093553-c6zvnoq","updated":"20240507093553"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic_flag"},{"Type":"NodeText","Data":"​类型的对象必须被ATOMIC_FLAG_INIT初始化。初始化标志位是“清除”状态。"}]},{"ID":"20240507093555-3u0vwrx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240507093555-3u0vwrx","updated":"20240507093655"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"std::atomic_flag flag = ATOMIC_FLAG_INIT;\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240507093649-7hgrlpo","Type":"NodeParagraph","Properties":{"id":"20240507093649-7hgrlpo","updated":"20240507093702"},"Children":[{"Type":"NodeText","Data":"首次使用时，需要初始化。如果"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic_flag"},{"Type":"NodeText","Data":"​是静态存储的，那么就的保证其是静态初始化的，也就意味着没有初始化顺序问题。"}]},{"ID":"20240507093702-g8aioni","Type":"NodeParagraph","Properties":{"id":"20240507093702-g8aioni","updated":"20240507093717"},"Children":[{"Type":"NodeText","Data":"当标志对象已初始化，只能做三件事情：销毁，清除或设置(查询之前的值)。这些操作对应的函数分别是："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"clear()"},{"Type":"NodeText","Data":"​成员函数和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"test_and_set()"},{"Type":"NodeText","Data":"​成员函数。"}]},{"ID":"20240507093737-pgexxmo","Type":"NodeList","ListData":{},"Properties":{"id":"20240507093737-pgexxmo","updated":"20240507093939"},"Children":[{"ID":"20240507093738-0cy8dab","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240507093738-0cy8dab","updated":"20240507093738"},"Children":[{"ID":"20240507093738-ys6cz59","Type":"NodeParagraph","Properties":{"id":"20240507093738-ys6cz59","updated":"20240507093759"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"clear()"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"test_and_set()"},{"Type":"NodeText","Data":"​成员函数可以指定好内存顺序。"}]}]},{"ID":"20240507093806-01y3l8j","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240507093806-01y3l8j"},"Children":[{"ID":"20240507093806-o3ug3mi","Type":"NodeParagraph","Properties":{"id":"20240507093806-o3ug3mi","updated":"20240507093815"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"clear()"},{"Type":"NodeText","Data":"​是一个存储操作，所以不能有"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"memory_order_acquire"},{"Type":"NodeText","Data":"​或"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"memory_order_acq_rel"},{"Type":"NodeText","Data":"​语义"}]}]},{"ID":"20240507093930-gv7dfud","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240507093930-gv7dfud","updated":"20240507093939"},"Children":[{"ID":"20240507093930-yx42puv","Type":"NodeParagraph","Properties":{"id":"20240507093930-yx42puv","updated":"20240507093939"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"test_and_set()"},{"Type":"NodeText","Data":"​是一个“读-改-写”操作，可以应用于任何内存顺序。"}]}]}]},{"ID":"20240507093939-c4w5mky","Type":"NodeParagraph","Properties":{"id":"20240507093939-c4w5mky","updated":"20240507093944"},"Children":[{"Type":"NodeText","Data":"每一个原子操作，默认的内存序都是memory_order_seq_cst。"}]},{"ID":"20240507093949-26zrgrx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240507093949-26zrgrx","updated":"20240507094026"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"f.clear(std::memory_order_release);  // 1\nbool x=f.test_and_set();  // 2\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240507094028-hbvxetv","Type":"NodeList","ListData":{},"Properties":{"id":"20240507094028-hbvxetv","updated":"20240507094126"},"Children":[{"ID":"20240507094030-63rizyk","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240507094030-63rizyk","updated":"20240507094030"},"Children":[{"ID":"20240507094030-yty0v9o","Type":"NodeParagraph","Properties":{"id":"20240507094030-yty0v9o","updated":"20240507094057"},"Children":[{"Type":"NodeText","Data":"1: 调用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"clear()"},{"Type":"NodeText","Data":"​明确要求，使用释放语义清除标志"}]}]},{"ID":"20240507094057-1p2zsuv","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240507094057-1p2zsuv","updated":"20240507094126"},"Children":[{"ID":"20240507094057-v17aybv","Type":"NodeParagraph","Properties":{"id":"20240507094057-v17aybv","updated":"20240507094126"},"Children":[{"Type":"NodeText","Data":"2: 使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"test_and_set()"},{"Type":"NodeText","Data":"​使用默认内存序设置，并检索旧值"}]}]}]},{"ID":"20240507094350-8xefdzl","Type":"NodeParagraph","Properties":{"id":"20240507094350-8xefdzl","updated":"20240507094433"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"所有原子操作都没有赋值和拷贝操作，因为赋值和拷贝调用了两个对象，破坏了操作的原子性。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"}]},{"ID":"20240507094433-k5be3za","Type":"NodeParagraph","Properties":{"id":"20240507094433-k5be3za","updated":"20240507094641"},"Children":[{"Type":"NodeText","Data":"有限的特性使得"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic_flag"},{"Type":"NodeText","Data":"​非常适合于作"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"https://zh.wikipedia.org/wiki/%E8%87%AA%E6%97%8B%E9%94%81","TextMarkATitle":"自旋锁链接","TextMarkTextContent":"自旋锁"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240507094557-508tmfq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240507094557-508tmfq","updated":"20240507094955"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"class SpinLockMutex {\n    std::atomic_flag mFlag;\n\npublic:\n    SpinLockMutex()\n        : mFlag(ATOMIC_FLAG_INIT)\n    {\n    }\n\n    void Lock()\n    {\n        while (mFlag.test_and_set(std::memory_order_acquire))\n            ;\n    }\n\n    void Unlock()\n    {\n        mFlag.clear(std::memory_order_release);\n    }\n};\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240507095022-23y0dos","Type":"NodeParagraph","Properties":{"id":"20240507095022-23y0dos","updated":"20240507095029"},"Children":[{"Type":"NodeText","Data":"由于"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic_flag"},{"Type":"NodeText","Data":"​的局限性太强，没有非修改查询操作，甚至不能像普通的布尔标志那样使用。所以，实际操作中最好使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic\u0026lt;bool\u0026gt;"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20240507095029-nul5lmj","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240507095029-nul5lmj","updated":"20240507095038"},"Children":[{"Type":"NodeText","Data":"5.2.3 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic\u0026lt;bool\u0026gt;"},{"Type":"NodeText","Data":"​"}]},{"ID":"20240507095039-bd0o0qg","Type":"NodeParagraph","Properties":{"id":"20240507095039-bd0o0qg","updated":"20240507095324"},"Children":[{"Type":"NodeText","Data":"最基本的原子整型类型就是"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic\u0026lt;bool\u0026gt;"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20240507095324-rue5nll","Type":"NodeParagraph","Properties":{"id":"20240507095324-rue5nll","updated":"20240507095353"},"Children":[{"Type":"NodeText","Data":"虽然不能拷贝构造和拷贝赋值，但可以使用非原子的bool类型进行构造，所以可以初始化为true或false，并且可以从非原子bool变量赋值给"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic\u0026lt;bool\u0026gt;"},{"Type":"NodeText","Data":"​"}]},{"ID":"20240507095353-0gy81bl","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240507095353-0gy81bl","updated":"20240507095358"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"std::atomic\u003cbool\u003e b(true);\nb=false;\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240507095425-u0s8xi8","Type":"NodeParagraph","Properties":{"id":"20240507095425-u0s8xi8","updated":"20240507095425"},"Children":[{"Type":"NodeText","Data":"另外，非原子bool类型的赋值操作不同于通常的操作(转换成对应类型的引用，再赋给对应的对象)：它返回一个bool值来代替指定对象。"}]},{"ID":"20240507095542-11ym8zj","Type":"NodeParagraph","Properties":{"id":"20240507095542-11ym8zj","updated":"20240507095545"},"Children":[{"Type":"NodeText","Data":"虽然有内存序的指定，但使用store()写入(true或false)还是好于"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic_flag"},{"Type":"NodeText","Data":"​中的clear()。同样，test_and_set()也可以替换为更加通用的exchange()，exchange()允许使用新选的值替换已存储的值，并且会自动检索原始值。"}]},{"ID":"20240507095555-skmh6cy","Type":"NodeParagraph","Properties":{"id":"20240507095555-skmh6cy","updated":"20240507095616"},"Children":[{"Type":"NodeText","Data":"其中："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"store()"},{"Type":"NodeText","Data":"​是一个存储操作，而"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"load()"},{"Type":"NodeText","Data":"​是一个加载操作，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"exchange()"},{"Type":"NodeText","Data":"​是一个“读-改-写”操作"}]},{"ID":"20240507095545-navxun9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240507095545-navxun9","updated":"20240507095634"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"std::atomic\u003cbool\u003e b;\nbool x=b.load(std::memory_order_acquire);\nb.store(true);\nx=b.exchange(false, std::memory_order_acq_rel);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240507095804-av8s7m3","Type":"NodeParagraph","Properties":{"id":"20240507095804-av8s7m3","updated":"20240507095812"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic\u0026lt;bool\u0026gt;"},{"Type":"NodeText","Data":"​提供多个“读-改-写”的操作，exchange()只是其中之一。它还介绍了一种新的存储方式：当前值与预期值一致时，存储新值的操作。"}]},{"ID":"20240509094637-zhkyetb","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240509094637-zhkyetb","updated":"20240509095312"},"Children":[{"Type":"NodeText","Data":"5.2.3.1 根据当前值存储一个新值或旧值"}]},{"ID":"20240509095313-3173bwm","Type":"NodeParagraph","Properties":{"id":"20240509095313-3173bwm","updated":"20240509095418"},"Children":[{"Type":"NodeText","Data":"这种操作叫做"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"比较/交换"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。它的形式表现为"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"compare_exchange_weak()"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"compare_exchange_strong()"},{"Type":"NodeText","Data":"​。它比较原子变量的当前值和期望值，当两值相等时，存储所提供值。当两值不等，期望值就会被更新为原子变量中的值。当返回"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"true"},{"Type":"NodeText","Data":"​时执行存储操作，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"false"},{"Type":"NodeText","Data":"​则更新期望值。"}]},{"ID":"20240509095426-abltfq1","Type":"NodeParagraph","Properties":{"id":"20240509095426-abltfq1","updated":"20240509095445"},"Children":[{"Type":"NodeText","Data":"对于"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"compare_exchange_weak()"},{"Type":"NodeText","Data":"​，当原始值与预期值一致时，存储也可能会不成功。在这种情况中变量的值不会发生改变，并且compare_exchange_weak()的返回值是false。"}]},{"ID":"20240509095435-cmfz9ow","Type":"NodeBlockquote","Properties":{"id":"20240509095435-cmfz9ow","updated":"20240509095507"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240509095452-rvkspdw","Type":"NodeParagraph","Properties":{"id":"20240509095452-rvkspdw","updated":"20240509095507"},"Children":[{"Type":"NodeText","Data":"这最可能发生在缺少单条CAS操作(“比较-交换”指令)的机器上，当处理器不能保证这个操作能够原子的完成——可能因为线程的操作执行到必要操作的中间时被切换，并且另一个线程将会被操作系统调度(这里线程数多于处理器数量)，称为“"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"伪失败"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"”(spurious failure)，因为造成这种情况的是时间，而不是变量值。"}]}]},{"ID":"20240509095507-2dxtokh","Type":"NodeParagraph","Properties":{"id":"20240509095507-2dxtokh","updated":"20240509095613"},"Children":[{"Type":"NodeText","Data":"由于"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"compare_exchang_weak()"},{"Type":"NodeText","Data":"​会伪失败，因此通常会配合一个循环："}]},{"ID":"20240509095614-izuah5f","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240509095614-izuah5f","updated":"20240509095619"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"bool expected=false;\nextern atomic\u003cbool\u003e b; // 设置些什么\nwhile(!b.compare_exchange_weak(expected,true) \u0026\u0026 !expected);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240509095619-b1uiy1m","Type":"NodeParagraph","Properties":{"id":"20240509095619-b1uiy1m","updated":"20240509095835"},"Children":[{"Type":"NodeText","Data":"“compare/exchange”另一点不同的是，它拥有对两个内存序的参数进行操作的能力，这就允许内存序语义在成功和失败的例子中有所不同。"}]},{"ID":"20240509095946-ayx7huj","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240509095946-ayx7huj","updated":"20240509100046"},"Children":[{"Type":"NodeText","Data":"5.2.4 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic\u0026lt;T*\u0026gt;"},{"Type":"NodeText","Data":"​"}]},{"ID":"20240509100046-8w01tsn","Type":"NodeParagraph","Properties":{"id":"20240509100046-8w01tsn","updated":"20240509100106"},"Children":[{"Type":"NodeText","Data":"原子指针类型，可以使用内置类型或自定义类型T，通过特化"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic\u0026lt;T*\u0026gt;"},{"Type":"NodeText","Data":"​进行定义，操作是针对于相关类型的指针。"}]},{"ID":"20240509100217-iy48h7r","Type":"NodeParagraph","Properties":{"id":"20240509100217-iy48h7r","updated":"20240509100415"},"Children":[{"Type":"NodeText","Data":"这一类型提供了"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"fetch_add"},{"Type":"NodeText","Data":"​与"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"fetch_sub"},{"Type":"NodeText","Data":"​对指针进行地址偏移。并返回原来的地址。"}]},{"ID":"20240509100625-kixge8p","Type":"NodeParagraph","Properties":{"id":"20240509100625-kixge8p","updated":"20240509100640"},"Children":[{"Type":"NodeText","Data":"这两种操作都是“读-改-写”操作。"}]},{"ID":"20240509100640-37qst7t","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240509100640-37qst7t","updated":"20240509100657"},"Children":[{"Type":"NodeText","Data":"5.2.5 标准原子整型"}]},{"ID":"20240509100657-4kskrwf","Type":"NodeParagraph","Properties":{"id":"20240509100657-4kskrwf","updated":"20240509100731"},"Children":[{"Type":"NodeText","Data":"还有"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"fetch_add(), fetch_sub(), fetch_and(), fetch_or(), fetch_xor()"},{"Type":"NodeText","Data":"​，和对应的复合赋值方式"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"((+=, -=, \u0026amp;=, |=和^=)，以及++和--(++x, x++, --x和x--)"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20240509100732-hn4gmmq","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240509100732-hn4gmmq","updated":"20240509100745"},"Children":[{"Type":"NodeText","Data":"5.2.6 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic\u0026lt;\u0026gt;"},{"Type":"NodeText","Data":"​类模版"}]},{"ID":"20240509100745-hrl8elg","Type":"NodeParagraph","Properties":{"id":"20240509100745-hrl8elg","updated":"20240509101020"},"Children":[{"Type":"NodeText","Data":"为了使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic\u0026lt;UDT\u0026gt;"},{"Type":"NodeText","Data":"​，UDT必须有拷贝赋值运算符。此外UDT不能有任何虚函数或虚基类，这意味着编译器可以使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"memcpy()"},{"Type":"NodeText","Data":"​或复制操作的等价操作，因为实现中没有用户代码。"}]},{"ID":"20240509101215-5019dz0","Type":"NodeParagraph","Properties":{"id":"20240509101215-5019dz0","updated":"20240509101215"},"Children":[{"Type":"NodeText","Data":"比较-交换操作操作就类似于memcmp使用位比较，而非为UDT类定义一个比较操作符。"}]},{"ID":"20240509101509-zwsblyu","Type":"NodeParagraph","Properties":{"id":"20240509101509-zwsblyu","updated":"20240509101956"},"Children":[{"Type":"NodeText","Data":"以上严格的限制都是依据第3章中的建议："},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"不要将锁定区域内的数据以引用或指针的形式，作为参数传递给用户提供的函数"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"通常情况下，编译器不会为"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"code text","TextMarkTextContent":"std::atomic\u0026lt;UDT\u0026gt;"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"生成无锁代码，所以所有操作使用一个内部锁。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"如果允许用户提供的拷贝赋值或比较操作，就需要传递保护数据的引用作为参数，这就有悖于指导意见了。"}]},{"ID":"20240509101911-13rv25q","Type":"NodeParagraph","Properties":{"id":"20240509101911-13rv25q","updated":"20240509102219"},"Children":[{"Type":"NodeText","Data":"对于"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic\u0026lt;float\u0026gt;"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic\u0026lt;double\u0026gt;"},{"Type":"NodeText","Data":"​，在"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"compare_exchange_strong"},{"Type":"NodeText","Data":"​里当存储的值与当前值相等时，这个操作也可能失败，可能因为旧值是一个不同的表达（自定义的比较操作与memcmp不同）。这就不是对浮点数的原子计算操作了。"}]},{"ID":"20240509102145-qppm16l","Type":"NodeParagraph","Properties":{"id":"20240509102145-qppm16l","updated":"20240509102150"},"Children":[{"Type":"NodeText","Data":"如果UDT类型的大小如同(或小于)一个int或"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"void*"},{"Type":"NodeText","Data":"​类型时，大多数平台将会对"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic\u0026lt;UDT\u0026gt;"},{"Type":"NodeText","Data":"​使用原子指令。"}]},{"ID":"20240509102234-b7eh9wb","Type":"NodeParagraph","Properties":{"id":"20240509102234-b7eh9wb","updated":"20240509102307"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"strong text","TextMarkTextContent":"以上的限制也意味着有些事情不能做"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"，"}]},{"ID":"20240509102255-ba368e0","Type":"NodeBlockquote","Properties":{"id":"20240509102255-ba368e0","updated":"20240509102303"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240509102303-40ua0ml","Type":"NodeParagraph","Properties":{"id":"20240509102303-40ua0ml","updated":"20240509102303"},"Children":[{"Type":"NodeText","Data":"比如：创建一个"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic[std::vector\u0026lt;int](std::vector%3Cint)\u0026gt;"},{"Type":"NodeText","Data":"​类型。不能使用包含有计数器，标志指针和简单数组的类型，作为特化类型。虽然这不会导致任何问题，但是越是复杂的数据结构，就有越多的操作，而非只有赋值和比较。"}]}]},{"ID":"20240509102308-fr5shh1","Type":"NodeParagraph","Properties":{"id":"20240509102308-fr5shh1","updated":"20240509102319"},"Children":[{"Type":"NodeText","Data":"当使用用户定义类型T进行实例化时，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic\u0026lt;T\u0026gt;"},{"Type":"NodeText","Data":"​的可用接口就只有: load(), store(), exchange(), compare_exchange_weak(), compare_exchange_strong()和赋值操作，以及向类型T转换的操作。"}]},{"ID":"20240509102325-hl2igkb","Type":"NodeParagraph","Properties":{"id":"20240509102325-hl2igkb","updated":"20240509102327"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240509102325-d1rq14c.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240509102351-o1gj1ul","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240509102351-o1gj1ul","updated":"20240509102458"},"Children":[{"Type":"NodeText","Data":"5.3 同步操作和强制排序"}]},{"ID":"20240509102458-qimjj70","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240509102458-qimjj70","updated":"20240510084449"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"#include \u003cvector\u003e\n#include \u003catomic\u003e\n#include \u003ciostream\u003e\n\nstd::vector\u003cint\u003e data;\nstd::atomic\u003cbool\u003e data_ready(false);\n\nvoid reader_thread()\n{\n  while(!data_ready.load())  // 1\n  {\n    std::this_thread::sleep(std::milliseconds(1));\n  }\n  std::cout\u003c\u003c\"The answer=\"\u003c\u003cdata[0]\u003c\u003c\"\\m\";  // 2\n}\nvoid writer_thread()\n{\n  data.push_back(42);  // 3\n  data_ready=true;  // 4\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240510084451-9aqbrcz","Type":"NodeParagraph","Properties":{"id":"20240510084451-9aqbrcz","updated":"20240510084552"},"Children":[{"Type":"NodeText","Data":"假如没有1，那么非原子读2和写3对同一数据结构进行无序访问时就破坏了遵守的访问顺序，产生未定义行为。"}]},{"ID":"20240510084553-63toa8s","Type":"NodeParagraph","Properties":{"id":"20240510084553-63toa8s","updated":"20240510084606"},"Children":[{"Type":"NodeText","Data":"但是这里访问顺序通过对"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::atomic\u0026lt;bool\u0026gt;"},{"Type":"NodeText","Data":"​类型的data_ready变量进行操作完成，这些操作通过"},{"Type":"NodeTextMark","TextMarkType":"em a","TextMarkAHref":"http://en.wikipedia.org/wiki/Happened-before","TextMarkTextContent":"先行"},{"Type":"NodeText","Data":"(happens-before)和"},{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":"同发"},{"Type":"NodeText","Data":"(synchronizes-with)确定顺序。"}]},{"ID":"20240510084607-4tgkgxd","Type":"NodeBlockquote","Properties":{"id":"20240510084607-4tgkgxd","updated":"20240510084636"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240510084619-ci9yl2s","Type":"NodeParagraph","Properties":{"id":"20240510084619-ci9yl2s","updated":"20240510084630"},"Children":[{"Type":"NodeText","Data":"写入数据③在写入data_ready④前发生，读取①发生在读取数据②之前。当data_ready①为true，写操作就会与读操作同步，建立一个“先行”的关系。因为“先行”关系是可传递的，所以写入③先行于写入④，这两个行为又先行于读取操作①，之前的操作都先行于读取数据②，这样就强制了顺序：写入数据先行于读取数据。"}]},{"ID":"20240510084634-839urxc","Type":"NodeParagraph","Properties":{"id":"20240510084634-839urxc","updated":"20240510084636"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240510084634-kqgimaz.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]}]},{"ID":"20240510084640-69kx64i","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240510084640-69kx64i","updated":"20240510084649"},"Children":[{"Type":"NodeText","Data":"5.3.1 同步发生"}]},{"ID":"20240510084649-i33d88a","Type":"NodeParagraph","Properties":{"id":"20240510084649-i33d88a","updated":"20240510084654"},"Children":[{"Type":"NodeText","Data":"“同发”只在原子类型之间进行。"}]},{"ID":"20240510084655-58oylyi","Type":"NodeBlockquote","Properties":{"id":"20240510084655-58oylyi","updated":"20240510084700"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240510084656-9r612ov","Type":"NodeParagraph","Properties":{"id":"20240510084656-9r612ov","updated":"20240510084700"},"Children":[{"Type":"NodeText","Data":"例如：操作一个数据结构(对互斥量上锁)，如果数据结构包含有原子类型，并且操作内部执行了一定的原子操作，那这些操作就是“同发”关系。"}]}]},{"ID":"20240510084701-y7e1quf","Type":"NodeParagraph","Properties":{"id":"20240510084701-y7e1quf","updated":"20240510084722"},"Children":[{"Type":"NodeText","Data":"“同发”的基本想法：原子写操作W对变量x进行标记，同步与对x进行原子读操作，读取的是W操作写入的内容，或是W之后，同一线程上的原子写操作对x写入的值，亦或是任意线程对x的一系列原子读-改-写操作"}]},{"ID":"20240510084810-3ki7t0q","Type":"NodeBlockquote","Properties":{"id":"20240510084810-3ki7t0q","updated":"20240510084812"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240510084812-7yqgwqw","Type":"NodeParagraph","Properties":{"id":"20240510084812-7yqgwqw","updated":"20240510084812"},"Children":[{"Type":"NodeText","Data":"(例如，fetch_add()或compare_exchange_weak())。"}]}]},{"ID":"20240510084738-0ajzgq0","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240510084738-0ajzgq0","updated":"20240510084847"},"Children":[{"Type":"NodeText","Data":"5.3.2 先行发生"}]},{"ID":"20240510084935-fv7bb2a","Type":"NodeParagraph","Properties":{"id":"20240510084935-fv7bb2a","updated":"20240510084942"},"Children":[{"Type":"NodeText","Data":"“先行”关系是一个程序中基本构建块的操作顺序：指定了某个操作去影响另一个操作。"}]},{"ID":"20240510084946-ol5e7mw","Type":"NodeBlockquote","Properties":{"id":"20240510084946-ol5e7mw","updated":"20240510085002"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240510084955-uc810k8","Type":"NodeParagraph","Properties":{"id":"20240510084955-uc810k8","updated":"20240510085002"},"Children":[{"Type":"NodeText","Data":"对于单线程来说：一个操作排在另一个之后，那这个操作就先执行。如果源码中操作A发生在操作B之前，那A就先行于B。可以回看代码5.2：对data的写入③先于对data_ready④的写入。"}]}]},{"ID":"20240510085005-p6fcmpv","Type":"NodeParagraph","Properties":{"id":"20240510085005-p6fcmpv","updated":"20240510085013"},"Children":[{"Type":"NodeText","Data":"如果操作在同时发生，因为操作间无序执行，通常情况下就没有先行关系了。例如："}]},{"ID":"20240510085013-t96m51z","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240510085013-t96m51z","updated":"20240510085018"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"#include \u003ciostream\u003e\nvoid foo(int a,int b)\n{\n  std::cout\u003c\u003ca\u003c\u003c”,”\u003c\u003cb\u003c\u003cstd::endl;\n}\nint get_num()\n{\n  static int i=0;\n  return ++i;\n}\nint main()\n{\n  foo(get_num(),get_num());  // 无序调用get_num()\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240510085019-wi4h6mf","Type":"NodeParagraph","Properties":{"id":"20240510085019-wi4h6mf","updated":"20240510085137"},"Children":[{"Type":"NodeText","Data":"如果操作A在线程上，并且线程先行于另一线程上的操作B，那么A就先行于B。"}]},{"ID":"20240510085139-s1qz4w8","Type":"NodeParagraph","Properties":{"id":"20240510085139-s1qz4w8","updated":"20240510085156"},"Children":[{"Type":"NodeText","Data":"线程间的先行比较简单，并且依赖与同步关系(详见5.3.1节)：如果操作A在一个线程上，与另一个线程上的操作B同步，那么A就线程间先行于B。这也是一个传递关系：如果A线程间先行于B，并且B线程间先行于C，那么A就线程间先行于C。"}]},{"ID":"20240510085228-2hnd59z","Type":"NodeParagraph","Properties":{"id":"20240510085228-2hnd59z","updated":"20240510085228"},"Children":[{"Type":"NodeText","Data":"线程间先行可以与排序先行相结合：如果操作A排序先行于操作B，并且操作B线程间先行于操作C，那么A线程间先行于C。同样的，如果A同步于B，并且B排序先于C，那么A线程间先行于C。当对数据进行一系列修改(单线程)时，只需要对数据进行一次同步即可。"}]},{"ID":"20240510085233-ee1dq5i","Type":"NodeParagraph","Properties":{"id":"20240510085233-ee1dq5i","updated":"20240510085251"},"Children":[{"Type":"NodeText","Data":"强先行发生关系会有一些不同，不过在大多数情况下是一样的。如果操作A与操作B同步，或操作A的顺序在操作B之前，那么A就是强先行于B。也适用于顺序传递。"}]},{"ID":"20240510085252-7auwif0","Type":"NodeBlockquote","Properties":{"id":"20240510085252-7auwif0","updated":"20240510085304"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240510085253-jugciow","Type":"NodeParagraph","Properties":{"id":"20240510085253-jugciow","updated":"20240510085304"},"Children":[{"Type":"NodeText","Data":"如果A强先行于B，并且B强先行于C，那么A就肯定强先行于C。"}]}]},{"ID":"20240510085304-im0kko5","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240510085304-im0kko5","updated":"20240510085328"},"Children":[{"Type":"NodeText","Data":"5.3.3 原子操作的内存序"}]},{"ID":"20240510085606-r9qh8bj","Type":"NodeSuperBlock","Properties":{"id":"20240510085606-r9qh8bj","updated":"20240510085628"},"Children":[{"Type":"NodeSuperBlockOpenMarker"},{"Type":"NodeSuperBlockLayoutMarker","Data":"row"},{"ID":"20240510085551-jhbvw8x","Type":"NodeParagraph","Properties":{"id":"20240510085551-jhbvw8x","updated":"20240510085620"},"Children":[{"Type":"NodeText","Data":"这里有六个内存序列选项可应用于对原子类型的操作"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"："}]},{"ID":"20240510085551-q18sats","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240510085551-q18sats","updated":"20240510085628"},"Children":[{"ID":"20240510085551-r4f0b71","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240510085551-r4f0b71","updated":"20240510085621"},"Children":[{"ID":"20240510085551-w7kcdcn","Type":"NodeParagraph","Properties":{"id":"20240510085551-w7kcdcn","updated":"20240510085621"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"memory_order_relaxed"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20240510085551-1uvefu8","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240510085551-1uvefu8","updated":"20240510085623"},"Children":[{"ID":"20240510085551-7mb5tqp","Type":"NodeParagraph","Properties":{"id":"20240510085551-7mb5tqp","updated":"20240510085623"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"memory_order_consume"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20240510085551-ou2qnw4","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20240510085551-ou2qnw4","updated":"20240510085624"},"Children":[{"ID":"20240510085551-os18gx7","Type":"NodeParagraph","Properties":{"id":"20240510085551-os18gx7","updated":"20240510085624"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"memory_order_acquire"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20240510085551-wzc4r3z","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NC4=","Num":4},"Properties":{"id":"20240510085551-wzc4r3z","updated":"20240510085625"},"Children":[{"ID":"20240510085551-22q0saj","Type":"NodeParagraph","Properties":{"id":"20240510085551-22q0saj","updated":"20240510085625"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"memory_order_release"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20240510085551-nqkrlff","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"NS4=","Num":5},"Properties":{"id":"20240510085551-nqkrlff","updated":"20240510085626"},"Children":[{"ID":"20240510085551-hwjnlwm","Type":"NodeParagraph","Properties":{"id":"20240510085551-hwjnlwm","updated":"20240510085626"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"memory_order_acq_rel"},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20240510085551-vaujg37","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Ni4=","Num":6},"Properties":{"id":"20240510085551-vaujg37","updated":"20240510085628"},"Children":[{"ID":"20240510085551-x90tgsu","Type":"NodeParagraph","Properties":{"id":"20240510085551-x90tgsu","updated":"20240510085628"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"memory_order_seq_cst"},{"Type":"NodeText","Data":"​"}]}]}]},{"Type":"NodeSuperBlockCloseMarker"}]},{"ID":"20240510085551-cvz3rcz","Type":"NodeParagraph","Properties":{"id":"20240510085551-cvz3rcz","updated":"20240510085630"},"Children":[{"Type":"NodeText","Data":"除非为特定的操作指定一个序列选项，要不内存序列默认都是"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"memory_order_seq_cst"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20240510085630-0feyzot","Type":"NodeParagraph","Properties":{"id":"20240510085630-0feyzot","updated":"20240510085638"},"Children":[{"Type":"NodeText","Data":"代表了三种内存模型："}]},{"ID":"20240510085638-xkoky47","Type":"NodeList","ListData":{},"Properties":{"id":"20240510085638-xkoky47","updated":"20240510085721"},"Children":[{"ID":"20240510085639-6ufgb4l","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240510085639-6ufgb4l","updated":"20240510085639"},"Children":[{"ID":"20240510085639-r6i1bo8","Type":"NodeParagraph","Properties":{"id":"20240510085639-r6i1bo8","updated":"20240510085648"},"Children":[{"Type":"NodeText","Data":"顺序一致性"}]}]},{"ID":"20240510085649-gky7blf","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240510085649-gky7blf"},"Children":[{"ID":"20240510085649-0m3saln","Type":"NodeParagraph","Properties":{"id":"20240510085649-0m3saln","updated":"20240510085711"},"Children":[{"Type":"NodeText","Data":"获取释放序("},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"memory_order_consume"},{"Type":"NodeText","Data":"​, "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"memory_order_acquire"},{"Type":"NodeText","Data":"​, "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"memory_order_release"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"memory_order_acq_rel"},{"Type":"NodeText","Data":"​)"}]}]},{"ID":"20240510085714-wuki4b6","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240510085714-wuki4b6","updated":"20240510085721"},"Children":[{"ID":"20240510085714-f60gngv","Type":"NodeParagraph","Properties":{"id":"20240510085714-f60gngv","updated":"20240510085721"},"Children":[{"Type":"NodeText","Data":"自由序："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"memory_order_relaxed"},{"Type":"NodeText","Data":"​"}]}]}]},{"ID":"20240510085722-8djbv2h","Type":"NodeParagraph","Properties":{"id":"20240510085722-8djbv2h","updated":"20240510085910"},"Children":[{"Type":"NodeText","Data":"不同的内存序在不同的CPU架构下功耗不同。"}]},{"ID":"20240510085911-cc6wput","Type":"NodeBlockquote","Properties":{"id":"20240510085911-cc6wput","updated":"20240510085928"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240510085911-ob0q7aj","Type":"NodeParagraph","Properties":{"id":"20240510085911-ob0q7aj","updated":"20240510085928"},"Children":[{"Type":"NodeText","Data":"例如：基于处理器架构的可视化精细操作系统，可使用顺序一致或被获取-释放序(在自由序之前)添加的同步指令。如果有多个处理器，额外的同步指令会消耗大量的时间，从而降低系统性能。另一方面，CPU使用的是x86或x86-64架构(例如，使用Intel或AMD处理器的台式电脑)，这种架构的CPU不需要对获取-释放序添加额外的指令(没有保证原子性的必要了)，顺序一致序对于加载操作也不需要任何处理，但在进行存储时需要额外的消耗。"}]}]},{"ID":"20240510085942-i3a121u","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240510085942-i3a121u","updated":"20240510085951"},"Children":[{"Type":"NodeText","Data":"5.3.3.1 顺序一致性"}]},{"ID":"20240510085951-4y9prdb","Type":"NodeParagraph","Properties":{"id":"20240510085951-4y9prdb","updated":"20240510090110"},"Children":[{"Type":"NodeText","Data":"这是默认的内存序。因为在这个内存序下，不同的操作也要遵守相同的顺序。因为行为简单，可以使用原子变量进行编写。通过不同的线程，可以写出所有可能的操作消除那些不一致，以及确认代码的行为是否与预期相符。"}]},{"ID":"20240510090123-pkirrar","Type":"NodeParagraph","Properties":{"id":"20240510090123-pkirrar","updated":"20240510090128"},"Children":[{"Type":"NodeText","Data":"所以，操作都不能重排；"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"如果代码在一个线程中，将一个操作放在另一个操作前面，那其他线程也需要了解这个顺序"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240510090129-xsk25jc","Type":"NodeParagraph","Properties":{"id":"20240510090129-xsk25jc","updated":"20240510090214"},"Children":[{"Type":"NodeText","Data":"从同步的角度看，是对同一变量的存储操作与载入操作的同步。这就提供了一种对两个(以上)线程操作的排序约束，但"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"顺序一致的功能要比排序约束大的多，所以对于使用顺序一致的原子操作，都会存储值后再加载"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240510090215-vdpqfh8","Type":"NodeParagraph","Properties":{"id":"20240510090215-vdpqfh8","updated":"20240510090253"},"Children":[{"Type":"NodeText","Data":"因为整个序列中的操作都必须在多个处理器上保持一致，可能需要对处理器间的同步操作进行扩展(代价很昂贵！)。"}]},{"ID":"20240510090257-jo7jr86","Type":"NodeParagraph","Properties":{"id":"20240510090257-jo7jr86","updated":"20240510090319"},"Children":[{"Type":"NodeText","Data":"下面代码展示了顺序一致性的行为。"}]},{"ID":"20240510090320-1f9fotr","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240510090320-1f9fotr","updated":"20240510090328"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"#include \u003catomic\u003e\n#include \u003cthread\u003e\n#include \u003cassert.h\u003e\n\nstd::atomic\u003cbool\u003e x,y;\nstd::atomic\u003cint\u003e z;\n\nvoid write_x()\n{\n  x.store(true,std::memory_order_seq_cst);  // 1\n}\n\nvoid write_y()\n{\n  y.store(true,std::memory_order_seq_cst);  // 2\n}\nvoid read_x_then_y()\n{\n  while(!x.load(std::memory_order_seq_cst));\n  if(y.load(std::memory_order_seq_cst))  // 3\n    ++z;\n}\nvoid read_y_then_x()\n{\n  while(!y.load(std::memory_order_seq_cst));\n  if(x.load(std::memory_order_seq_cst))  // 4\n    ++z;\n}\nint main()\n{\n  x=false;\n  y=false;\n  z=0;\n  std::thread a(write_x);\n  std::thread b(write_y);\n  std::thread c(read_x_then_y);\n  std::thread d(read_y_then_x);\n  a.join();\n  b.join();\n  c.join();\n  d.join();\n  assert(z.load()!=0);  // 5\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240510090545-3ks3y96","Type":"NodeParagraph","Properties":{"id":"20240510090545-3ks3y96","updated":"20240510090620"},"Children":[{"Type":"NodeText","Data":"⑤永远不会触发，因为不是存储x的①发生就是存储y的②发生。"}]},{"ID":"20240510090704-2fiuqvo","Type":"NodeBlockquote","Properties":{"id":"20240510090704-2fiuqvo","updated":"20240510090737"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240510090704-jjfggz4","Type":"NodeParagraph","Properties":{"id":"20240510090704-jjfggz4","updated":"20240510090737"},"Children":[{"Type":"NodeText","Data":"如果在read_x_then_y中加载y③返回false，是因为存储x的操作发生在存储y的操作之前。在read_y_then_x中加载x④必定会返回true，因为while循环能保证在某一时刻y是true。"}]}]},{"ID":"20240510090816-d1zhki6","Type":"NodeParagraph","Properties":{"id":"20240510090816-d1zhki6","updated":"20240510090818"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240510090816-1e7gxmh.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240510090819-dm1vej0","Type":"NodeParagraph","Properties":{"id":"20240510090819-dm1vej0","updated":"20240510090915"},"Children":[{"Type":"NodeText","Data":"虚线始于read_x_then_y中对y的加载操作，到达write_y中对y的存储，其表示排序关系需要保持一致：全局操作序memory_order_seq_cst中，加载操作必须在存储操作前发生，这样就产生了图中的情况。"}]},{"ID":"20240510090945-1cqtc84","Type":"NodeParagraph","Properties":{"id":"20240510090945-1cqtc84","updated":"20240510091300"},"Children":[{"Type":"NodeText","Data":"序列一致性是最简单、直观的序列，因为需要对所有线程进行全局同步，所以也是开销最大的内存序。多处理器设备上需要在处理期间，在信息交换上耗费大量的时间。"}]},{"ID":"20240510091303-7c47uyu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240510091303-7c47uyu","updated":"20240510091311"},"Children":[{"Type":"NodeText","Data":"5.3.3.2 非顺序一致性内存"}]},{"ID":"20240510091311-9i3da43","Type":"NodeParagraph","Properties":{"id":"20240510091311-9i3da43","updated":"20240510091402"},"Children":[{"Type":"NodeText","Data":"不同线程看到相同操作，不一定有着相同的顺序，还有对于不同线程的操作，都会一个接着另一个执行的想法就不可行了。"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"不仅是考虑事情同时发生的问题，还有线程没办法保证一致性"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240510091403-qi24b7y","Type":"NodeParagraph","Properties":{"id":"20240510091403-qi24b7y","updated":"20240510091413"},"Children":[{"Type":"NodeText","Data":"即使线程运行相同的代码，都能拒绝遵循事件发生的顺序，因为操作在其他线程上没有明确的顺序限制，不同的CPU缓存和内部缓冲区，在同样的存储空间中可以存储不同的值。"}]},{"ID":"20240510091429-gz7ju9t","Type":"NodeParagraph","Properties":{"id":"20240510091429-gz7ju9t","updated":"20240510091455"},"Children":[{"Type":"NodeText","Data":"不仅是要摒弃串行的想法，还要放弃编译器或处理器重排指令的想法。"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"没有明确顺序限制时，就需要所有线程要对每个独立变量统一修改顺序"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。对不同变量的操作可以体现在不同线程的不同序列上，提供的值要与任意附加顺序限制保持一致。"}]},{"ID":"20240510091441-vn4q2i4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240510091441-vn4q2i4","updated":"20240510091510"},"Children":[{"Type":"NodeText","Data":"5.3.3.3 自由序"}]},{"ID":"20240510091510-2qwtjku","Type":"NodeParagraph","Properties":{"id":"20240510091510-2qwtjku","updated":"20240510091553"},"Children":[{"Type":"NodeText","Data":"原子类型上的操作以自由序执行。同一线程中对于同一变量的操作还是遵从先行关系，但"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"不同线程不需要规定顺序"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。唯一的要求是"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"在访问同一线程中的单个原子变量不能重排序，当给定线程看到原子变量的值时，随后线程的读操作就不会去检索较早的那个值"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240510091541-3v5env0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240510091541-3v5env0","updated":"20240510091609"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"#include \u003catomic\u003e\n#include \u003cthread\u003e\n#include \u003cassert.h\u003e\n\nstd::atomic\u003cbool\u003e x,y;\nstd::atomic\u003cint\u003e z;\n\nvoid write_x_then_y()\n{\n  x.store(true,std::memory_order_relaxed);  // 1\n  y.store(true,std::memory_order_relaxed);  // 2\n}\nvoid read_y_then_x()\n{\n  while(!y.load(std::memory_order_relaxed));  // 3\n  if(x.load(std::memory_order_relaxed))  // 4\n    ++z;\n}\nint main()\n{\n  x=false;\n  y=false;\n  z=0;\n  std::thread a(write_x_then_y);\n  std::thread b(read_y_then_x);\n  a.join();\n  b.join();\n  assert(z.load()!=0);  // 5\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240510093444-bpfcyh0","Type":"NodeParagraph","Properties":{"id":"20240510093444-bpfcyh0","updated":"20240510093444"},"Children":[{"Type":"NodeText","Data":"这次assert⑤可能会触发，因为加载x的操作④可能读取到false，即使加载y的操作③读取到true，并且存储x的操作①先发与存储y的操作②。x和y是两个不同的变量，所以没有顺序去保证每个操作产生相关值的可见性。"}]},{"ID":"20240510093448-j3zhlom","Type":"NodeParagraph","Properties":{"id":"20240510093448-j3zhlom","updated":"20240510093511"},"Children":[{"Type":"NodeText","Data":"非限制操作对于不同变量可以重排序，只要服从任意的先行关系即可(比如，在同一线程中)。"}]},{"ID":"20240510093512-tgr6zcc","Type":"NodeParagraph","Properties":{"id":"20240510093512-tgr6zcc","updated":"20240510093521"},"Children":[{"Type":"NodeText","Data":"尽管，不同的存储/加载操作间有着先行关系，这里不是在一对存储/加载之间了，所以加载操作可以看到“违反”顺序的存储操作。"}]},{"ID":"20240510093528-015i7j4","Type":"NodeParagraph","Properties":{"id":"20240510093528-015i7j4","updated":"20240510093530"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240510093528-qxm0rpa.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240510093534-3s73ycx","Type":"NodeParagraph","Properties":{"id":"20240510093534-3s73ycx","updated":"20240510093625"},"Children":[{"Type":"NodeText","Data":"下面是一个更复杂的例子，有三个变量和五个线程。"}]},{"ID":"20240510093626-43h9e9q","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240510093626-43h9e9q","updated":"20240510093630"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"#include \u003cthread\u003e\n#include \u003catomic\u003e\n#include \u003ciostream\u003e\n\nstd::atomic\u003cint\u003e x(0),y(0),z(0);  // 1\nstd::atomic\u003cbool\u003e go(false);  // 2\n\nunsigned const loop_count=10;\n\nstruct read_values\n{\n  int x,y,z;\n};\n\nread_values values1[loop_count];\nread_values values2[loop_count];\nread_values values3[loop_count];\nread_values values4[loop_count];\nread_values values5[loop_count];\n\nvoid increment(std::atomic\u003cint\u003e* var_to_inc,read_values* values)\n{\n  while(!go)\n    std::this_thread::yield();  // 3 自旋，等待信号\n  for(unsigned i=0;i\u003cloop_count;++i)\n  {\n    values[i].x=x.load(std::memory_order_relaxed);\n    values[i].y=y.load(std::memory_order_relaxed);\n    values[i].z=z.load(std::memory_order_relaxed);\n    var_to_inc-\u003estore(i+1,std::memory_order_relaxed);  // 4\n    std::this_thread::yield();\n  }\n}\n\nvoid read_vals(read_values* values)\n{\n  while(!go)\n    std::this_thread::yield(); // 5 自旋，等待信号\n  for(unsigned i=0;i\u003cloop_count;++i)\n  {\n    values[i].x=x.load(std::memory_order_relaxed);\n    values[i].y=y.load(std::memory_order_relaxed);\n    values[i].z=z.load(std::memory_order_relaxed);\n    std::this_thread::yield();\n  }\n}\n\nvoid print(read_values* v)\n{\n  for(unsigned i=0;i\u003cloop_count;++i)\n  {\n    if(i)\n      std::cout\u003c\u003c\",\";\n    std::cout\u003c\u003c\"(\"\u003c\u003cv[i].x\u003c\u003c\",\"\u003c\u003cv[i].y\u003c\u003c\",\"\u003c\u003cv[i].z\u003c\u003c\")\";\n  }\n  std::cout\u003c\u003cstd::endl;\n}\n\nint main()\n{\n  std::thread t1(increment,\u0026x,values1);\n  std::thread t2(increment,\u0026y,values2);\n  std::thread t3(increment,\u0026z,values3);\n  std::thread t4(read_vals,values4);\n  std::thread t5(read_vals,values5);\n\n  go=true;  // 6 开始执行主循环的信号\n\n  t5.join();\n  t4.join();\n  t3.join();\n  t2.join();\n  t1.join();\n\n  print(values1);  // 7 打印最终结果\n  print(values2);\n  print(values3);\n  print(values4);\n  print(values5);\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240510094350-0c6ax6q","Type":"NodeParagraph","Properties":{"id":"20240510094350-0c6ax6q","updated":"20240510094401"},"Children":[{"Type":"NodeText","Data":"一种可能的输出为："}]},{"ID":"20240510094401-1l5krpc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240510094401-1l5krpc","updated":"20240510094407"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"(0,0,0),(1,0,0),(2,0,0),(3,0,0),(4,0,0),(5,7,0),(6,7,8),(7,9,8),(8,9,8),(9,9,10)\n(0,0,0),(0,1,0),(0,2,0),(1,3,5),(8,4,5),(8,5,5),(8,6,6),(8,7,9),(10,8,9),(10,9,10)\n(0,0,0),(0,0,1),(0,0,2),(0,0,3),(0,0,4),(0,0,5),(0,0,6),(0,0,7),(0,0,8),(0,0,9)\n(1,3,0),(2,3,0),(2,4,1),(3,6,4),(3,9,5),(5,10,6),(5,10,8),(5,10,10),(9,10,10),(10,10,10)\n(0,0,0),(0,0,0),(0,0,0),(6,3,7),(6,5,7),(7,7,7),(7,8,7),(8,8,7),(8,8,9),(8,8,9)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240510094413-mlge7dk","Type":"NodeParagraph","Properties":{"id":"20240510094413-mlge7dk","updated":"20240510094431"},"Children":[{"Type":"NodeText","Data":"前三行中线程都做了更新，后两行线程只是做读取。每三个值都是一组x，y和z，并按照这样的顺序依次循环。对于输出，需要注意的是："}]},{"ID":"20240510094413-p8o4u3l","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20240510094413-p8o4u3l","updated":"20240510094429"},"Children":[{"ID":"20240510094413-wjxe77x","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20240510094413-wjxe77x","updated":"20240510094429"},"Children":[{"ID":"20240510094413-xn90847","Type":"NodeParagraph","Properties":{"id":"20240510094413-xn90847","updated":"20240510094429"},"Children":[{"Type":"NodeText","Data":"第一组值中x增1，第二组值中y增1，第三组中z增1。"}]}]},{"ID":"20240510094413-x6mvqh2","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20240510094413-x6mvqh2","updated":"20240510094426"},"Children":[{"ID":"20240510094413-pmju5de","Type":"NodeParagraph","Properties":{"id":"20240510094413-pmju5de","updated":"20240510094426"},"Children":[{"Type":"NodeText","Data":"x元素只在给定集中增加，y和z也一样，但是是不均匀增加，并且每个线程中的相对顺序都不同。"}]}]},{"ID":"20240510094413-rb6txj9","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20240510094413-rb6txj9","updated":"20240510094424"},"Children":[{"ID":"20240510094413-ie1jqb1","Type":"NodeParagraph","Properties":{"id":"20240510094413-ie1jqb1","updated":"20240510094424"},"Children":[{"Type":"NodeText","Data":"线程3看不到x或y的任何更新，它能看到的只有z的更新。这并不妨碍别的线程观察z的更新，并同时观察x和y的更新。"}]}]}]},{"ID":"20240510094413-cuvsym9","Type":"NodeParagraph","Properties":{"id":"20240510094413-cuvsym9","updated":"20240510094419"},"Children":[{"Type":"NodeText","Data":"对于非限制操作，这个结果没毛病(但是不是唯一合法的输出)。任意组都用三个变量保持一致，从0到10依次递增，并且线程对相应变量进行递增操作，所以打印出的值在0到10的范围内都合理。"}]},{"ID":"20240510094448-9avvfov","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240510094448-9avvfov","updated":"20240510094730"},"Children":[{"Type":"NodeText","Data":"5.3.3.4 了解自由序"}]},{"ID":"20240510094730-r5gpk8s","Type":"NodeBlockquote","Properties":{"id":"20240510094730-r5gpk8s","updated":"20240510095017"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240510094838-fs8b3nk","Type":"NodeParagraph","Properties":{"id":"20240510094838-fs8b3nk","updated":"20240510094844"},"Children":[{"Type":"NodeText","Data":"为了了解自由序是如何工作的，可先将每一个变量想象成在一个独立房间中拿着记事本的人。他的记事本上是一组值的列表，可以通过打电话的方式让他给你一个值，或让他写下一个新值。如果告诉他写下一个新值，他会将这个新值写在表的最后。如果让他给你一个值，他会从列表中读取一个值给你。"}]},{"ID":"20240510094838-7ab59et","Type":"NodeParagraph","Properties":{"id":"20240510094838-7ab59et","updated":"20240510094847"},"Children":[{"Type":"NodeText","Data":"第一次与这人交谈时，如果问他要一个值，他可能会在现有的列表中选区任意值告诉你。如果之后再问他要一个值，可能会得到与之前相同的值，或是列表下端的其他值，他不会给你列表上端的值。如果让他写一个值，并且随后再问他要一个值，他要不就给你你刚告诉他的那个值，要不就是一个列表下端的值。"}]},{"ID":"20240510094932-1bq5i0r","Type":"NodeParagraph","Properties":{"id":"20240510094932-1bq5i0r","updated":"20240510094932"},"Children":[{"Type":"NodeText","Data":"试想当他的笔记本上开始有5，10，23，3，1，2这几个数。如果问他索要一个值，你可能获取这几个数中的任意一个。如果他给你10，那么下次再问他要值的时候可能会再给你10，或者10后面的数，但绝对不会是5。如果那你问他要了五次，他就可能回答“10，10，1，2，2”。如果你让他写下42，他将会把这个值添加在列表的最后。如果你再问他要值，他可能会告诉你“42”，直到有其他值写在了后面，并且他愿意将那个数告诉你。"}]},{"ID":"20240510095008-s3k8sv2","Type":"NodeParagraph","Properties":{"id":"20240510095008-s3k8sv2","updated":"20240510095012"},"Children":[{"Type":"NodeText","Data":"现在，你有个朋友叫Carl，他也有那个计数员的电话。Carl也可以打电话给计算员，让他写下一个值或获取一个值，他对Carl回应的规则和你是一样的。他只有一部电话，所以一次只能处理一个人的请求，所以他记事本上的列表是一个简单的列表。但是，你让他写下一个新值的时候，不意味着他会将这个消息告诉Carl，反之亦然。如果Carl从他那里获取一个值“23”，之后因为你告诉他写下42，这不意味着下次他会将这件事告诉Carl。他可能会告诉Carl任意一个值，23，3，1，2，42亦或是67(是Fred在你之后告诉他的)。他会很高兴的告诉Carl“23，3，3，1，67”，与你告诉他的值完全不一致，这就像在使用便签跟踪告诉每个人的数字，如图5.5。"}]},{"ID":"20240510095016-0dl6jj0","Type":"NodeParagraph","Properties":{"id":"20240510095016-0dl6jj0","updated":"20240510095017"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240510095015-epcfjje.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]}]},{"ID":"20240510095128-ddf1tq2","Type":"NodeParagraph","Properties":{"id":"20240510095128-ddf1tq2","updated":"20240510095128"},"Children":[{"Type":"NodeText","Data":"现在，不仅仅有一个人在房间里，而是在一个小农场里，每个人都有一部电话和一个笔记本，这就是原子变量。每一个变量拥有自己的修改顺序(笔记上的简单数值列表)，但是每个原子变量之间没有任何关系。如果每一个调用者(你，Carl，Anne，Dave和Fred)是一个线程，对每个操作使用memory_order_relaxed就会得到上面的结果。还有些事情可以告诉小房子里的人，例如：“写下这个值，并且告诉我现在列表中的最后一个值”(exchange)，或“写下这个值，当列表的最后一个值为某值时，会进行猜测，如果猜错了，则告诉我最后一个值是多少”(compare_exchange_strong)，这些都不影响一般性原则。"}]},{"ID":"20240510095312-nft1mb9","Type":"NodeParagraph","Properties":{"id":"20240510095312-nft1mb9","updated":"20240510095331"},"Children":[{"Type":"NodeText","Data":"这就让自由的原子操作变得难以处理，他们必须与原子操作结合使用，这些原子操作必须有较强的排序语义。"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"为了让内部线程同步变得更有用，我强烈建议避免自由序的原子操作"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"，除非它们是硬性要求的，并且使用时需要十二分的谨慎。"}]},{"ID":"20240510095333-v49m2g8","Type":"NodeParagraph","Properties":{"id":"20240510095333-v49m2g8","updated":"20240510095347"},"Children":[{"Type":"NodeText","Data":"要想获取额外的同步，且不使用全局排序一致"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"，"},{"Type":"NodeText","Data":"可以使用"},{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":"获取-释放序"},{"Type":"NodeText","Data":"(acquire-release ordering)。"}]},{"ID":"20240510095344-gy9aw5e","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240510095344-gy9aw5e","updated":"20240510095358"},"Children":[{"Type":"NodeText","Data":"5.3.3.5 获取-释放序"}]},{"ID":"20240510095358-3gxytfm","Type":"NodeParagraph","Properties":{"id":"20240510095358-3gxytfm","updated":"20240510095416"},"Children":[{"Type":"NodeText","Data":"这是"},{"Type":"NodeTextMark","TextMarkType":"strong em","TextMarkTextContent":"自由序"},{"Type":"NodeText","Data":"(relaxed ordering)的加强版，虽然操作依旧没有统一顺序，但引入了同步。"}]},{"ID":"20240510095414-0fadkpt","Type":"NodeParagraph","Properties":{"id":"20240510095414-0fadkpt","updated":"20240510095503"},"Children":[{"Type":"NodeText","Data":"这种序列模型中，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"原子加载就是"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"em text","TextMarkTextContent":"获取"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"(acquire)操作(memory_order_acquire)，原子存储就是"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"em text","TextMarkTextContent":"释放"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"(memory_order_release)操作，原子读-改-写操作(例如fetch_add()或exchange())在这里，不是“获取”就是“释放”，或者两者兼有的操作(memory_order_acq_rel)，同步在线程释放和获取间是"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"em text","TextMarkTextContent":"成对的"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"(pairwise)，释放操作与获取操作同步就能读取已写入的值。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"}]},{"ID":"20240510095504-apvhklg","Type":"NodeParagraph","Properties":{"id":"20240510095504-apvhklg","updated":"20240510095520"},"Children":[{"Type":"NodeText","Data":"下面是一个例子："}]},{"ID":"20240510095520-vjp7d2k","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240510095520-vjp7d2k","updated":"20240510095525"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"#include \u003catomic\u003e\n#include \u003cthread\u003e\n#include \u003cassert.h\u003e\n\nstd::atomic\u003cbool\u003e x,y;\nstd::atomic\u003cint\u003e z;\nvoid write_x()\n{\n  x.store(true,std::memory_order_release);\n}\nvoid write_y()\n{\n  y.store(true,std::memory_order_release);\n}\nvoid read_x_then_y()\n{\n  while(!x.load(std::memory_order_acquire));\n  if(y.load(std::memory_order_acquire))  // 1\n    ++z;\n}\nvoid read_y_then_x()\n{\n  while(!y.load(std::memory_order_acquire));\n  if(x.load(std::memory_order_acquire))  // 2\n    ++z;\n}\nint main()\n{\n  x=false;\n  y=false;\n  z=0;\n  std::thread a(write_x);\n  std::thread b(write_y);\n  std::thread c(read_x_then_y);\n  std::thread d(read_y_then_x);\n  a.join();\n  b.join();\n  c.join();\n  d.join();\n  assert(z.load()!=0); // 3\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240510095622-feqrs91","Type":"NodeParagraph","Properties":{"id":"20240510095622-feqrs91","updated":"20240510095644"},"Children":[{"Type":"NodeText","Data":"例子中断言③可能会触发(就如同自由排序那样)，因为在加载x②和y①时，可能读取到false。"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"因为x和y是由不同线程写入，所以序列中的每一次释放和获取都不会影响到其他线程的操作"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240510095640-w4aw208","Type":"NodeParagraph","Properties":{"id":"20240510095640-w4aw208","updated":"20240510095750"},"Children":[{"Type":"NodeText","Data":"图5.6展示了代码5.7的先行关系，对于读取的结果，两个(读取)线程看到的是两个完全不同的世界。如前所述，这可能是因为"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"这里没有对先行顺序进行强制规定导致的"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240510095753-ezxohif","Type":"NodeParagraph","Properties":{"id":"20240510095753-ezxohif","updated":"20240510095754"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240510095753-xfb83n3.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240510095755-va7b09j","Type":"NodeParagraph","Properties":{"id":"20240510095755-va7b09j","updated":"20240510095949"},"Children":[{"Type":"NodeText","Data":"为了了解获取-释放序的优点，需要考虑将两次存储由一个线程来完成。"}]},{"ID":"20240510095950-oydcu0d","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240510095950-oydcu0d","updated":"20240510095953"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"#include \u003catomic\u003e\n#include \u003cthread\u003e\n#include \u003cassert.h\u003e\n\nstd::atomic\u003cbool\u003e x,y;\nstd::atomic\u003cint\u003e z;\n\nvoid write_x_then_y()\n{\n  x.store(true,std::memory_order_relaxed);  // 1 \n  y.store(true,std::memory_order_release);  // 2\n}\nvoid read_y_then_x()\n{\n  while(!y.load(std::memory_order_acquire));  // 3 自旋，等待y被设置为true\n  if(x.load(std::memory_order_relaxed))  // 4\n    ++z;\n}\nint main()\n{\n  x=false;\n  y=false;\n  z=0;\n  std::thread a(write_x_then_y);\n  std::thread b(read_y_then_x);\n  a.join();\n  b.join();\n  assert(z.load()!=0);  // 5\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240510095954-63ftcsw","Type":"NodeParagraph","Properties":{"id":"20240510095954-63ftcsw","updated":"20240510100127"},"Children":[{"Type":"NodeText","Data":"最后，读取y③时会得到true，和存储时写入的一样②。存储使用的是memory_order_release，读取使用的是memory_order_acquire，存储与读取就同步了。因为这两个操作是由同一个线程串行完成的，所以存储x①的操作先行于存储y②的操作。对y的存储同步与对y的加载，存储x也就先行于对y的加载，并且扩展先行于x的读取。因此，加载x的值必为true，并且断言⑤不会触发。"}]},{"ID":"20240510100128-wo0weze","Type":"NodeParagraph","Properties":{"id":"20240510100128-wo0weze","updated":"20240510100139"},"Children":[{"Type":"NodeText","Data":"如果对于y的加载不是在while循环中，情况可能就会有所不同。加载y的时候可能会读取到false，这种情况下对于读取到的x是什么值没有要求了。"}]},{"ID":"20240510100139-s5k05ay","Type":"NodeParagraph","Properties":{"id":"20240510100139-s5k05ay","updated":"20240510100150"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"为了保证同步，加载和释放操作必须成对。所以，无论有何影响，释放操作存储的值必须要让获取操作看到。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"}]},{"ID":"20240510100151-zmg5kfq","Type":"NodeParagraph","Properties":{"id":"20240510100151-zmg5kfq","updated":"20240510100214"},"Children":[{"Type":"NodeText","Data":"当存储②或加载③都是一个释放操作时，对x的访问就无序了，也就无法保证④处读到的是true，并且还会触发断言。"}]}]}