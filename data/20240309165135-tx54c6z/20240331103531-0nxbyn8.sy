{"ID":"20240331103531-0nxbyn8","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240331103531-0nxbyn8","title":"Chapter4 同步操作","type":"doc","updated":"20240429112517"},"Children":[{"ID":"20240331103531-u25rpxn","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240331103531-u25rpxn","updated":"20240331103637"},"Children":[{"Type":"NodeText","Data":"4.1 等待事件或条件"}]},{"ID":"20240331103637-ucmi971","Type":"NodeParagraph","Properties":{"id":"20240331103637-ucmi971","updated":"20240331103758"},"Children":[{"Type":"NodeText","Data":"可以利用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::this_thread::sleep_for()"},{"Type":"NodeText","Data":"​进行周期间歇访问："}]},{"ID":"20240331103758-cuabul6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240331103758-cuabul6","updated":"20240331103801"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"bool flag;\nstd::mutex m;\n\nvoid wait_for_flag()\n{\n  std::unique_lock\u003cstd::mutex\u003e lk(m);\n  while(!flag)\n  {\n    lk.unlock();  // 1 解锁互斥量\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));  // 2 休眠100ms\n    lk.lock();   // 3 再锁互斥量\n  }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240331103803-9nzromo","Type":"NodeParagraph","Properties":{"id":"20240331103803-9nzromo","updated":"20240331103911"},"Children":[{"Type":"NodeText","Data":"优先选择广播等待完成时间的方式。"}]},{"ID":"20240331103911-z0g3dvh","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240331103911-z0g3dvh","updated":"20240331103917"},"Children":[{"Type":"NodeText","Data":"4.1.1 等待条件达成"}]},{"ID":"20240331103918-8bo4yj7","Type":"NodeParagraph","Properties":{"id":"20240331103918-8bo4yj7","updated":"20240331103938"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"C++标准库对条件变量有两套实现："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::condition_variable"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::condition_variable_any"},{"Type":"NodeText","Data":"​，这两个实现都包含在"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026lt;condition_variable\u0026gt;"},{"Type":"NodeText","Data":"​头文件的声明中。两者都需要与互斥量一起才能工作(互斥量是为了同步)，前者仅能与"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::mutex"},{"Type":"NodeText","Data":"​一起工作，而后者可以和合适的互斥量一起工作，从而加上了"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"_any"},{"Type":"NodeText","Data":"​的后缀。"}]},{"ID":"20240331103939-e2lc7qv","Type":"NodeParagraph","Properties":{"id":"20240331103939-e2lc7qv","updated":"20240331103948"},"Children":[{"Type":"NodeText","Data":"通常"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"会将"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::condition_variable"},{"Type":"NodeText","Data":"​作为首选类型。"}]},{"ID":"20240331103954-8oc73ak","Type":"NodeParagraph","Properties":{"id":"20240331103954-8oc73ak","updated":"20240331104015"},"Children":[{"Type":"NodeText","Data":"下面代码展示了使用条件变量唤醒线程的方式。"}]},{"ID":"20240331104015-9y74eb6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240331104015-9y74eb6","updated":"20240331104020"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"std::mutex mut;\nstd::queue\u003cdata_chunk\u003e data_queue;  // 1\nstd::condition_variable data_cond;\n\nvoid data_preparation_thread()\n{\n  while(more_data_to_prepare())\n  {\n    data_chunk const data=prepare_data();\n    std::lock_guard\u003cstd::mutex\u003e lk(mut);\n    data_queue.push(data);  // 2\n    data_cond.notify_one();  // 3\n  }\n}\n\nvoid data_processing_thread()\n{\n  while(true)\n  {\n    std::unique_lock\u003cstd::mutex\u003e lk(mut);  // 4\n    data_cond.wait(\n         lk,[]{return !data_queue.empty();});  // 5\n    data_chunk data=data_queue.front();\n    data_queue.pop();\n    lk.unlock();  // 6\n    process(data);\n    if(is_last_chunk(data))\n      break;\n  }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240331104246-bshyl2v","Type":"NodeParagraph","Properties":{"id":"20240331104246-bshyl2v","updated":"20240425083348"},"Children":[{"Type":"NodeText","Data":"⑤处：wait()会去检查这些条件(通过Lambda函数)，当条件满足(Lambda函数返回true)时返回。如果条件不满足(Lambda函数返回false)，wait()将解锁互斥量，并且将线程(处理数据的线程)置于阻塞或等待状态。当准备数据的线程调用notify_one()通知条件变量时，处理数据的线程从睡眠中苏醒，重新获取互斥锁，并且再次进行条件检查。在条件满足的情况下，从wait()返回并继续持有锁。当条件不满足时，线程将对互斥量解锁，并重新等待。"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"strong text","TextMarkTextContent":"这就是为什么用"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"code text","TextMarkTextContent":"std::unique_lock"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"而不使用"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"code text","TextMarkTextContent":"std::lock_guard"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"的原因——等待中的线程必须在等待期间解锁互斥量，并对互斥量再次上锁"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"strong text","TextMarkTextContent":"，而"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"code text","TextMarkTextContent":"std::lock_guard"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"没有这么灵活"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240331104935-nz4om76","Type":"NodeParagraph","Properties":{"id":"20240331104935-nz4om76","updated":"20240331104935"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"本质上，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::condition_variable::wait"},{"Type":"NodeText","Data":"​是“忙碌-等待”的优化。"}]},{"ID":"20240331104949-87ov9z3","Type":"NodeParagraph","Properties":{"id":"20240331104949-87ov9z3","updated":"20240331104950"},"Children":[{"Type":"NodeText","Data":"下面用简单的循环实现了一个“忙碌-等待”："}]},{"ID":"20240331104951-z5xk7fk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240331104951-z5xk7fk","updated":"20240331104954"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"template\u003ctypename Predicate\u003e\nvoid minimal_wait(std::unique_lock\u003cstd::mutex\u003e\u0026 lk, Predicate pred){\n  while(!pred()){\n    lk.unlock();\n    lk.lock();\n  }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240331104937-d66sa6u","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240331104937-d66sa6u","updated":"20240331105019"},"Children":[{"Type":"NodeText","Data":"4.1.2 构建线程安全队列"}]},{"ID":"20240331105019-myyll5r","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240331105019-myyll5r","updated":"20240331105236"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"#include \u003cqueue\u003e\n#include \u003cmemory\u003e\n#include \u003cmutex\u003e\n#include \u003ccondition_variable\u003e\n\ntemplate\u003ctypename T\u003e\nclass threadsafe_queue\n{\nprivate:\n  mutable std::mutex mut;  // 1 互斥量必须是可变的 \n  std::queue\u003cT\u003e data_queue;\n  std::condition_variable data_cond;\npublic:\n  threadsafe_queue()\n  {}\n  threadsafe_queue(threadsafe_queue const\u0026 other)\n  {\n    std::lock_guard\u003cstd::mutex\u003e lk(other.mut);\n    data_queue=other.data_queue;\n  }\n\n  void push(T new_value)\n  {\n    std::lock_guard\u003cstd::mutex\u003e lk(mut);\n    data_queue.push(new_value);\n    data_cond.notify_one();\n  }\n\n  void wait_and_pop(T\u0026 value)\n  {\n    std::unique_lock\u003cstd::mutex\u003e lk(mut);\n    data_cond.wait(lk,[this]{return !data_queue.empty();});\n    value=data_queue.front();\n    data_queue.pop();\n  }\n\n  std::shared_ptr\u003cT\u003e wait_and_pop()\n  {\n    std::unique_lock\u003cstd::mutex\u003e lk(mut);\n    data_cond.wait(lk,[this]{return !data_queue.empty();});\n    std::shared_ptr\u003cT\u003e res(std::make_shared\u003cT\u003e(data_queue.front()));\n    data_queue.pop();\n    return res;\n  }\n\n  bool try_pop(T\u0026 value)\n  {\n    std::lock_guard\u003cstd::mutex\u003e lk(mut);\n    if(data_queue.empty())\n      return false;\n    value=data_queue.front();\n    data_queue.pop();\n    return true;\n  }\n\n  std::shared_ptr\u003cT\u003e try_pop()\n  {\n    std::lock_guard\u003cstd::mutex\u003e lk(mut);\n    if(data_queue.empty())\n      return std::shared_ptr\u003cT\u003e();\n    std::shared_ptr\u003cT\u003e res(std::make_shared\u003cT\u003e(data_queue.front()));\n    data_queue.pop();\n    return res;\n  }\n\n  bool empty() const\n  {\n    std::lock_guard\u003cstd::mutex\u003e lk(mut);\n    return data_queue.empty();\n  }\n};\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240331105808-gx6hvzt","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240331105808-gx6hvzt","updated":"20240331105821"},"Children":[{"Type":"NodeText","Data":"4.2 使用Future"}]},{"ID":"20240331105821-m5ecju2","Type":"NodeParagraph","Properties":{"id":"20240331105821-m5ecju2","updated":"20240425084042"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"C++标准库中有两种future，声明在"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026lt;future\u0026gt;"},{"Type":"NodeText","Data":"​头文件中: unique future("},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::future\u0026lt;\u0026gt;"},{"Type":"NodeText","Data":"​)和shared futures("},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::shared_future\u0026lt;\u0026gt;"},{"Type":"NodeText","Data":"​)，与了"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::unique_ptr"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::shared_ptr"},{"Type":"NodeText","Data":"​非常类似。"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::future"},{"Type":"NodeText","Data":"​只能与指定事件相关联，而"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::shared_future"},{"Type":"NodeText","Data":"​就能关联多个事件。后者的实现中，所有实例会在同时变为就绪状态，并且可以访问与事件相关的数据。这种关联与模板有关，比如"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::unique_ptr"},{"Type":"NodeText","Data":"​ 和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::shared_ptr"},{"Type":"NodeText","Data":"​的模板参数就是相关的数据类型。与数据无关处的，可以使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::future\u0026lt;void\u0026gt;"},{"Type":"NodeText","Data":"​与"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::shared_future\u0026lt;void\u0026gt;"},{"Type":"NodeText","Data":"​的特化模板。"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color6);"},"TextMarkType":"text","TextMarkTextContent":"future对象本身并不提供同步访问。当多个线程需要访问一个独立future对象时，必须使用互斥量或类似同步机制进行保护。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color6);\"}"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"不过，当多个线程对一个"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::shared_future\u0026lt;\u0026gt;"},{"Type":"NodeText","Data":"​副本进行访问，即使同一个异步结果，也不需要同步future。"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::thread"},{"Type":"NodeText","Data":"​ 执行的任务不能有返回值，不过这个问题能使用future进行解决。"}]},{"ID":"20240331110127-ybmadwh","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240331110127-ybmadwh","updated":"20240331110134"},"Children":[{"Type":"NodeText","Data":"4.2.1 后台任务的返回值"}]},{"ID":"20240331110134-p4td6ka","Type":"NodeParagraph","Properties":{"id":"20240331110134-p4td6ka","updated":"20240331110157"},"Children":[{"Type":"NodeText","Data":"假设有一个需要长时间的运算，需要计算出一个有效值，但并不迫切需要这个值。你可以启动新线程来执行这个计算，你需要计算的结果，而"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::thread"},{"Type":"NodeText","Data":"​并不提供直接接收返回值的机制。这里就需要"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::async"},{"Type":"NodeText","Data":"​函数模板。"}]},{"ID":"20240331105956-24l579l","Type":"NodeParagraph","Properties":{"id":"20240331105956-24l579l","updated":"20240331110751"},"Children":[{"Type":"NodeText","Data":"当不着急任务结果时，可以使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::async"},{"Type":"NodeText","Data":"​启动一个异步任务。与"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::thread"},{"Type":"NodeText","Data":"​对象等待的方式不同，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::async"},{"Type":"NodeText","Data":"​会返回一个"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::future"},{"Type":"NodeText","Data":"​对象，这个对象持有最终计算出来的结果。"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color6);"},"TextMarkType":"text","TextMarkTextContent":"当需要这个值时，只需要调用这个对象的get()成员函数，就会阻塞线程直到future为就绪为止，并返回计算结果。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color6);\"}"}]},{"ID":"20240331111621-g2owbzv","Type":"NodeParagraph","Properties":{"id":"20240331111621-g2owbzv","updated":"20240331111621"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"与"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::thread"},{"Type":"NodeText","Data":"​方式一样，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::async"},{"Type":"NodeText","Data":"​允许通过添加额外的调用参数，向函数传递额外的参数。第一个参数是指向成员函数的指针，第二个参数提供这个函数成员类的具体对象(是通过指针，也可以包装在"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::ref"},{"Type":"NodeText","Data":"​中)，剩余的参数可作为函数的参数传入。否则，第二个和随后的参数将作为函数的参数，或作为指定可调用对象的第一个参数。和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::thread"},{"Type":"NodeText","Data":"​一样，当参数为右值时，拷贝操作将使用移动的方式转移原始数据，就可以使用“只移动”类型作为函数对象和参数。"}]},{"ID":"20240331111623-v9wfqvb","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240331111623-v9wfqvb","updated":"20240331111629"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"#include \u003cstring\u003e\n#include \u003cfuture\u003e\nstruct X\n{\n  void foo(int,std::string const\u0026);\n  std::string bar(std::string const\u0026);\n};\nX x;\nauto f1=std::async(\u0026X::foo,\u0026x,42,\"hello\");  // 调用p-\u003efoo(42, \"hello\")，p是指向x的指针\nauto f2=std::async(\u0026X::bar,x,\"goodbye\");  // 调用tmpx.bar(\"goodbye\")， tmpx是x的拷贝副本\nstruct Y\n{\n  double operator()(double);\n};\nY y;\nauto f3=std::async(Y(),3.141);  // 调用tmpy(3.141)，tmpy通过Y的移动构造函数得到\nauto f4=std::async(std::ref(y),2.718);  // 调用y(2.718)\nX baz(X\u0026);\nstd::async(baz,std::ref(x));  // 调用baz(x)\nclass move_only\n{\npublic:\n  move_only();\n  move_only(move_only\u0026\u0026)\n  move_only(move_only const\u0026) = delete;\n  move_only\u0026 operator=(move_only\u0026\u0026);\n  move_only\u0026 operator=(move_only const\u0026) = delete;\n  \n  void operator()();\n};\nauto f5=std::async(move_only());  // 调用tmp()，tmp是通过std::move(move_only())构造得到\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240331111812-m5ztgyc","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240331111812-m5ztgyc","updated":"20240331111822"},"Children":[{"Type":"NodeText","Data":"4.2.2 future与任务关联"}]},{"ID":"20240331111822-oqol742","Type":"NodeParagraph","Properties":{"id":"20240331111822-oqol742","updated":"20240331111842"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::packaged_task\u0026lt;\u0026gt;"},{"Type":"NodeText","Data":"​会将future与函数或可调用对象进行绑定。当调用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::packaged_task\u0026lt;\u0026gt;"},{"Type":"NodeText","Data":"​对象时，就会调用相关函数或可调用对象，当future状态为就绪时，会存储返回值。"}]},{"ID":"20240331111902-910zvr8","Type":"NodeParagraph","Properties":{"id":"20240331111902-910zvr8","updated":"20240331111922"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::packaged_task\u0026lt;\u0026gt;"},{"Type":"NodeText","Data":"​的模板参数是一个函数签名,"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"构造"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::packaged_task\u0026lt;\u0026gt;"},{"Type":"NodeText","Data":"​实例时，就必须传入函数或可调用对象。这个函数或可调用的对象，需要能接收指定的参数和返回(可转换为指定返回类型的)值。"}]},{"ID":"20240331112002-5m7179x","Type":"NodeParagraph","Properties":{"id":"20240331112002-5m7179x","updated":"20240331112009"},"Children":[{"Type":"NodeText","Data":"函数签名的返回类型可以用来标识从get_future()返回的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::future\u0026lt;\u0026gt;"},{"Type":"NodeText","Data":"​的类型，而函数签名的参数列表，可用来指定packaged_task的函数调用操作符。"}]},{"ID":"20240331112006-s6mkis6","Type":"NodeParagraph","Properties":{"id":"20240331112006-s6mkis6","updated":"20240331112051"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::packaged_task"},{"Type":"NodeText","Data":"​是个可调用对象，可以"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color6);"},"TextMarkType":"text","TextMarkTextContent":"封装在"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color6);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color6);"},"TextMarkType":"code text","TextMarkTextContent":"std::function"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color6);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color6);"},"TextMarkType":"text","TextMarkTextContent":"对象中，从而作为线程函数传递到"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color6);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color6);"},"TextMarkType":"code text","TextMarkTextContent":"std::thread"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color6);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color6);"},"TextMarkType":"text","TextMarkTextContent":"对象中"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color6);\"}"},{"Type":"NodeText","Data":"，或作为可调用对象传递到另一个函数中或直接调用。当"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::packaged_task"},{"Type":"NodeText","Data":"​作为函数调用时，实参将由函数调用操作符传递至底层函数，并且返回值作为异步结果存储在"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::future"},{"Type":"NodeText","Data":"​中，并且可通过get_future()获取。因此可以用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::packaged_task"},{"Type":"NodeText","Data":"​对任务进行打包，并适时的取回future。当异步任务需要返回值时，可以等待future状态变为“就绪”。"}]},{"ID":"20240331112128-god0mm0","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240331112128-god0mm0","updated":"20240331112148"},"Children":[{"Type":"NodeText","Data":"4.2.2.1 线程间传递任务"}]},{"ID":"20240331112148-q485alh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240331112148-q485alh","updated":"20240331112213"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"#include \u003cdeque\u003e\n#include \u003cmutex\u003e\n#include \u003cfuture\u003e\n#include \u003cthread\u003e\n#include \u003cutility\u003e\n\nstd::mutex m;\nstd::deque\u003cstd::packaged_task\u003cvoid()\u003e \u003e tasks;\n\nbool gui_shutdown_message_received();\nvoid get_and_process_gui_message();\n\nvoid gui_thread()  // 1\n{\n  while(!gui_shutdown_message_received())  // 2\n  {\n    get_and_process_gui_message();  // 3\n    std::packaged_task\u003cvoid()\u003e task;\n    {\n      std::lock_guard\u003cstd::mutex\u003e lk(m);\n      if(tasks.empty())  // 4\n        continue;\n      task=std::move(tasks.front());  // 5\n      tasks.pop_front();\n    }\n    task();  // 6\n  }\n}\n\nstd::thread gui_bg_thread(gui_thread);\n\ntemplate\u003ctypename Func\u003e\nstd::future\u003cvoid\u003e post_task_for_gui_thread(Func f)\n{\n  std::packaged_task\u003cvoid()\u003e task(f);  // 7\n  std::future\u003cvoid\u003e res=task.get_future();  // 8\n  std::lock_guard\u003cstd::mutex\u003e lk(m);\n  tasks.push_back(std::move(task));  // 9\n  return res; // 10\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240401093124-2p3htax","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240401093124-2p3htax","updated":"20240401093133"},"Children":[{"Type":"NodeText","Data":"4.2.3 使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::promise"},{"Type":"NodeText","Data":"​"}]},{"ID":"20240401093134-mg1qhpo","Type":"NodeParagraph","Properties":{"id":"20240401093134-mg1qhpo","updated":"20240425091109"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::promise\u0026lt;T\u0026gt;"},{"Type":"NodeText","Data":"​提供设定值的方式(类型为T)，这个类型会和后面看到的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::future\u0026lt;T\u0026gt;"},{"Type":"NodeText","Data":"​对象相关联。"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::promise/std::future"},{"Type":"NodeText","Data":"​对提供一种机制："},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"future可以阻塞等待线程，提供数据的线程可以使用promise对相关值进行设置，并将future的状态置为“就绪”。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"}]},{"ID":"20240425091109-4ahy41y","Type":"NodeParagraph","Properties":{"id":"20240425091109-4ahy41y","updated":"20240425103028"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"可以通过给定的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::promise"},{"Type":"NodeText","Data":"​的get_future()成员函数来获取与之相关的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::future"},{"Type":"NodeText","Data":"​对象，与"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::packaged_task"},{"Type":"NodeText","Data":"​的用法类似。当promise设置完毕(使用set_value()成员函数)时，对应的future状态就变为“就绪”，并且可用于检索已存储的值。当设置值之前销毁"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::promise"},{"Type":"NodeText","Data":"​，将会存储一个异常。"}]},{"ID":"20240425103230-nfwod53","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240425103230-nfwod53","updated":"20240425103345"},"Children":[{"Type":"NodeText","Data":"4.2.4 将异常存储于future中"}]},{"ID":"20240425103345-7ghliqp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240425103345-7ghliqp","updated":"20240425103636"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"double square_root(double x)\n{\n    if (x \u003c 0) {\n        throw std::out_of_range(\"x\u003c0\");\n    }\n    return std::sqrt(x);\n}\n\nint main()\n{\n    auto value = std::async(square_root, -1);\n    value.get(); // 调用这行才能看到异常\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240425103637-j5ejejt","Type":"NodeParagraph","Properties":{"id":"20240425103637-j5ejejt","updated":"20240425103720"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"函数作为"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::async"},{"Type":"NodeText","Data":"​的一部分时，当调用抛出一个异常时，这个异常就会存储到future中，之后future的状态置为“就绪”，之后调用get()会抛出已存储的异常"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"(注意：标准级别没有指定重新抛出的这个异常是原始的异常对象，还是一个拷贝。不同的编译器和库将会在这方面做出不同的选择)"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。将函数打包入"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::packaged_task"},{"Type":"NodeText","Data":"​任务包后，当任务调用时，同样的事情也会发生。打包函数抛出一个异常，这个异常将存储在future中，在get()调用时会再次抛出。"}]},{"ID":"20240425103742-0d66as6","Type":"NodeParagraph","Properties":{"id":"20240425103742-0d66as6","updated":"20240425103759"},"Children":[{"Type":"NodeText","Data":"下面是显式设置异常的方式，使用set_exception。"}]},{"ID":"20240425104248-in2r7qx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240425104248-in2r7qx","updated":"20240425104303"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"extern std::promise\u003cdouble\u003e some_promise;\ntry\n{\n  some_promise.set_value(calculate_value());\n}\ncatch(...)\n{\n  some_promise.set_exception(std::current_exception());\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240425104304-req805k","Type":"NodeParagraph","Properties":{"id":"20240425104304-req805k","updated":"20240425104413"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"可用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::copy_exception()"},{"Type":"NodeText","Data":"​作为替代方案，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::copy_exception()"},{"Type":"NodeText","Data":"​会直接存储新的异常而不抛出："}]},{"ID":"20240425105038-mzasb4x","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240425105038-mzasb4x","updated":"20240425105052"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"void A(double a)\n{\n    if (a \u003c 0) {\n        p.set_exception(std::make_exception_ptr(std::logic_error(\"error\")));\n    } else {\n        p.set_value(a);\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240425105052-dgkekv1","Type":"NodeParagraph","Properties":{"id":"20240425105052-dgkekv1","updated":"20240425105103"},"Children":[{"Type":"NodeText","Data":"这比使用try/catch块更加清晰，当异常类型已知，就应该优先使用。"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"不是因为代码实现简单，而是给编译器提供了极大的优化空间。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"}]},{"ID":"20240425105058-g6zvf5t","Type":"NodeParagraph","Properties":{"id":"20240425105058-g6zvf5t","updated":"20240425105244"},"Children":[{"Type":"NodeText","Data":"另一种向future中存储异常的方式，在没有调用promise上的任何设置函数前，或正在调用包装好的任务时，销毁与"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::promise"},{"Type":"NodeText","Data":"​或"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::packaged_task"},{"Type":"NodeText","Data":"​相关的future对象。"}]},{"ID":"20240425105248-rae0uij","Type":"NodeParagraph","Properties":{"id":"20240425105248-rae0uij","updated":"20240425105248"},"Children":[{"Type":"NodeText","Data":"任何情况下，当future的状态还不是“就绪”时，调用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::promise"},{"Type":"NodeText","Data":"​或"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::packaged_task"},{"Type":"NodeText","Data":"​的析构函数，将会存储一个与"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::future_errc::broken_promise"},{"Type":"NodeText","Data":"​错误状态相关的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::future_error"},{"Type":"NodeText","Data":"​异常。通过创建一个future，可以构造一个promise为其提供值或异常，也可以通过销毁值和异常源，去违背promise。这种情况下，编译器没有在future中存储任何东西，线程可能会永远的等下去。"}]},{"ID":"20240425105245-kvn1aun","Type":"NodeParagraph","Properties":{"id":"20240425105245-kvn1aun","updated":"20240425105346"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::future"},{"Type":"NodeText","Data":"​在多线程等待时只有一个线程能获取结果，当多个线程等待相同事件时就需要使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::shared_future"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20240425105346-frpl6ai","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240425105346-frpl6ai","updated":"20240425105353"},"Children":[{"Type":"NodeText","Data":"4.2.5 多个线程的等待"}]},{"ID":"20240425105353-6li7762","Type":"NodeBlockquote","Properties":{"id":"20240425105353-6li7762","updated":"20240425105458"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240425105455-91cng9x","Type":"NodeParagraph","Properties":{"id":"20240425105455-91cng9x","updated":"20240425105458"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"虽然"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::future"},{"Type":"NodeText","Data":"​可以处理所有在线程间数据转移的同步，但是调用某一特殊"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::future"},{"Type":"NodeText","Data":"​对象的成员函数，就会让这个线程的数据和其他线程的数据不同步。多线程在没有额外同步的情况下，访问独立"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::future"},{"Type":"NodeText","Data":"​对象时，就会有数据竞争和未定义行为。因为"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::future"},{"Type":"NodeText","Data":"​独享同步结果，并且通过调用get()函数，一次性的获取数据，这就让并发访问变的毫无意义。"}]}]},{"ID":"20240425105458-oj9drej","Type":"NodeParagraph","Properties":{"id":"20240425105458-oj9drej","updated":"20240425105511"},"Children":[{"Type":"NodeText","Data":"如果并行代码没办法让多个线程等待同一个事件，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::shared_future"},{"Type":"NodeText","Data":"​可以帮你解决这个问题。"}]},{"ID":"20240425105512-66cu5wz","Type":"NodeParagraph","Properties":{"id":"20240425105512-66cu5wz","updated":"20240425105516"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::shared_future"},{"Type":"NodeText","Data":"​实例是可拷贝的，所以多个对象可以引用同一关联期望值的结果。"}]},{"ID":"20240425105517-le0q44f","Type":"NodeParagraph","Properties":{"id":"20240425105517-le0q44f","updated":"20240425105525"},"Children":[{"Type":"NodeText","Data":"每一个"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::shared_future"},{"Type":"NodeText","Data":"​的独立对象上，成员函数调用返回的结果还是不同步的，所以为了在多个线程访问一个独立对象时避免数据竞争，必须使用锁来对访问进行保护。"}]},{"ID":"20240425105527-3zjs38w","Type":"NodeParagraph","Properties":{"id":"20240425105527-3zjs38w","updated":"20240425105554"},"Children":[{"Type":"NodeText","Data":"优先使用的方法是：为了替代只有一个拷贝对象的情况，可以让每个线程都拥有自己对应的拷贝对象。这样，当每个线程都通过自己拥有的"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::shared_future"},{"Type":"NodeText","Data":"​对象获取结果，那么多个线程访问共享同步结果就是安全的。如下图"}]},{"ID":"20240425105600-c3v0kfs","Type":"NodeParagraph","Properties":{"id":"20240425105600-c3v0kfs","updated":"20240425105602"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240425105600-4ddc07p.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240425105611-u5bylfb","Type":"NodeParagraph","Properties":{"id":"20240425105611-u5bylfb","updated":"20240425105613"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240425105611-w1wuhoy.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240425105639-noxvva3","Type":"NodeBlockquote","Properties":{"id":"20240425105639-noxvva3","updated":"20240425105653"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240425105648-jl3n0lu","Type":"NodeParagraph","Properties":{"id":"20240425105648-jl3n0lu","updated":"20240425105653"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"可能会使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::shared_future"},{"Type":"NodeText","Data":"​的场景，例如：实现类似于复杂的电子表格的并行执行，每一个单元格有唯一终值，这个终值可能由其他单元格中的数据通过公式计算得到。公式计算得到的结果依赖于其他单元格，然后可以使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::shared_future"},{"Type":"NodeText","Data":"​对象引用第一个单元格的数据。当每个单元格内的所有公式并行执行后，任务会以期望的方式完成工作。不过，当其中有计算需要依赖其他单元格的值时就会阻塞，直到依赖单元格的数据准备就绪。这可以让系统在最大程度上使用硬件并发。"}]}]},{"ID":"20240425110156-jdpxiwp","Type":"NodeParagraph","Properties":{"id":"20240425110156-jdpxiwp","updated":"20240425110203"},"Children":[{"Type":"NodeText","Data":"下面是一个例子"}]},{"ID":"20240425110203-zh5ug82","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240425110203-zh5ug82","updated":"20240425110728"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"std::promise\u003cdouble\u003e p;\nauto gsf = p.get_future().share();\n\nvoid SetPValue(double a)\n{\n    if (a \u003c 0) {\n        p.set_exception(std::make_exception_ptr(std::logic_error(\"error\")));\n    } else {\n        p.set_value(a);\n    }\n}\n\nvoid ThreadAExecute() {\n    auto sf = gsf;\n    std::this_thread::sleep_for(5s);\n    SetPValue(12);\n    std::cout \u003c\u003c sf.get() \u003c\u003c std::endl;\n}\n\nvoid ThreadBExecute() {\n    auto sf = gsf;\n    std::cout \u003c\u003c sf.get() + 5 \u003c\u003c std::endl;\n}\n\nint main()\n{\n    std::thread t1(ThreadAExecute);\n    std::thread t2(ThreadBExecute);\n    t1.join();\n    t2.join();\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240425110730-6sduy76","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240425110730-6sduy76","updated":"20240425110752"},"Children":[{"Type":"NodeText","Data":"4.3 限时等待"}]},{"ID":"20240425110812-wtirl35","Type":"NodeParagraph","Properties":{"id":"20240425110812-wtirl35","updated":"20240425110924"},"Children":[{"Type":"NodeText","Data":"使用超时的最简单方式，就是对特定线程添加延迟处理。当线程无所事事时，就不会占用其他线程的处理时间。"}]},{"ID":"20240425113525-81r7s13","Type":"NodeParagraph","Properties":{"id":"20240425113525-81r7s13","updated":"20240425113633"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"表4.1 可接受超时的函数"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240425113633-f5jik0l.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240425113634-xjin59a","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240425113634-xjin59a","updated":"20240429094955"},"Children":[{"Type":"NodeText","Data":"4.4 简化代码"}]},{"ID":"20240429094955-1wbjios","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240429094955-1wbjios","updated":"20240429094955"},"Children":[{"Type":"NodeText","Data":"4.4.1 使用future的函数化编程"}]},{"ID":"20240429095040-oixa0et","Type":"NodeParagraph","Properties":{"id":"20240429095040-oixa0et","updated":"20240429094955"},"Children":[{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":"函数化编程"},{"Type":"NodeText","Data":"(functional programming)是一种编程方式，函数结果只依赖于传入函数的参数。使用相同的参数调用函数，不管多少次都会获得相同的结果。"}]},{"ID":"20240429095307-lfvg5xr","Type":"NodeParagraph","Properties":{"id":"20240429095307-lfvg5xr","updated":"20240429095342"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color8);"},"TextMarkType":"strong text","TextMarkTextContent":"快速排序--FP版"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color8);\"}"},{"Type":"NodeText","Data":"​"}]},{"ID":"20240429095343-68868qg","Type":"NodeParagraph","Properties":{"id":"20240429095343-68868qg","updated":"20240429095403"},"Children":[{"Type":"NodeText","Data":"下面是快排的过程："}]},{"ID":"20240429095407-2rgsyg0","Type":"NodeParagraph","Properties":{"id":"20240429095407-2rgsyg0","updated":"20240429095408"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240429095407-6t971r0.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240429095411-nkj5jwn","Type":"NodeParagraph","Properties":{"id":"20240429095411-nkj5jwn","updated":"20240429095427"},"Children":[{"Type":"NodeText","Data":"串行版实现如下："}]},{"ID":"20240429095427-7y9y2pn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240429095427-7y9y2pn","updated":"20240429100854"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"template \u003ctypename T\u003e\nstd::list\u003cT\u003e SequentialQuickSort(std::list\u003cT\u003e input)\n{\n    if (input.empty())\n        return input;\n    std::list\u003cT\u003e Result;\n    Result.splice(Result.begin(), input, input.begin());\n    const T\u0026 Pivot = *Result.begin();\n    auto DividePoint = std::partition(input.begin(), input.end(), [\u0026](const T\u0026 t) { return t \u003c Pivot; });\n    std::list\u003cint\u003e LowerPart;\n    LowerPart.splice(LowerPart.end(), input, input.begin(), DividePoint);\n\n    auto NewLower = SequentialQuickSort(LowerPart);\n    auto NewHigher = SequentialQuickSort(input);\n\n    Result.splice(Result.end(), NewHigher);\n    Result.splice(Result.begin(), NewLower);\n    return Result;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240429100856-xwhcs24","Type":"NodeParagraph","Properties":{"id":"20240429100856-xwhcs24","updated":"20240429101000"},"Children":[{"Type":"NodeText","Data":"下面是FP模式线程强化版本实现（并行版本）。"}]},{"ID":"20240429101001-u16cx0k","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240429101001-u16cx0k","updated":"20240429101512"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"template \u003ctypename T\u003e\nstd::list\u003cT\u003e ParallelQuickSort(std::list\u003cT\u003e input)\n{\n    if (input.empty())\n        return input;\n    std::list\u003cT\u003e Result;\n    Result.splice(Result.begin(), input, input.begin());\n    const T\u0026 Pivot = *Result.begin();\n    auto DividePoint = std::partition(input.begin(), input.end(), [\u0026](const T\u0026 t) { return t \u003c Pivot; });\n    std::list\u003cint\u003e LowerPart;\n    LowerPart.splice(LowerPart.end(), input, input.begin(), DividePoint);\n\n\t// ①\n    std::future\u003cstd::list\u003cT\u003e\u003e NewLower = std::async(\u0026ParallelQuickSort\u003cT\u003e, std::move(LowerPart));\n    // ②\n\tauto NewHigher = ParallelQuickSort(std::move(input));\n\n    Result.splice(Result.end(), NewHigher);\n    Result.splice(Result.begin(), NewLower.get());\n    return Result;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240429101516-b38xsha","Type":"NodeList","ListData":{},"Properties":{"id":"20240429101516-b38xsha","updated":"20240429101623"},"Children":[{"ID":"20240429101518-c9n56eb","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429101518-c9n56eb","updated":"20240429101518"},"Children":[{"ID":"20240429101518-pu0tylv","Type":"NodeParagraph","Properties":{"id":"20240429101518-pu0tylv","updated":"20240429101545"},"Children":[{"Type":"NodeText","Data":"①当前线程不对小于中间值部分排序，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::async"},{"Type":"NodeText","Data":"​使用另一线程排序"}]}]},{"ID":"20240429101614-ehzkoi7","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429101614-ehzkoi7","updated":"20240429101623"},"Children":[{"ID":"20240429101614-9xnbo4m","Type":"NodeParagraph","Properties":{"id":"20240429101614-9xnbo4m","updated":"20240429101623"},"Children":[{"Type":"NodeText","Data":"②当前线程排序"}]}]}]},{"ID":"20240429101626-owk9u84","Type":"NodeParagraph","Properties":{"id":"20240429101626-owk9u84","updated":"20240429101712"},"Children":[{"Type":"NodeText","Data":"当递归十次(对于大约有1000个元素的列表)，如果硬件能处理这十次递归调用，将会创建1024个执行线程。这太多了。可以写一个"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"spawn_task"},{"Type":"NodeText","Data":"​对"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::packaged_task"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::thread"},{"Type":"NodeText","Data":"​进行一下包装。"}]},{"ID":"20240429103727-o0i5t7n","Type":"NodeParagraph","Properties":{"id":"20240429103727-o0i5t7n","updated":"20240429103733"},"Children":[{"Type":"NodeText","Data":"下面是一个SpawnTask的简单实现"}]},{"ID":"20240429101713-okao6ju","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240429101713-okao6ju","updated":"20240429103736"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"template\u003ctypename F,typename A\u003e\nstd::future\u003cstd::result_of\u003cF(A\u0026\u0026)\u003e::type\u003e\n   spawn_task(F\u0026\u0026 f,A\u0026\u0026 a)\n{\n  typedef std::result_of\u003cF(A\u0026\u0026)\u003e::type result_type;\n  std::packaged_task\u003cresult_type(A\u0026\u0026)\u003e\n       task(std::move(f)));\n  std::future\u003cresult_type\u003e res(task.get_future());\n  std::thread t(std::move(task),std::move(a));\n  t.detach();\n  return res;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240429101639-2smiu36","Type":"NodeParagraph","Properties":{"id":"20240429101639-2smiu36","updated":"20240429103815"},"Children":[{"Type":"NodeText","Data":"这里的实现并没有太多优势，但是可以为转型为一个更复杂的视线做铺垫（向队列添加任务，线程池）。"}]},{"ID":"20240429104859-dmooykf","Type":"NodeParagraph","Properties":{"id":"20240429104859-dmooykf","updated":"20240429104859"},"Children":[{"Type":"NodeText","Data":"函数化编程可算作是并发编程的范型，并且也是"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color4);"},"TextMarkType":"text","TextMarkTextContent":"通讯顺序进程"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color4);\"}"},{"Type":"NodeText","Data":"(CSP，Communicating Sequential Processer[3])的范型，这里的"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color4);"},"TextMarkType":"text","TextMarkTextContent":"线程没有共享数据，但有通讯通道允许信息在不同线程间进行传递"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color4);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240429104638-dx1ntax","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240429104638-dx1ntax","updated":"20240429104654"},"Children":[{"Type":"NodeText","Data":"4.4.2 使用消息传递的同步操作"}]},{"ID":"20240429104803-1rejlkn","Type":"NodeParagraph","Properties":{"id":"20240429104803-1rejlkn","updated":"20240429104938"},"Children":[{"Type":"NodeText","Data":"CSP的概念很简单："},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color4);"},"TextMarkType":"text","TextMarkTextContent":"没有共享数据时，每个线程可以基于所接收到的信息独立运行。每个线程就都有状态机：当收到一条信息，会以某种方式更新状态，并且可能向其他线程发出信息(消息处理机制依赖于线程的初始化状态)"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color4);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240429104938-zpv6mvd","Type":"NodeParagraph","Properties":{"id":"20240429104938-zpv6mvd","updated":"20240429105015"},"Children":[{"Type":"NodeText","Data":"试想有一天要为实现ATM(自动取款机)写一个应用。这个应用需要处理：取钱时和银行之间的交互情况，以及控制器械接受用户的卡片，显示适当的信息，处理按钮事件，吐出现金，还有退还卡。"}]},{"ID":"20240429105018-s8qwtf6","Type":"NodeList","ListData":{},"Properties":{"id":"20240429105018-s8qwtf6","updated":"20240429105100"},"Children":[{"ID":"20240429105018-nq9dbat","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429105018-nq9dbat","updated":"20240429105100"},"Children":[{"ID":"20240429105018-zojmz4r","Type":"NodeParagraph","Properties":{"id":"20240429105018-zojmz4r","updated":"20240429105025"},"Children":[{"Type":"NodeText","Data":"一种处理方法是让代码将所有事情分配到三个独立线程上去：一个线程去处理物理机械，一个去处理ATM机的逻辑，还有一个用来与银行通讯，这些线程不共享任何数据"}]},{"ID":"20240429105059-2kx4653","Type":"NodeParagraph","Properties":{"id":"20240429105059-2kx4653","updated":"20240429105100"},"Children":[{"Type":"NodeText","Data":"比如：当有人在ATM机上插入了卡片或者按下按钮，处理机械的线程将会发送一条信息到逻辑线程上，并且逻辑线程将发送一条消息到机械线程，告诉机械线程可以分配多少钱等等。"}]}]}]},{"ID":"20240429105105-7ytbkem","Type":"NodeParagraph","Properties":{"id":"20240429105105-7ytbkem","updated":"20240429105115"},"Children":[{"Type":"NodeText","Data":"这可以当做是一种状态机，如下："}]},{"ID":"20240429105118-3ac5niq","Type":"NodeParagraph","Properties":{"id":"20240429105118-3ac5niq","updated":"20240429105121"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240429105118-x2moldg.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240429105122-s97kga5","Type":"NodeParagraph","Properties":{"id":"20240429105122-s97kga5","updated":"20240429105415"},"Children":[{"Type":"NodeText","Data":"逻辑类是简单实现如下："}]},{"ID":"20240429105415-tklk5t2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240429105415-tklk5t2","updated":"20240429105420"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"struct card_inserted\n{\n  std::string account;\n};\n\nclass atm\n{\n  messaging::receiver incoming;\n  messaging::sender bank;\n  messaging::sender interface_hardware;\n  void (atm::*state)();\n\n  std::string account;\n  std::string pin;\n\n  void waiting_for_card()  // 1\n  {\n    interface_hardware.send(display_enter_card());  // 2\n    incoming.wait().  // 3\n      handle\u003ccard_inserted\u003e(\n      [\u0026](card_inserted const\u0026 msg)  // 4\n      {\n       account=msg.account;\n       pin=\"\";\n       interface_hardware.send(display_enter_pin());\n       state=\u0026atm::getting_pin;\n      }\n    );\n  }\n  void getting_pin();\npublic:\n  void run()  // 5\n  {\n    state=\u0026atm::waiting_for_card;  // 6\n    try\n    {\n      for(;;)\n      {\n        (this-\u003e*state)();  // 7\n      }\n    }\n    catch(messaging::close_queue const\u0026)\n    {\n    }\n  }\n};\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240429105530-50kg99r","Type":"NodeParagraph","Properties":{"id":"20240429105530-50kg99r","updated":"20240429105536"},"Children":[{"Type":"NodeText","Data":"这里无需考虑同步和并发问题，只需要考虑什么时候接收和发送信息即可。"}]},{"ID":"20240429105534-okzb1cq","Type":"NodeParagraph","Properties":{"id":"20240429105534-okzb1cq","updated":"20240429105729"},"Children":[{"Type":"NodeText","Data":"完整代码可见"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"assets/C.0-chinese-20240429105729-s5ieyyx.md","TextMarkTextContent":"C.0-chinese.md"}]},{"ID":"20240429105900-2e3oxur","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240429105900-2e3oxur","updated":"20240429105917"},"Children":[{"Type":"NodeText","Data":"4.4.3 扩展规范中的持续性并发"}]},{"ID":"20240429105918-yhmkfwg","Type":"NodeParagraph","Properties":{"id":"20240429105918-yhmkfwg","updated":"20240429105947"},"Children":[{"Type":"NodeText","Data":"假设任务产生了一个结果，并且future持有这个结果。然后，需要写一些代码来处理这个结果。使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::future"},{"Type":"NodeText","Data":"​时，必须等待future的状态变为就绪态，不然就使用全阻塞函数wait()，或是使用wait_for()/wait_unitl()成员函数进行等待，而这会让代码变得非常复杂。用一句话来说“完事俱备，只等数据”，这也就是持续性的意义。为了给future添加持续性，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"只需要在成员函数后添加then()即可。比如：给定一个future fut，添加持续性的调用即为fut.then(continuation)"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240429105947-n03pi82","Type":"NodeParagraph","Properties":{"id":"20240429105947-n03pi82","updated":"20240429110026"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"与"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::future"},{"Type":"NodeText","Data":"​类似 ,  "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::experimental::future"},{"Type":"NodeText","Data":"​的存储值也只能检索一次。如果future处于持续使用状态，其他代码就不能访问这个furture。因此，使用fut.then()为fut添加持续性后，对原始fut的操作就是非法的。另外，调用fut.then()会返回一个新future，这个新future会持有持续性调用的结果。如下："}]},{"ID":"20240429110026-ahhfsbq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240429110026-ahhfsbq","updated":"20240429110031"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"std::experimental::future\u003cint\u003e find_the_answer;\nauto fut=find_the_answer();\nauto fut2=fut.then(find_the_question);\nassert(!fut.valid());\nassert(fut2.valid());\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240429110032-y02780j","Type":"NodeParagraph","Properties":{"id":"20240429110032-y02780j","updated":"20240429110122"},"Children":[{"Type":"NodeText","Data":"与直接调用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::async"},{"Type":"NodeText","Data":"​或"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::thread"},{"Type":"NodeText","Data":"​不同，持续性函数不需要传入参数，因为运行库已经为其定义好了参数——会传入处于就绪态的future，这个future保存了持续性触发后的结果。如下："}]},{"ID":"20240429110122-64etztq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240429110122-64etztq","updated":"20240429110128"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"std::string find_the_question(std::experimental::future\u003cint\u003e the_answer);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240429110129-kbux5nw","Type":"NodeParagraph","Properties":{"id":"20240429110129-kbux5nw","updated":"20240429110156"},"Children":[{"Type":"NodeText","Data":"这里参数是future而不是int，因为持续性的过程中可能会持有异常。"}]},{"ID":"20240429110543-c0x1b8o","Type":"NodeParagraph","Properties":{"id":"20240429110543-c0x1b8o","updated":"20240429110609"},"Children":[{"Type":"NodeText","Data":"这是一个扩展，目前（2024年4月29日11:06:00）还处于Experimental命名空间。"}]},{"ID":"20240429110610-hd1362v","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240429110610-hd1362v","updated":"20240429111215"},"Children":[{"Type":"NodeText","Data":"4.4.4 持续性连接"}]},{"ID":"20240429111138-yrj9hmy","Type":"NodeParagraph","Properties":{"id":"20240429111138-yrj9hmy","updated":"20240429111215"},"Children":[{"Type":"NodeText","Data":"假设有一些列耗时任务要完成，并且要使用异步多线程完成这些任务，从而减轻主线程的计算压力，例如：用户登录应用时，需要将登录凭证发送给后台，在对身份信息进行验证后，从后台获取用户的账户信息，使用获取到的信息对显示进行更新。"}]},{"ID":"20240429111144-eumg1gl","Type":"NodeParagraph","Properties":{"id":"20240429111144-eumg1gl","updated":"20240429111215"},"Children":[{"Type":"NodeText","Data":"下面是同步方式代码："}]},{"ID":"20240429111150-6u1ascr","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240429111150-6u1ascr","updated":"20240429111215"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"void process_login(std::string const\u0026 username, std::string const\u0026 password)\n{\n  try{\n    user_id const id = backend.authenticate_user(username, password);\n    user_data const info_to_display = backend.request_current_info(id);\n    update_display(info_to_display);\n  } catch(std::exception\u0026 e){\n    display_error(e);\n  }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240429111155-6lmkoem","Type":"NodeParagraph","Properties":{"id":"20240429111155-6lmkoem","updated":"20240429111438"},"Children":[{"Type":"NodeText","Data":"这会阻塞UI线程，下面是异步方式："}]},{"ID":"20240429111204-85lc3jc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240429111204-85lc3jc","updated":"20240429111215"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"std::future\u003cvoid\u003e process_login(\n  std::string const\u0026 username, std::string const\u0026 password)\n{\n  return std::async(std::launch::async,[=](){\n    try{\n      user_id consst id = backend.authenticate_user(username, password);\n      user_data const info_to_display = \n        backend.request_current_info(id);\n      update_display(info_to_display);\n    } catch(std::exception\u0026 e){\n      display_error(e);\n    }    \n  });\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240429111514-t15b89k","Type":"NodeParagraph","Properties":{"id":"20240429111514-t15b89k","updated":"20240429111629"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"为了避免线程阻塞，机制需要对每个完成的任务进行连接：持续性。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"下面的代码与之前大体相同，但这次将整个任务分成了一系列任务，并且每个任务在完成时回连到前一个任务上。"}]},{"ID":"20240429111651-mwsh7ux","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240429111651-mwsh7ux","updated":"20240429111710"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"std::experimental::future\u003cvoid\u003e process_login(\n  std::string const\u0026 username, std::string const\u0026 password)\n{\n  return spawn_async([=](){\n    return backend.authenticate_user(username, password);  \n  }).then([](std::experimental::future\u003cuser_id\u003e id){\n    return backend.request_current_info(id.get());\n  }).then([](std::experimental::future\u003cuser_data\u003e info_to_display){\n    try{\n      update_display(info_to_display.get());\n    } catch(std::exception\u0026 e){\n      display_error(e);\n    }\n  });\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240429112015-uu73sbn","Type":"NodeBlockquote","Properties":{"id":"20240429112015-uu73sbn","updated":"20240429112016"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240429112016-ejaambf","Type":"NodeParagraph","Properties":{"id":"20240429112016-ejaambf","updated":"20240429112016"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"每个持续性函数都以"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::experimental::future"},{"Type":"NodeText","Data":"​作为独立参数，然后使用"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":".get()"},{"Type":"NodeText","Data":"​来获取其拥有的值。这意味着异常会沿着链条进行传播，如果有函数抛出异常，就会在调用info_to_display.get()时抛出，捕获结构可以处理所有的异常类型。"}]}]},{"ID":"20240429111711-lsxhfte","Type":"NodeParagraph","Properties":{"id":"20240429111711-lsxhfte","updated":"20240429111857"},"Children":[{"Type":"NodeText","Data":"因为等待消息需要通过网络或数据操作进行传输，所函数内部会对后端模块进行调用，但这时前端的任务可能还没有完成。虽然已经将任务进行分割成独立的小任务，但仍然会阻塞线程的运行。"}]},{"ID":"20240429112248-nq999gs","Type":"NodeParagraph","Properties":{"id":"20240429112248-nq999gs","updated":"20240429112257"},"Children":[{"Type":"NodeText","Data":"下面是全异步代码："}]},{"ID":"20240429112018-u8w5uws","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240429112018-u8w5uws","updated":"20240429112243"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Qysr"},{"Type":"NodeCodeBlockCode","Data":"std::experimental::future\u003cvoid\u003e process_login(\n  std::string const\u0026 username, std::string const\u0026 password)\n{\n  return backend.async_authenticate_user(username, password).then(\n    [](std::experimental::future\u003cuser_id\u003e id){\n      return backend.async_request_current_info(id.get());    \n    }).then([](std::experimental::future\u003cuser_data\u003e info_to_display){\n      try{\n        update_display(info_to_display.get());  \n      } catch(std::exception\u0026 e){\n        display_error(e);\n      }\n    });\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240429112410-bphn7qk","Type":"NodeParagraph","Properties":{"id":"20240429112410-bphn7qk","updated":"20240429112516"},"Children":[{"Type":"NodeText","Data":"之后讲解的是"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::experimental"},{"Type":"NodeText","Data":"​的东西，比如"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"when_all"},{"Type":"NodeText","Data":"​,"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"when_any"},{"Type":"NodeText","Data":"​,"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"barrier"},{"Type":"NodeText","Data":"​,"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"fence"},{"Type":"NodeText","Data":"​等就不写笔记了，可以直接看"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"assets/4.4-chinese-20240429112516-cyz78i0.md","TextMarkTextContent":"4.4-chinese.md"}]},{"ID":"20240429112517-phboe30","Type":"NodeParagraph","Properties":{"id":"20240429112517-phboe30"}}]}