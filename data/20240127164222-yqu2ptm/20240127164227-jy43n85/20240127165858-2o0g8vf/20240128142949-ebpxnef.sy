{"ID":"20240128142949-ebpxnef","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240128142949-ebpxnef","title":"GamePlay架构（三）WorldContext，GameInstance，Engine","updated":"20240128143407"},"Children":[{"ID":"20240128143128-is2qlnx","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240128143128-is2qlnx","updated":"20240128143128"},"Children":[{"Type":"NodeText","Data":"引言"}]},{"ID":"20240128143128-u5ssmoy","Type":"NodeParagraph","Properties":{"id":"20240128143128-u5ssmoy","updated":"20240128143129"},"Children":[{"Type":"NodeText","Data":"前文提到说一个World管理多个Level，并负责它们的加载释放。那么，问题来了，一个游戏里是只有一个World吗？"}]},{"ID":"20240128143128-lqpef08","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240128143128-lqpef08","updated":"20240128143128"},"Children":[{"Type":"NodeText","Data":"WorldContext"}]},{"ID":"20240128143128-hgrsz9y","Type":"NodeParagraph","Properties":{"id":"20240128143128-hgrsz9y","updated":"20240128143129"},"Children":[{"Type":"NodeText","Data":"答案是否定的，首先World就不是只有一种类型，比如编辑器本身就也是一个World，里面显示的游戏场景也是一个World，这两个World互相协作构成了我们的编辑体验。然后点播放的时候，引擎又可以生成新的类型World来让我们测试。简单来说，UE其实是一个平行宇宙世界观。\n以下是一些世界类型："}]},{"ID":"20240128143128-mdwbcl3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240128143128-mdwbcl3","updated":"20240128143129"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"dGV4dA=="},{"Type":"NodeCodeBlockCode","Data":"namespace EWorldType\n{\n\tenum Type\n\t{\n\t\tNone,\t\t// An untyped world, in most cases this will be the vestigial worlds of streamed in sub-levels\n\t\tGame,\t\t// The game world\n\t\tEditor,\t\t// A world being edited in the editor\n\t\tPIE,\t\t// A Play In Editor world\n\t\tPreview,\t// A preview world for an editor tool\n\t\tInactive\t// An editor world that was loaded but not currently being edited in the level editor\n\t};\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240128143128-vyjar1e","Type":"NodeParagraph","Properties":{"id":"20240128143128-vyjar1e","updated":"20240128143129"},"Children":[{"Type":"NodeText","Data":"而UE用来管理和跟踪这些World的工具就是WorldContext："}]},{"ID":"20240128143128-mm11ysv","Type":"NodeParagraph","Properties":{"id":"20240128143128-mm11ysv","updated":"20240128143347"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://pic4.zhimg.com/80/v2-5ded56be67f4082ee7f77a0c3fa0960f_720w.webp"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240128143128-rz1k5q3","Type":"NodeParagraph","Properties":{"id":"20240128143128-rz1k5q3","updated":"20240128143129"},"Children":[{"Type":"NodeText","Data":"FWorldContext保存着ThisCurrentWorld来指向当前的World。而当需要从一个World切换到另一个World的时候（比如说当点击播放时，就是从Preview切换到PIE），FWorldContext就用来保存切换过程信息和目标World上下文信息。所以一般在切换的时候，比如OpenLevel，也都会需要传FWorldContext的参数。一般就来说，对于独立运行的游戏，WorldContext只有唯一个。而对于编辑器模式，则是一个WorldContext给编辑器，一个WorldContext给PIE（Play In Editor）的World。一般来说我们不需要直接操作到这个类，引擎内部已经处理好各种World的协作。\n不仅如此，同时FWorldContext还保存着World里Level切换的上下文："}]},{"ID":"20240128143128-iv381ee","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240128143128-iv381ee","updated":"20240128143129"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"struct FWorldContext\n{\n    [...]\n\tTEnumAsByte\u003cEWorldType::Type\u003e\tWorldType;\n\n\tFSeamlessTravelHandler SeamlessTravelHandler;\n\n\tFName ContextHandle;\n\n\t/** URL to travel to for pending client connect */\n\tFString TravelURL;\n\n\t/** TravelType for pending client connects */\n\tuint8 TravelType;\n\n\t/** URL the last time we traveled */\n\tUPROPERTY()\n\tstruct FURL LastURL;\n\n\t/** last server we connected to (for \"reconnect\" command) */\n\tUPROPERTY()\n\tstruct FURL LastRemoteURL;\n\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240128143128-qyaa2y3","Type":"NodeParagraph","Properties":{"id":"20240128143128-qyaa2y3","updated":"20240128143129"},"Children":[{"Type":"NodeText","Data":"这里的TravelURL和TravelType就是负责设定下一个Level的目标和转换过程。"}]},{"ID":"20240128143128-bf6afim","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240128143128-bf6afim","updated":"20240128143129"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"dGV4dA=="},{"Type":"NodeCodeBlockCode","Data":"// Traveling from server to server.\nUENUM()\nenum ETravelType\n{\n\t/** Absolute URL. */\n\tTRAVEL_Absolute,\n\t/** Partial (carry name, reset server). */\n\tTRAVEL_Partial,\n\t/** Relative URL. */\n\tTRAVEL_Relative,\n\tTRAVEL_MAX,\n};\n\nvoid UEngine::SetClientTravel( UWorld *InWorld, const TCHAR* NextURL, ETravelType InTravelType )\n{\n\tFWorldContext \u0026Context = GetWorldContextFromWorldChecked(InWorld);\n\t// set TravelURL.  Will be processed safely on the next tick in UGameEngine::Tick().\n\tContext.TravelURL    = NextURL;\n\tContext.TravelType   = InTravelType;\n    [...]\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240128143128-yfxxtpn","Type":"NodeParagraph","Properties":{"id":"20240128143128-yfxxtpn","updated":"20240128143129"},"Children":[{"Type":"NodeText","Data":"粗略的流程是UE在OpenLevel的时候， 先设置当前World的Context上的TravelURL，然后在UEngine::TickWorldTravel的时候判断TravelURL非空来真正执行Level的切换。具体的Level切换详细流程比较复杂，目前先从大局上理解整体结构。总而言之，WorldContext既负责World之间切换的上下文，也负责Level之间切换的操作信息。"}]},{"ID":"20240128143128-5d8n61i","Type":"NodeParagraph","Properties":{"id":"20240128143128-5d8n61i","updated":"20240128143129"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"思考：为何Level的切换信息不放在World里？"},{"Type":"NodeText","Data":"\n因为UE有一个逻辑，一个World只有一个PersistentLevel（见上篇），而当我们OpenLevel一个PersistentLevel的时候，实际上引擎做的是先释放掉当前的World，然后再创建个新的World。所以如果我们把下一个Level的信息放在当前的World中，就不得不在释放当前World前又拷贝回来一遍了。\n而LoadStreamLevel的时候，就只是在当前的World中载入对象了，所以其实就没有这个限制了。"}]},{"ID":"20240128143128-bdkv0ip","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240128143128-bdkv0ip","updated":"20240128143129"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"void UGameplayStatics::LoadStreamLevel(UObject* WorldContextObject, FName LevelName,bool bMakeVisibleAfterLoad,bool bShouldBlockOnLoad,FLatentActionInfo LatentInfo)\n{\n\tif (UWorld* World = GEngine-\u003eGetWorldFromContextObject(WorldContextObject))\n\t{\n\t\tFLatentActionManager\u0026 LatentManager = World-\u003eGetLatentActionManager();\n\t\tif (LatentManager.FindExistingAction\u003cFStreamLevelAction\u003e(LatentInfo.CallbackTarget, LatentInfo.UUID) == nullptr)\n\t\t{\n\t\t\tFStreamLevelAction* NewAction = new FStreamLevelAction(true, LevelName, bMakeVisibleAfterLoad, bShouldBlockOnLoad, LatentInfo, World);\n\t\t\tLatentManager.AddNewAction(LatentInfo.CallbackTarget, LatentInfo.UUID, NewAction);\n\t\t}\n\t}\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240128143128-nnv84n1","Type":"NodeParagraph","Properties":{"id":"20240128143128-nnv84n1","updated":"20240128143129"},"Children":[{"Type":"NodeText","Data":"World-\u003eGetLatentActionManager()其实也算是保存在当前World里了。"}]},{"ID":"20240128143128-xju0dma","Type":"NodeParagraph","Properties":{"id":"20240128143128-xju0dma","updated":"20240128143129"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"思考：为何World和Level的切换要放在下一帧再执行？"},{"Type":"NodeText","Data":"\n首先Level的加载显然是比较慢的，需要载入Map，相应的Mesh，Material……等等。所以这个操作就必须异步化，异步的话其实就剩下两种方式，一种是先记录下来信息之后再执行；一种是命令模式立马往队列里压个命令之后再执行。注意，因为OpenLevel还要相应在主线程生成相应Actor对象，所以有些部分还是要在主线程完成的。这两种模式其实都可以达成需求，前者更加简单明了，后者相对统一。UE也是个进化过来的引擎，也并不是所有的代码都完美无缺。猜想其实也是一开始这么简单就这么做了，后来也没有特别大的改动的动力就一直这样了。引擎最终比的是生产效率的提高，确实也不是代码有多优雅。"}]},{"ID":"20240128143128-yzxr1h6","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240128143128-yzxr1h6","updated":"20240128143128"},"Children":[{"Type":"NodeText","Data":"GameInstance"}]},{"ID":"20240128143128-6wtrg3i","Type":"NodeParagraph","Properties":{"id":"20240128143128-6wtrg3i","updated":"20240128143129"},"Children":[{"Type":"NodeText","Data":"那么这些WorldContexts又是保存在哪里的呢？追根溯源："}]},{"ID":"20240128143128-fz8cbwl","Type":"NodeParagraph","Properties":{"id":"20240128143128-fz8cbwl","updated":"20240128143344"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://pic4.zhimg.com/80/v2-36b45a7b36ac77d978719bc6fe8db17b_720w.webp"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240128143128-h80ngxl","Type":"NodeParagraph","Properties":{"id":"20240128143128-h80ngxl","updated":"20240128143129"},"Children":[{"Type":"NodeText","Data":"GameInstance里会保存着当前的WorldConext和其他整个游戏的信息。明白了GameInstance是比World更高的层次之后，我们也就能明白为何那些独立于Level的逻辑或数据要在GameInstance中存储了。\n这一点其实也很好理解，大凡游戏引擎都会有一个Game的概念，不管是叫Application还是Director，它都是玩家能直接接触到的最根源的操作类。而UE的GameInstance因为继承于UObject，所以就拥有了动态创建的能力，所以我们可以通过指定GameInstanceClass来让UE创建使用我们自定义的GameInstance子类。所以不论是C++还是BP，我们通常会继承于GameInstance，然后在里面编写应用于整个游戏范围的逻辑。\n因为经常有初学者会问到：我的Level切换了，变量数据就丟了，我应该把那些数据放在哪？再清晰直白一点，GameInstance就是你不管Level怎么切换，还是会一直存在的那个对象！"}]},{"ID":"20240128143128-tq1z47x","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240128143128-tq1z47x","updated":"20240128143128"},"Children":[{"Type":"NodeText","Data":"Engine"}]},{"ID":"20240128143128-hwgj6sz","Type":"NodeParagraph","Properties":{"id":"20240128143128-hwgj6sz","updated":"20240128143129"},"Children":[{"Type":"NodeText","Data":"让我们继续再往上，终于得见UE大神："}]},{"ID":"20240128143128-1yis35t","Type":"NodeParagraph","Properties":{"id":"20240128143128-1yis35t","updated":"20240128143340"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"https://pic1.zhimg.com/80/v2-94d1f4e3750b6f4fd09d02b20bc980b0_720w.webp"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240128143128-zieqccw","Type":"NodeParagraph","Properties":{"id":"20240128143128-zieqccw","updated":"20240128143129"},"Children":[{"Type":"NodeText","Data":"此处UEngine分化出了两个子类：UGameEngine和UEditorEngine。众所周知，UE的编辑器也是UE用自己的引擎渲染出来的，采用的也是Slate那套UI框架。好处有很多，比如跨平台比较统一，UI框架可以复用一套控件库，Dogfood等等，此处不再细讲。所以本质上来说，UE的编辑器其实也是个游戏！我们是在编辑器这个游戏里面创造我们自己的另一个游戏。话虽如此，但比较编辑器和游戏还是有一定差别的，所以UE会在不同模式下根据编译环境而采用不同的具体Engine类，而在基类UEngine里通过一个WorldList保存了所有的World。"}]},{"ID":"20240128143128-z0fpea4","Type":"NodeList","ListData":{},"Properties":{"id":"20240128143128-z0fpea4","updated":"20240128143129"},"Children":[{"ID":"20240128143128-n1y3yhx","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240128143128-n1y3yhx","updated":"20240128143128"},"Children":[{"ID":"20240128143128-fwkq22a","Type":"NodeParagraph","Properties":{"id":"20240128143128-fwkq22a","updated":"20240128143128"},"Children":[{"Type":"NodeText","Data":"Standalone Game：会使用UGameEngine来创建出唯一的一个GameWorld，因为也只有一个，所以为了方便起见，就直接保存了GameInstance指针。"}]}]},{"ID":"20240128143128-2femv9e","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240128143128-2femv9e","updated":"20240128143128"},"Children":[{"ID":"20240128143128-tuk3dgh","Type":"NodeParagraph","Properties":{"id":"20240128143128-tuk3dgh","updated":"20240128143128"},"Children":[{"Type":"NodeText","Data":"而对于编辑器来说，EditorWorld其实只是用来预览，所以并不拥有OwningGameInstance，而PlayWorld里的OwningGameInstance才是间接保存了GameInstance."}]}]}]},{"ID":"20240128143128-trpjfmr","Type":"NodeParagraph","Properties":{"id":"20240128143128-trpjfmr","updated":"20240128143129"},"Children":[{"Type":"NodeText","Data":"目前来说，因为UE还不支持同时运行多个World（当前只能一个，但可以切换），所以GameInstance其实也是唯一的。提前说些题外话，虽然目前网络部分还没涉及到，但是当我们在Editor里进行MultiplePlayer的测试时，每一个Player Window里都是一个World。如果是DedicateServer模式，那DedicateServer也会是一个World。\n最后实例化出来的UEngine实例用一个全局的GEngine变量来保存。至此，我们已经到了引擎的最根处:"}]},{"ID":"20240128143128-z6bv3e4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240128143128-z6bv3e4","updated":"20240128143129"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"//UnrealEngine\\Engine\\Source\\Runtime\\Engine\\Private\\UnrealEngine.cpp\nENGINE_API UEngine*\tGEngine = NULL;\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240128143128-cvoz9iy","Type":"NodeParagraph","Properties":{"id":"20240128143128-cvoz9iy","updated":"20240128143129"},"Children":[{"Type":"NodeText","Data":"GEngine可以说是一切开始的地方了。翻看引擎源码，到处也可以看见从GEngine-\u003e出来的引用。"}]},{"ID":"20240128143128-qluejds","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240128143128-qluejds","updated":"20240128143128"},"Children":[{"Type":"NodeText","Data":"GamePlayStatics"}]},{"ID":"20240128143128-n76ovso","Type":"NodeParagraph","Properties":{"id":"20240128143128-n76ovso","updated":"20240128143129"},"Children":[{"Type":"NodeText","Data":"既然我们在引擎内部C++层次已经有了访问World操作Level的能力，那么在暴露出的蓝图系统里，UE为了我们的使用方便，也在Engine层次为我们提供了便利操作蓝图函数库。"}]},{"ID":"20240128143128-sqaqeqd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240128143128-sqaqeqd","updated":"20240128143129"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"dGV4dA=="},{"Type":"NodeCodeBlockCode","Data":"UCLASS ()\nclass UGameplayStatics : public UBlueprintFunctionLibrary \n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240128143128-309t06n","Type":"NodeParagraph","Properties":{"id":"20240128143128-309t06n","updated":"20240128143129"},"Children":[{"Type":"NodeText","Data":"我们在蓝图里见到的GetPlayerController、SpawActor和OpenLevel等都是来至于这个类的接口。这个类比较简单，相当于一个C++的静态类，只为蓝图暴露提供了一些静态方法。在想借鉴或者是查询某个功能的实现时，此处往往会是一个入口。"}]},{"ID":"20240128143128-ih30ccz","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240128143128-ih30ccz","updated":"20240128143128"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20240128143128-3ozkicl","Type":"NodeParagraph","Properties":{"id":"20240128143128-3ozkicl","updated":"20240128143407"},"Children":[{"Type":"NodeText","Data":"从结构上而言，我们已经来到了最根源的地方。GEngine仿佛就是一棵大树的根，当我们拎起它的时候，也会带出整个游戏世界的各个对象。但目前这些对象：Object-\u003eActor+Component-\u003eLevel-\u003eWorld-\u003eWorldContext-\u003eGameInstance-\u003eEngine，确实已经"},{"Type":"NodeText","Data":"足够表达UE游戏世界的各个部分。\n那作为GamePlay部分而言，我们还有一个问题：UE是如何把在该对象结构上表达游戏逻辑的？\n如果说：“程序=数据+算法”的话，那UE的GamePlay我们已经讨论完了数据部分，而下篇我们将开始讨论UE的游戏逻辑“算法”部分。"}]},{"ID":"20240128143128-0h4h89x","Type":"NodeParagraph","Properties":{"id":"20240128143128-0h4h89x","updated":"20240128143138"},"Children":[{"Type":"NodeText","Data":"上篇："},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20240128142721-xeuatb1","TextMarkBlockRefSubtype":"d","TextMarkTextContent":"GamePlay架构（二）Level和World"}]},{"ID":"20240128143128-urj614c","Type":"NodeParagraph","Properties":{"id":"20240128143128-urj614c","updated":"20240128143401"},"Children":[{"Type":"NodeText","Data":"下篇："},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20240128143211-phu3y9j","TextMarkBlockRefSubtype":"d","TextMarkTextContent":"GamePlay架构（四）Pawn"}]},{"ID":"20240128143128-3iazkbg","Type":"NodeParagraph","Properties":{"id":"20240128143128-3iazkbg","updated":"20240128143129"},"Children":[{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":"UE4.14"}]}]}