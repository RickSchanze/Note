{"ID":"20240429201045-jyxljhi","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240429201045-jyxljhi","title":"Chapter6 纹理 Texturing","type":"doc","updated":"20240510215006"},"Children":[{"ID":"20240429201045-u0yidc9","Type":"NodeParagraph","Properties":{"id":"20240429201045-u0yidc9","updated":"20240429201132"},"Children":[{"Type":"NodeText","Data":"表面纹理（texture）是指其外观和给人的视觉感受，就像是一幅油画的图案一样。而在计算机图形学中，纹理化则指的是一个过程，即通过使用一些图像、函数或者其他数据，来对每个表面位置的外观表现进行修改。"}]},{"ID":"20240429201134-7wnflzp","Type":"NodeBlockquote","Properties":{"id":"20240429201134-7wnflzp","updated":"20240429201146"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240429201134-n8v1dhl","Type":"NodeParagraph","Properties":{"id":"20240429201134-n8v1dhl","updated":"20240429201146"},"Children":[{"Type":"NodeText","Data":"例如：我们可以将一张砖墙的彩色图像应用于由两个三角形组成的矩形上，而不是去精确表现砖墙的几何结构。当我们观察这个砖墙矩形的时候，对应的彩色图像将会显示在这个矩形所在的位置上，这样可以使得这个矩形看起来很像真实的砖墙。除非相机十分靠近墙壁的话，否则砖墙几何细节的缺乏并不会带来明显的视觉瑕疵。"}]}]},{"ID":"20240429201146-egh97d0","Type":"NodeParagraph","Properties":{"id":"20240429201146-egh97d0","updated":"20240429201243"},"Children":[{"Type":"NodeText","Data":"然而，除了缺乏细致的几何结构之外，一些具有纹理的砖墙也有可能无法令人信服。"}]},{"ID":"20240429201244-87cmeba","Type":"NodeBlockquote","Properties":{"id":"20240429201244-87cmeba","updated":"20240429201301"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240429201246-37g5nvb","Type":"NodeParagraph","Properties":{"id":"20240429201246-37g5nvb","updated":"20240429201301"},"Children":[{"Type":"NodeText","Data":"例如：砖墙的砂浆（砖块和砖块之间粘合物）应当是"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"哑光"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"的（matte），而砖块则应当是"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"有光泽的（glossy）"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"，但是观察者会注意到，此时这两种材料表现出的"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"粗糙度（roughness）"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"实际上是相同的。"}]}]},{"ID":"20240429201243-nhin30n","Type":"NodeParagraph","Properties":{"id":"20240429201243-nhin30n","updated":"20240429201309"},"Children":[{"Type":"NodeText","Data":"为了产生更加令人信服的视觉表现，我们可以将第二张图像纹理应用到这个表面上，这种纹理并不会改变表面的颜色，而是会根据表面位置来修改墙壁的粗糙度。"}]},{"ID":"20240429201313-6gaqd3k","Type":"NodeParagraph","Properties":{"id":"20240429201313-6gaqd3k","updated":"20240429201325"},"Children":[{"Type":"NodeText","Data":"但是现在还有一些问题，那就是每个砖块看起来都非常平整，而真实的砖块表面通常都是坑坑洼洼的，是不规则的。我们可以通过使用"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"凹凸映射（bump mapping）"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"，对砖块表面的着色法线进行一些修改，从而使得其在渲染之后看起来并不平整。"}]},{"ID":"20240429201325-scy6djr","Type":"NodeParagraph","Properties":{"id":"20240429201325-scy6djr","updated":"20240429201419"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"视差映射"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"（parallax mapping）会在渲染平面时，使用一个特殊纹理来使其变形；"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"视差遮蔽映射"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"（parallax occlusion mapping）会对高度纹理进行光线投射，从而提高渲染的真实感。"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"位移映射"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"（displacement mapping）通过使用位移贴图，从而对模型的三角形高度进行修改。图6.1展示了一个具有颜色贴图和凹凸贴图的例子。"}]},{"ID":"20240429201427-jsojxsh","Type":"NodeParagraph","Properties":{"id":"20240429201427-jsojxsh","updated":"20240429201433"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240429201427-fquo8az.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"通过将颜色贴图和凹凸贴图应用到这条鱼身上，从而增加其细节表现。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240429201438-2ezzawb","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240429201438-2ezzawb","updated":"20240510215006"},"Children":[{"Type":"NodeText","Data":"6.1 纹理管线"}]},{"ID":"20240429201448-sos0fxf","Type":"NodeParagraph","Properties":{"id":"20240429201448-sos0fxf","updated":"20240429201625"},"Children":[{"Type":"NodeText","Data":"纹理化（texturing）是一种用于描述表面材质以及对表面进行修饰加工的有效技术。"}]},{"ID":"20240429201626-8pqm6kb","Type":"NodeParagraph","Properties":{"id":"20240429201626-8pqm6kb","updated":"20240429201632"},"Children":[{"Type":"NodeText","Data":"纹理化的过程可以被描述为一个更加一般的纹理管线。"}]},{"ID":"20240429201641-y18tpwh","Type":"NodeParagraph","Properties":{"id":"20240429201641-y18tpwh","updated":"20240429201650"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"纹理化的起点首先是空间中的一个具体位置，这个位置可以在世界空间中，但是通常都会放在模型的参考坐标系中，因为当模型发生移动的时候，纹理也会随之移动。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"这个空间点会应用一个投影函数（projector function）来获得一组数字，它被称为纹理坐标（texture coordinates），这个纹理坐标将用于访问和采样纹理，这个过程被称为纹理映射（texture mapping）。"}]},{"ID":"20240429201746-hfei603","Type":"NodeParagraph","Properties":{"id":"20240429201746-hfei603","updated":"20240429201803"},"Children":[{"Type":"NodeText","Data":"在使用纹理坐标访问纹理之前，还需要使用一个或者多个转换函数（corresponder function），来将纹理坐标转换到纹理空间中。 转换后的纹理空间位置用于在纹理中获取像素值。"}]},{"ID":"20240429201803-f6gfm0s","Type":"NodeBlockquote","Properties":{"id":"20240429201803-f6gfm0s","updated":"20240429201817"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240429201805-rj1a1uz","Type":"NodeParagraph","Properties":{"id":"20240429201805-rj1a1uz","updated":"20240429201817"},"Children":[{"Type":"NodeText","Data":"例如：纹理空间位置可以是图像纹理中的数组索引，从而检索到对应位置上的像素值。检索到的像素值可能还需要使用一个值转换函数（value transform function）来进行转换，最终这些新值会用于对表面的某些属性进行修改，例如材质或者着色法线等。"}]}]},{"ID":"20240429201818-i4b1riu","Type":"NodeParagraph","Properties":{"id":"20240429201818-i4b1riu","updated":"20240429201828"},"Children":[{"Type":"NodeText","Data":"下图展示了一个纹理的应用过程："}]},{"ID":"20240429201832-1zyxdfm","Type":"NodeParagraph","Properties":{"id":"20240429201832-1zyxdfm","updated":"20240429201841"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240429201832-b4iyhdo.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"针对单个纹理的广义纹理管线"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240429202319-lrf9cu1","Type":"NodeParagraph","Properties":{"id":"20240429202319-lrf9cu1","updated":"20240429202324"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240429202319-76546tm.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"砖墙纹理管线过程中的参数变化"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240429202325-gdl85qk","Type":"NodeParagraph","Properties":{"id":"20240429202325-gdl85qk","updated":"20240429202403"},"Children":[{"Type":"NodeText","Data":"在上面的砖墙纹理管线中："}]},{"ID":"20240429202403-ifqx0tu","Type":"NodeList","ListData":{},"Properties":{"id":"20240429202403-ifqx0tu","updated":"20240429202711"},"Children":[{"ID":"20240429202415-y31s830","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429202415-y31s830","updated":"20240429202415"},"Children":[{"ID":"20240429202415-z4465rg","Type":"NodeParagraph","Properties":{"id":"20240429202415-z4465rg","updated":"20240429202457"},"Children":[{"Type":"NodeText","Data":"首先我们会在该物体的局部参考系中，找到对应的采样位置"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"(x, y, z)"},{"Type":"NodeText","Data":"，这里假设它是"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"(−2.3,7.1,88.2)"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240429202508-2dmt72b","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429202508-2dmt72b"},"Children":[{"ID":"20240429202508-v0gajp9","Type":"NodeParagraph","Properties":{"id":"20240429202508-v0gajp9","updated":"20240429202613"},"Children":[{"Type":"NodeText","Data":"然后会对这个位置坐标应用一个投影函数，就像世界地图是三维地球的二维投影那样，这里的投影函数通常会将一个三维向量(x, y, z)转换为一个二维向量(u, v)。这里我们假设转换后的值是(0.32,0.29)，这个数值对也被称为纹理坐标或者UV坐标。"}]}]},{"ID":"20240429202616-sdqiyer","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429202616-sdqiyer"},"Children":[{"ID":"20240429202616-thsrvy8","Type":"NodeParagraph","Properties":{"id":"20240429202616-thsrvy8","updated":"20240429202628"},"Children":[{"Type":"NodeText","Data":"假设这里我们所使用的砖墙纹理分辨率为256\\times 256，因此使用转换函数，将纹理坐标(u, v)各自乘以256，即(81.92,74.24)。在丢弃小数部分之后，我们在砖墙图像中进行检索，找到索引值为(81,74)的颜色值，这里假设这个颜色值为(0.9, 0.8, 0.7)。"}]}]},{"ID":"20240429202635-aser17u","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429202635-aser17u","updated":"20240429202711"},"Children":[{"ID":"20240429202635-dbc4wji","Type":"NodeParagraph","Properties":{"id":"20240429202635-dbc4wji","updated":"20240429202711"},"Children":[{"Type":"NodeText","Data":"我们所使用的纹理颜色位于sRGB颜色空间中，因此如果要在着色方程中使用这个颜色值，还需要将其转换到线性空间中，即（0.787、0.604、0.448）"}]}]}]},{"ID":"20240429202457-792nrys","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240429202457-792nrys","updated":"20240510215006"},"Children":[{"Type":"NodeText","Data":"6.1.1 投影函数"}]},{"ID":"20240429202740-tp5jwfx","Type":"NodeParagraph","Properties":{"id":"20240429202740-tp5jwfx","updated":"20240429202812"},"Children":[{"Type":"NodeText","Data":"纹理处理的第一步是获取表面的位置，并将其投影到纹理坐标空间（texture coordinate space）中，这个纹理坐标空间通常是一个二维(u,v)空间。"}]},{"ID":"20240429202813-sop64tb","Type":"NodeBlockquote","Properties":{"id":"20240429202813-sop64tb","updated":"20240429202838"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240429202815-ush8sih","Type":"NodeParagraph","Properties":{"id":"20240429202815-ush8sih","updated":"20240429202838"},"Children":[{"Type":"NodeText","Data":"常见的建模软件都允许艺术家定义每个顶点的(u,v)坐标。"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"这些"},{"Type":"NodeText","Data":"(u,v)"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"坐标可以"},{"Type":"NodeText","Data":"从投影函数（projector function）或者网格展开算法（mesh unwrapping algorithm）中进行初始化，艺术家也可以像编辑顶点位置那样，对(u,v)坐标进行编辑。"}]}]},{"ID":"20240429202821-3r46wuj","Type":"NodeParagraph","Properties":{"id":"20240429202821-3r46wuj","updated":"20240429202853"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"投影函数的作用通常是将空间中的三维坐标转换为二维纹理坐标"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240429202940-tshvmwm","Type":"NodeParagraph","Properties":{"id":"20240429202940-tshvmwm","updated":"20240429202949"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240429202940-4b9zoi8.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"不同的纹理投影方法。第一行从左到右分别是：球面、柱面、平面和自然 (u,v) 投影。第二行则展示了这些投影方法应用于同一个物体的结果（不包含自然投影）。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240429202951-pdvo5fi","Type":"NodeParagraph","Properties":{"id":"20240429202951-pdvo5fi","updated":"20240429203043"},"Children":[{"Type":"NodeText","Data":"在实时渲染中，通常会在建模阶段使用投影函数，并将结果数据存储在顶点上。"}]},{"ID":"20240429203044-6oipoxa","Type":"NodeParagraph","Properties":{"id":"20240429203044-6oipoxa","updated":"20240429203059"},"Children":[{"Type":"NodeText","Data":"但是情况并非总是如此，有时在顶点着色器或者像素着色器中应用投影函数是会带来一些好处，这样做可以提高精度，并有助于实现包括动画（章节6.4）在内的各种效果。有时候一些渲染方法有着自己独特的投影函数，它们会进行逐像素的计算，例如环境映射（environment mapping，章节10.4）。"}]},{"ID":"20240429203059-i8dyeve","Type":"NodeList","ListData":{},"Properties":{"id":"20240429203059-i8dyeve","updated":"20240429203230"},"Children":[{"ID":"20240429203230-47z8mt4","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429203230-47z8mt4","updated":"20240429203230"},"Children":[{"ID":"20240429203230-17q5zv3","Type":"NodeParagraph","Properties":{"id":"20240429203230-17q5zv3","updated":"20240429203230"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"球面投影"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"（spherical projection，图6.4左侧）会将表面点投影到一个以某点为中心的假想球体上。"}]}]}]},{"ID":"20240429203138-issnvxk","Type":"NodeList","ListData":{},"Properties":{"id":"20240429203138-issnvxk","updated":"20240429203301"},"Children":[{"ID":"20240429203232-kz48pqr","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429203232-kz48pqr","updated":"20240429203301"},"Children":[{"ID":"20240429203232-swu3909","Type":"NodeParagraph","Properties":{"id":"20240429203232-swu3909","updated":"20240429203232"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"柱面投影"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"（cylindrical projection）计算纹理坐标u的方法与球面投影相同，而纹理坐标v则是沿圆柱体轴的距离。"}]},{"ID":"20240429203254-w639uoo","Type":"NodeBlockquote","Properties":{"id":"20240429203254-w639uoo","updated":"20240429203254"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240429203254-f1xhhby","Type":"NodeParagraph","Properties":{"id":"20240429203254-f1xhhby","updated":"20240429203254"},"Children":[{"Type":"NodeText","Data":"这种投影方法对于具有中心轴的物体而言十分有用，例如旋转的表面。"}]}]},{"ID":"20240429203300-pa2tbvi","Type":"NodeParagraph","Properties":{"id":"20240429203300-pa2tbvi","updated":"20240429203301"},"Children":[{"Type":"NodeText","Data":"缺点：当一个表面几乎垂直于圆柱体的中轴时，就会发生畸变（如柱面投影两端的圆形表面）。"}]}]}]},{"ID":"20240429203156-968puun","Type":"NodeList","ListData":{},"Properties":{"id":"20240429203156-968puun","updated":"20240429203320"},"Children":[{"ID":"20240429203304-zigrt8m","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429203304-zigrt8m","updated":"20240429203320"},"Children":[{"ID":"20240429203304-t7g2okz","Type":"NodeParagraph","Properties":{"id":"20240429203304-t7g2okz","updated":"20240429203320"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"平面投影"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"（planar projection）就像一束x射线一样，它会沿着一个方向进行平行投射，并将纹理应用到所有的表面上。平面投影使用了正交投影方法（章节4.7.1）。这种类型的投影在贴花（decal）应用中十分有用"}]}]}]},{"ID":"20240429203314-nolc3i5","Type":"NodeParagraph","Properties":{"id":"20240429203314-nolc3i5","updated":"20240429203419"},"Children":[{"Type":"NodeText","Data":"与投影方向平齐的表面会发生严重的扭曲，因此艺术家经常需要手动将模型分解成接近平面的小块（即建模流程中的分UV）。"}]},{"ID":"20240429203441-94ue8gt","Type":"NodeParagraph","Properties":{"id":"20240429203441-94ue8gt","updated":"20240429203457"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240429203441-o0mqe47.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"几张用于渲染雕像模型的小纹理，它们被打包存储在两个较大的纹理中。右图展示了这个雕像的三角形网格是如何被展开的，以及是如何将纹理映射到三角形网格上的"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240429203458-qihmncn","Type":"NodeParagraph","Properties":{"id":"20240429203458-qihmncn","updated":"20240429203518"},"Children":[{"Type":"NodeText","Data":"纹理坐标空间并不总是一个二维平面，有时候它也可能是一个三维体积，在这种情况下，纹理坐标会被表示为一个包含三个分量的向量(u, v, w)，其中w是沿着投影方向的深度。"}]},{"ID":"20240429203518-nq3d5ne","Type":"NodeParagraph","Properties":{"id":"20240429203518-nq3d5ne","updated":"20240429203627"},"Children":[{"Type":"NodeText","Data":"另一类重要的纹理坐标空间是"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"方向性的"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"纹理空间中的每个点都需要通过输入方向来进行访问"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。将这种空间进行可视化的一种方法是，将其作为单位球体上的点，每个点位置上的法线代表了用于访问该位置纹理的输入方向。使用这种方向性参数化的、最常见的纹理类型就是"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"立方体贴图"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"（cube map，章节6.2.4）。"}]},{"ID":"20240429203556-r7ijonf","Type":"NodeParagraph","Properties":{"id":"20240429203556-r7ijonf","updated":"20240429203653"},"Children":[{"Type":"NodeText","Data":"由于多个纹理可以被应用到同一个表面上，因此可能需要定义多组纹理坐标。但是无论怎样使用这些纹理坐标，其核心思想都是相同的："},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"这些纹理坐标会在表面上进行插值，并用于检索纹理值。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"}]},{"ID":"20240429203653-q0lqcct","Type":"NodeParagraph","Properties":{"id":"20240429203653-q0lqcct","updated":"20240429203656"},"Children":[{"Type":"NodeText","Data":"在进行插值之前，这些纹理坐标还需要使用转换函数进行变换。"}]},{"ID":"20240429203659-1qbxpyv","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240429203659-1qbxpyv","updated":"20240510215006"},"Children":[{"Type":"NodeText","Data":"6.1.2 转换函数"}]},{"ID":"20240429203707-6ftpj78","Type":"NodeParagraph","Properties":{"id":"20240429203707-6ftpj78","updated":"20240429203716"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"转换函数（corresponder function）用于将纹理坐标转换为纹理空间中的具体位置"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"，它们提高了在表面上应用纹理的灵活性。"}]},{"ID":"20240429203843-kzu9xpe","Type":"NodeList","ListData":{},"Properties":{"id":"20240429203843-kzu9xpe","updated":"20240429204014"},"Children":[{"ID":"20240429203843-s7pz88m","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429203843-s7pz88m","updated":"20240429203843"},"Children":[{"ID":"20240429203843-yw2b1r8","Type":"NodeParagraph","Properties":{"id":"20240429203843-yw2b1r8","updated":"20240429203843"},"Children":[{"Type":"NodeText","Data":"转换函数的其中一个例子是：使用API选择现有纹理中的一部分来进行显示；并且在后续操作中都只会用到这个子图像。"}]}]},{"ID":"20240429203843-sbjib7l","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429203843-sbjib7l","updated":"20240429203843"},"Children":[{"ID":"20240429203843-e3jihna","Type":"NodeParagraph","Properties":{"id":"20240429203843-e3jihna","updated":"20240429203843"},"Children":[{"Type":"NodeText","Data":"另一类转换函数是矩阵变换，应用于顶点着色器或者像素着色器中，它们允许对表面上的纹理进行平移、旋转、缩放、剪切或者投影操作。"}]},{"ID":"20240429203843-bz898od","Type":"NodeParagraph","Properties":{"id":"20240429203843-bz898od","updated":"20240429203843"},"Children":[{"Type":"NodeText","Data":"令人惊讶的是，纹理的变换顺序必须与预期的变换顺序相反，这是因为纹理变换实际上是对决定图像可见位置的遮罩空间产生了影响；图像本身并没有被变换，真正发生变换的是定义图像位置的空间。"}]}]},{"ID":"20240429203843-bldof4x","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429203843-bldof4x","updated":"20240429204014"},"Children":[{"ID":"20240429203843-35hdtdh","Type":"NodeParagraph","Properties":{"id":"20240429203843-35hdtdh","updated":"20240429203851"},"Children":[{"Type":"NodeText","Data":"另一类转换函数控制了图像的应用方式。"}]},{"ID":"20240429203852-d996ix6","Type":"NodeList","ListData":{},"Properties":{"id":"20240429203852-d996ix6","updated":"20240429203854"},"Children":[{"ID":"20240429203854-2fenl49","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429203854-2fenl49","updated":"20240429203854"},"Children":[{"ID":"20240429203854-932kvrs","Type":"NodeParagraph","Properties":{"id":"20240429203854-932kvrs","updated":"20240429203907"},"Children":[{"Type":"NodeText","Data":"wrap: 图像在表面上重复"}]}]},{"ID":"20240429203912-0eov6xm","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429203912-0eov6xm"},"Children":[{"ID":"20240429203912-oijus8j","Type":"NodeParagraph","Properties":{"id":"20240429203912-oijus8j","updated":"20240429203929"},"Children":[{"Type":"NodeText","Data":"mirror: 每重复一次就镜像翻转"}]}]},{"ID":"20240429203929-j43bcav","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429203929-j43bcav"},"Children":[{"ID":"20240429203929-2w147k9","Type":"NodeParagraph","Properties":{"id":"20240429203929-2w147k9","updated":"20240429203944"},"Children":[{"Type":"NodeText","Data":"clamp: 超出范围外被clamp至范围"}]}]},{"ID":"20240429203944-ulgz5pz","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429203944-ulgz5pz"},"Children":[{"ID":"20240429203944-1gsexn2","Type":"NodeParagraph","Properties":{"id":"20240429203944-1gsexn2","updated":"20240429203950"},"Children":[{"Type":"NodeText","Data":"border: 直接用边界"}]}]}]},{"ID":"20240429204009-ok2i2c6","Type":"NodeParagraph","Properties":{"id":"20240429204009-ok2i2c6","updated":"20240429204014"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240429204009-s0dyn6m.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"纹理图像的不同寻址模式，从左到右分别是repeat，mirror，clamp和border。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]}]}]},{"ID":"20240429204004-qkhj4hh","Type":"NodeParagraph","Properties":{"id":"20240429204004-qkhj4hh","updated":"20240429204045"},"Children":[{"Type":"NodeText","Data":"纹理的重复平铺是一种为场景添加更多视觉细节的廉价方法，但是通常来说，这种方法在纹理重复三次之后就看起来不太自然了，因为人眼会识别出这种重复的图案。"}]},{"ID":"20240429204049-wat94bo","Type":"NodeList","ListData":{},"Properties":{"id":"20240429204049-wat94bo","updated":"20240429204055"},"Children":[{"ID":"20240429204049-3wa4e1n","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429204049-3wa4e1n","updated":"20240429204049"},"Children":[{"ID":"20240429204049-znwi57y","Type":"NodeParagraph","Properties":{"id":"20240429204049-znwi57y","updated":"20240429204049"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"避免这种周期性（periodicity）问题的一个常见方法是，将纹理值与另一个非重复平铺的纹理相结合"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240429204055-stv3nle","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429204055-stv3nle","updated":"20240429204055"},"Children":[{"ID":"20240429204055-w4c7mks","Type":"NodeParagraph","Properties":{"id":"20240429204055-w4c7mks","updated":"20240429204055"},"Children":[{"Type":"NodeText","Data":"另一个避免周期性问题的方法是，使用着色器程序来实现一些特殊的转换函数，从而将纹理图案和瓦片（tile）贴图进行随机重组。"}]}]}]},{"ID":"20240429204046-zo456bx","Type":"NodeParagraph","Properties":{"id":"20240429204046-zo456bx","updated":"20240429204152"},"Children":[{"Type":"NodeText","Data":"最后一种被应用的转换函数是隐式的，并且与图像的大小有关。纹理通常会应用在uv坐标的[0,1]范围内。优势在于：可以使用不同分辨率的纹理贴图，而且不需要修改存储在模型顶点中的纹理坐标值。"}]},{"ID":"20240429204148-x1m9ypr","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240429204148-x1m9ypr","updated":"20240510215006"},"Children":[{"Type":"NodeText","Data":"6.2 图像纹理"}]},{"ID":"20240429204158-amdgdmd","Type":"NodeParagraph","Properties":{"id":"20240429204158-amdgdmd","updated":"20240429204400"},"Children":[{"Type":"NodeText","Data":"像素着色器可以通过将纹理坐标传给texture2D等函数，并调用它们来访问纹理；这些纹理坐标位于(u,v)纹理坐标系中，会通过转换函数来将其映射到[0.0,1.0]范围中，然后再由GPU负责将这个值转换为纹素坐标。"}]},{"ID":"20240429204400-azbop6a","Type":"NodeParagraph","Properties":{"id":"20240429204400-azbop6a","updated":"20240429204427"},"Children":[{"Type":"NodeText","Data":"纹素具有整数类型的坐标，但是我们会经常想要访问两个纹素之间的位置，并在它们之间进行插值，这就引出了一个问题：像素中心的浮点坐标到底是什么？"}]},{"ID":"20240429204459-tve1qum","Type":"NodeParagraph","Properties":{"id":"20240429204459-tve1qum","updated":"20240429204537"},"Children":[{"Type":"NodeText","Data":"具有两种可能的模式：截断和舍入。向下取整是更直观的系统。"}]},{"ID":"20240429204537-vt67ngp","Type":"NodeBlockquote","Properties":{"id":"20240429204537-vt67ngp","updated":"20240429204541"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240429204537-xdwjwoc","Type":"NodeParagraph","Properties":{"id":"20240429204537-xdwjwoc","updated":"20240429204541"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"例如：当我们说一个像素位于坐标"},{"Type":"NodeText","Data":"(5,9)"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"时，实际上我们指的是沿"},{"Type":"NodeText","Data":"u"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"轴方向上从5.0-6.0的范围，以及沿"},{"Type":"NodeText","Data":"v"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"轴方向上从9.0-10.0的范围。"}]}]},{"ID":"20240429204542-dylym6j","Type":"NodeParagraph","Properties":{"id":"20240429204542-dylym6j","updated":"20240429204557"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"依赖纹理读取"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"（dependent texture read）是一个值得解释的术语，它包含两个定义。"}]},{"ID":"20240429204558-5xeatg3","Type":"NodeList","ListData":{},"Properties":{"id":"20240429204558-5xeatg3","updated":"20240429205443"},"Children":[{"ID":"20240429204558-st4ts6r","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429204558-st4ts6r","updated":"20240429204558"},"Children":[{"ID":"20240429204558-u8f5gjh","Type":"NodeParagraph","Properties":{"id":"20240429204558-u8f5gjh","updated":"20240429204618"},"Children":[{"Type":"NodeText","Data":"第一个定义是针对移动设备而言的，当我们使用texture2D或者类似方式访问纹理，并在像素着色器内手动计算纹理坐标，而不是使用从顶点着色器传入的、未修改的纹理坐标时，就会发生依赖纹理读取。"}]},{"ID":"20240429205358-tt46oah","Type":"NodeParagraph","Properties":{"id":"20240429205358-tt46oah","updated":"20240429205403"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"这里提到的手动计算纹理坐标，包括任何对输入纹理坐标的修改，甚至是像交换u和v这样的简单操作。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"}]}]},{"ID":"20240429205418-vk5hlew","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429205418-vk5hlew","updated":"20240429205443"},"Children":[{"ID":"20240429205418-mgyjn2n","Type":"NodeParagraph","Properties":{"id":"20240429205418-mgyjn2n","updated":"20240429205432"},"Children":[{"Type":"NodeText","Data":"另一个定义是当一个纹理坐标依赖于之前的纹理值结果时，就会发生依赖纹理读取。"}]},{"ID":"20240429205438-iqv0fn4","Type":"NodeBlockquote","Properties":{"id":"20240429205438-iqv0fn4","updated":"20240429205443"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240429205439-yjryvhr","Type":"NodeParagraph","Properties":{"id":"20240429205439-yjryvhr","updated":"20240429205443"},"Children":[{"Type":"NodeText","Data":"例如：一个纹理可能会改变表面的着色法线，这反过来又会改变用于访问立方体贴图（cube map）的坐标。"}]}]}]}]},{"ID":"20240429205336-m23ncga","Type":"NodeParagraph","Properties":{"id":"20240429205336-m23ncga","updated":"20240429205542"},"Children":[{"Type":"NodeText","Data":"GPU所使用的纹理尺寸通常为"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"2^m\\times2^n"},{"Type":"NodeText","Data":" ，其中m和n为非负整数，这样的纹理被称为2次幂（power-of-two，POT）纹理。"}]},{"ID":"20240429205521-xg4e582","Type":"NodeParagraph","Properties":{"id":"20240429205521-xg4e582","updated":"20240429205648"},"Children":[{"Type":"NodeText","Data":"那么当屏幕像素大于或小于纹理尺寸应该怎么办呢？下面介绍"}]},{"ID":"20240429205653-pbks1ax","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240429205653-pbks1ax","updated":"20240510215006"},"Children":[{"Type":"NodeText","Data":"6.2.1 纹理尺寸过小（一个纹素对应多个像素）"}]},{"ID":"20240507163737-h60ahd0","Type":"NodeParagraph","Properties":{"id":"20240507163737-h60ahd0","updated":"20240507165539"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240507163737-1guk3o2.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"将 48 x 48 的纹理放大到 320 x 320 。左：邻近过滤，每个像素都会选择距离其最近的纹素。中间：双线性过滤，使用四个最近像素的加权平均值。右：立方滤波（三次滤波），使用 5 x 5 范围内最近像素的加权平均值。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240507163826-xhacy63","Type":"NodeParagraph","Properties":{"id":"20240507163826-xhacy63","updated":"20240507165539"},"Children":[{"Type":"NodeText","Data":"上图左侧使用临近过滤，这种放大技术可能导致单个纹素十分明显，这种效果叫做"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"像素化"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。因为该方法在放大的时候，会选取距离每个像素中心最近的纹素，从而产生了块状外观。它的好处每个像素只需获取一个纹素。"}]},{"ID":"20240507164022-lkjhtef","Type":"NodeParagraph","Properties":{"id":"20240507164022-lkjhtef","updated":"20240507165539"},"Children":[{"Type":"NodeText","Data":"中间使用了双线性插值。对于每个像素而言，这种过滤方法需要找到四个相邻的纹素，并在二维上进行线性插值，从而获得混合后的像素值。它虽然比较模糊，但是不会像临近过滤一样产生锯齿。"}]},{"ID":"20240507164037-coiuyx8","Type":"NodeParagraph","Properties":{"id":"20240507164037-coiuyx8","updated":"20240507165539"},"Children":[{"Type":"NodeText","Data":"假设在不舍弃小数的情况下，我们获得一个坐标"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"(p_u, p_v) =(81.92, 74.24)"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"。"},{"Type":"NodeText","Data":" 我们的目标是在这四个纹素之间插值获得该点像素值，如下图："}]},{"ID":"20240507164250-rjb6ceu","Type":"NodeParagraph","Properties":{"id":"20240507164250-rjb6ceu","updated":"20240507165539"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240507164250-63g3ne5.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"双线性插值。涉及的四个纹素由左边的四个正方形表示，其中蓝点代表了纹素的中心点。右边则展示了由四个纹素中心所形成的局部坐标系。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240507164258-e6douvr","Type":"NodeParagraph","Properties":{"id":"20240507164258-e6douvr","updated":"20240507165539"},"Children":[{"Type":"NodeText","Data":"定义纹理访问函数为"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"t(x,y)"},{"Type":"NodeText","Data":"，该函数返回纹理颜色。那么双线性插值如下："}]},{"ID":"20240507164433-hgf27tt","Type":"NodeParagraph","Properties":{"id":"20240507164433-hgf27tt","updated":"20240507165539"},"Children":[{"Type":"NodeText","Data":"首先，使用下方的两个纹素颜色"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"t (x, y)和t (x + 1, y)"},{"Type":"NodeText","Data":"，按照参数"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"u^{\\prime}"},{"Type":"NodeText","Data":"进行插值，即"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"(1−u^{\\prime})t(x, y) + u^{\\prime}t (x + 1, y)"},{"Type":"NodeText","Data":"；再使用上方的两个纹素颜色"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"t (x, y + 1)和t (x + 1, y+ 1)"},{"Type":"NodeText","Data":"，按照参数"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"u^{\\prime}"},{"Type":"NodeText","Data":"进行插值，即"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"(1−u^{\\prime}) t (x, y + 1) +u^{\\prime}t (x + 1, y+ 1)"},{"Type":"NodeText","Data":"，"}]},{"ID":"20240507164512-biyj4qr","Type":"NodeParagraph","Properties":{"id":"20240507164512-biyj4qr","updated":"20240507165539"},"Children":[{"Type":"NodeText","Data":"则纹素颜色"}]},{"ID":"20240507164540-nub6pky","Type":"NodeMathBlock","Properties":{"id":"20240507164540-nub6pky","updated":"20240507165539"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\begin{aligned} \\mathbf{b}\\left(p_{u}, p_{v}\\right)= \u0026 \\left(1-v^{\\prime}\\right)\\left(\\left(1-u^{\\prime}\\right) \\mathbf{t}(x, y)+u^{\\prime} \\mathbf{t}(x+1, y)\\right) \\\\ \u0026 +v^{\\prime}\\left(\\left(1-u^{\\prime}\\right) \\mathbf{t}(x, y+1)+u^{\\prime} \\mathbf{t}(x+1, y+1)\\right) \\\\ = \u0026 \\left(1-u^{\\prime}\\right)\\left(1-v^{\\prime}\\right) \\mathbf{t}(x, y)+u^{\\prime}\\left(1-v^{\\prime}\\right) \\mathbf{t}(x+1, y) \\\\ \u0026 +\\left(1-u^{\\prime}\\right) v^{\\prime} \\mathbf{t}(x, y+1)+u^{\\prime} v^{\\prime} \\mathbf{t}(x+1, y+1) .\\end{aligned}\n\\tag{6.1}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240507164534-4vg6qq1","Type":"NodeParagraph","Properties":{"id":"20240507164534-4vg6qq1","updated":"20240507165539"},"Children":[{"Type":"NodeText","Data":"从直观上来说，距离采样位置越近的纹素，对其最终颜色值的影响也就越大。"}]},{"ID":"20240507164740-auty102","Type":"NodeParagraph","Properties":{"id":"20240507164740-auty102","updated":"20240507165539"},"Children":[{"Type":"NodeText","Data":"解决模糊的常见方法是使用细节贴图。这个纹理代表了表面上的精细细节，这些细节会作为一个独立的纹理贴图，以不同的尺度被覆盖在放大后的纹理上。"}]},{"ID":"20240507164832-ly8ypvl","Type":"NodeParagraph","Properties":{"id":"20240507164832-ly8ypvl","updated":"20240507165539"},"Children":[{"Type":"NodeText","Data":"双线性插值会在两个方向上进行线性插值，但是有些情况下我们其实并不需要线性插值。"}]},{"ID":"20240507164834-49y3vaa","Type":"NodeBlockquote","Properties":{"id":"20240507164834-49y3vaa","updated":"20240507165539"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240507164834-sfoipge","Type":"NodeParagraph","Properties":{"id":"20240507164834-sfoipge","updated":"20240507164852"},"Children":[{"Type":"NodeText","Data":"例如：一个纹理是由类似于棋盘格的黑白像素组成的，使用双线性插值使得原本的黑白结果变成了平滑的灰度值。这时候我们需要对结果进行通过重新映射，例如我们可以让所有低于0.4的灰色都变成黑色，所有高于0.6的灰色都变成白色，而那些介于两者之间的灰色，则被拉伸用以填补空白，使得纹理看起来更像是原本的棋盘格，同时也在纹理之间进行了一些混合过渡，如图所示。"}]},{"ID":"20240507164855-zi7h190","Type":"NodeParagraph","Properties":{"id":"20240507164855-zi7h190","updated":"20240507164903"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240507164855-twz1r9n.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"从左到右分别是邻近过滤，双线性插值，和部分重新映射的结果，原本的纹理是一个 2 × 2 的黑白棋盘格。需要注意的是，由于纹理和图像网格并不是完美匹配的，因此邻近过滤方法所生成的正方形大小略有不同。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]}]},{"ID":"20240507164903-5u8um62","Type":"NodeParagraph","Properties":{"id":"20240507164903-5u8um62","updated":"20240507165539"},"Children":[{"Type":"NodeText","Data":"对于双三次插值（bicubic filter），它大幅去除了方块感。需要注意的是，双三次插值比双线性插值的计算成本更高。"}]},{"ID":"20240507165028-5dchgku","Type":"NodeParagraph","Properties":{"id":"20240507165028-5dchgku","updated":"20240507165539"},"Children":[{"Type":"NodeText","Data":"一个更简单的技术是在2X2纹素之间使用一个平滑曲线进行插值。最常用的是smoothstep曲线和quintic(五次)曲线："}]},{"ID":"20240507165110-d36o90n","Type":"NodeMathBlock","Properties":{"id":"20240507165110-d36o90n","updated":"20240507165539"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\underbrace{s(x)=x^{2}(3-2 x)}_{\\text {smoothstep }} and \\underbrace{q(x)=x^{3}\\left(6 x^{2}-15 x+10\\right)}_{\\text {quintic }}\n\\tag{6.2}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240507165114-g8kmsis","Type":"NodeParagraph","Properties":{"id":"20240507165114-g8kmsis","updated":"20240507165539"},"Children":[{"Type":"NodeText","Data":"smoothstep曲线具有"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"s^{\\prime}(0) = s^{\\prime}(1) = 0"},{"Type":"NodeText","Data":"的性质（"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"C^1"},{"Type":"NodeText","Data":"连续），它在0-1之间是非常平滑的。quintic曲线具有类似的性质，唯一不同是"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"q^{\\prime \\prime}(0) = q^{\\prime \\prime}(1) = 0"},{"Type":"NodeText","Data":"（"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"C^2"},{"Type":"NodeText","Data":"连续），即曲线在开始和结束处的二阶导数也是0。"}]},{"ID":"20240507165208-i1h0157","Type":"NodeParagraph","Properties":{"id":"20240507165208-i1h0157","updated":"20240507165539"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240507165208-7uoiu9e.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240507165213-a8l7jcz","Type":"NodeParagraph","Properties":{"id":"20240507165213-a8l7jcz","updated":"20240507165539"},"Children":[{"Type":"NodeText","Data":"该方法首先会计算出位置"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\left(u^{\\prime}, v^{\\prime}\\right)"},{"Type":"NodeText","Data":"（与方程6.1和图6.9中使用相同的方法），然后将采样位置与纹理尺寸相乘并加上0.5。结果的整数部分暂时先保留，小数部分会存储在"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"u^{\\prime}和v^{\\prime}"},{"Type":"NodeText","Data":"中，它们的取值范围是[0,1]。然后再将"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\left(u^{\\prime}, v^{\\prime}\\right)"},{"Type":"NodeText","Data":"变换为"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\left(t_{u}, t_{v}\\right)=\\left(q\\left(u^{\\prime}\\right), q\\left(v^{\\prime}\\right)\\right)"},{"Type":"NodeText","Data":"，这个结果仍然在[0,1]的范围内；将这个结果减去0.5，再加上原来的整数部分。然后将得到的坐标u和坐标v分别除以纹理宽度和纹理高度。此时，会将这个新的纹理坐标作为参数，传给GPU提供的双线性插值查找函数。"}]},{"ID":"20240507165315-obmokl6","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240507165315-obmokl6","updated":"20240510215006"},"Children":[{"Type":"NodeText","Data":"6.2.2 纹理尺寸过大（一个像素占据多个纹素）"}]},{"ID":"20240507165359-rgwqkqs","Type":"NodeParagraph","Properties":{"id":"20240507165359-rgwqkqs","updated":"20240507165649"},"Children":[{"Type":"NodeText","Data":"假如使用临近过滤方法处理这种情况，可能会出现严重的锯齿问题（下图第一行）："}]},{"ID":"20240507165629-t3uuehw","Type":"NodeParagraph","Properties":{"id":"20240507165629-t3uuehw","updated":"20240507165637"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240507165629-5gvdq2t.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"第一行图像使用了点采样（邻近过滤），第二行图像使用了mipmap，第三行图像使用了SAT。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240507165638-x5gxkcz","Type":"NodeParagraph","Properties":{"id":"20240507165638-x5gxkcz","updated":"20240507165731"},"Children":[{"Type":"NodeText","Data":"此外在运动过程中，由于只选择一个纹素代表颜色，故瑕疵会变得更加明显，成为"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"时域锯齿"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240507165728-mjnydc5","Type":"NodeBlockquote","Properties":{"id":"20240507165728-mjnydc5","updated":"20240507165843"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240507165833-y8kpb0q","Type":"NodeParagraph","Properties":{"id":"20240507165833-y8kpb0q","updated":"20240507165843"},"Children":[{"Type":"NodeText","Data":"走样（锯齿）问题可以通过采样技术和滤波技术来解决。纹理的信号频率取决于纹素在屏幕上的间隔距离，根据Nyquist极限，我们只需要确保纹理的信号频率不大于采样频率的一半即可。例如：假设现在有这样一个图像，它由黑白相间的线条组成，其中每个线条占据了两个纹素，即频率为"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\frac{1}{2}"},{"Type":"NodeText","Data":"。为了在屏幕上能够正确显示这个纹理，那么采样频率必须至少为"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"2 \\times\\frac{1}{2}=1"},{"Type":"NodeText","Data":"，即至少一个像素。因此对于纹理而言，一般一个像素应当最多对应一个纹素，这样可以避免走样和锯齿。"}]}]},{"ID":"20240507165845-5yfhm21","Type":"NodeParagraph","Properties":{"id":"20240507165845-5yfhm21","updated":"20240507170222"},"Children":[{"Type":"NodeText","Data":"为了实现这个目标，要么提高像素采样率，要么降低纹理信号频率。上一节的方法方法主要提高了像素采样率。为了更充分解决这个问题我们需要降低纹理频率。所以提出了各种纹理缩小算法。"}]},{"ID":"20240507170223-rz3zqsq","Type":"NodeParagraph","Properties":{"id":"20240507170223-rz3zqsq","updated":"20240507170232"},"Children":[{"Type":"NodeText","Data":"所有纹理抗锯齿算法背后的基本思想都是相同的：对纹理进行预处理，创建某种数据结构，从而快速近似计算一组纹素对像素的影响。"}]},{"ID":"20240507170233-igsq5mg","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240507170233-igsq5mg","updated":"20240510215006"},"Children":[{"Type":"NodeText","Data":"6.2.2.1 Mipmap"}]},{"ID":"20240507170241-tbc4si5","Type":"NodeParagraph","Properties":{"id":"20240507170241-tbc4si5","updated":"20240507170308"},"Children":[{"Type":"NodeText","Data":"在使用mipmap滤波器的时候，在实际渲染发生之前，原始纹理图像会生成一系列较小尺寸的版本。原始纹理（第0级）会被下采样到原始尺寸的四分之一，每个新生成的纹素值，通常为原始纹理中四个相邻纹素的平均值，这个新生成的纹理（第1级）有时也会被叫做原始纹理的子纹理（subtexture）。这个下采样的过程会被递归执行，直到最终生成的某个纹理的维度为1。"}]},{"ID":"20240507170314-clpcbq3","Type":"NodeParagraph","Properties":{"id":"20240507170314-clpcbq3","updated":"20240507170320"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240507170314-qh5ke6w.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"金字塔的底部是原始纹理图像，它对应了mipmap的第0级，将每个 2 × 2 区域内纹素的平均值作为下一级别的mipmap。纵轴是第三个纹理坐标 d ，在这个图中， d 并不是线性的，它用于在两个纹理级别之间进行插值。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240507170321-b8azn2z","Type":"NodeParagraph","Properties":{"id":"20240507170321-b8azn2z","updated":"20240507170331"},"Children":[{"Type":"NodeText","Data":"生成高质量mipmap的两个重要因素分别是：使用良好的过滤和伽马校正。"}]},{"ID":"20240507170344-a8qlqel","Type":"NodeParagraph","Properties":{"id":"20240507170344-a8qlqel","updated":"20240507170347"},"Children":[{"Type":"NodeText","Data":"生成mipmap的常用方法是将每2 × 2的纹素进行平均，从而获得下一级mip所对应的纹素值。"}]},{"ID":"20240507170417-35ky29m","Type":"NodeParagraph","Properties":{"id":"20240507170417-35ky29m","updated":"20240507170421"},"Children":[{"Type":"NodeText","Data":"对于在非线性颜色空间中进行编码的纹理（例如大多数的彩色纹理），在过滤时忽略伽玛校正会修改该层级mipmap的感知亮度[173, 607]。如果使用了未校正的mipmap，相机距离物体越远，物体整体看起来就会越暗，对比度和表面细节也会受到影响。"}]},{"ID":"20240507170422-tf18rma","Type":"NodeParagraph","Properties":{"id":"20240507170422-tf18rma","updated":"20240507170752"},"Children":[{"Type":"NodeText","Data":"由于这个原因，因此将这种纹理（例如颜色纹理）从sRGB颜色空间转换到线性颜色空间是十分重要的（Ref 5.6）。我们会在线性空间中完成mipmap的生成和过滤，然后将生产的结果转换回sRGB颜色空间中并进行存储。"}]},{"ID":"20240507170837-iqoskyt","Type":"NodeParagraph","Properties":{"id":"20240507170837-iqoskyt","updated":"20240507170857"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240507170837-axdcy8h.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"图6.16：左边是一个正方形的像素单元格及其它的纹理视图。右边是这个像素单元格在纹理上的投影。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240507170938-utjhpid","Type":"NodeParagraph","Properties":{"id":"20240507170938-utjhpid","updated":"20240507171325"},"Children":[{"Type":"NodeText","Data":"在纹理化时访问mipmap的过程也很简单。由于屏幕像素占据了纹理中的一个区域，因此当某个像素被投影到纹理上时（如上图"},{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":"）"},{"Type":"NodeText","Data":"，它会包含一个或者多个纹素。这里使用像素单元格的边界并不是严格正确的，使用这种方式只是为了简化表示。"}]},{"ID":"20240507171107-rrcfxep","Type":"NodeParagraph","Properties":{"id":"20240507171107-rrcfxep","updated":"20240507171345"},"Children":[{"Type":"NodeText","Data":"对于第三个纹理坐标"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"d"},{"Type":"NodeText","Data":"，有两种计算方法："}]},{"ID":"20240507171346-ewjt3nc","Type":"NodeList","ListData":{},"Properties":{"id":"20240507171346-ewjt3nc","updated":"20240507171435"},"Children":[{"ID":"20240507171346-5w3zb6z","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240507171346-5w3zb6z","updated":"20240507171346"},"Children":[{"ID":"20240507171346-u4bbsqv","Type":"NodeParagraph","Properties":{"id":"20240507171346-u4bbsqv","updated":"20240507171355"},"Children":[{"Type":"NodeText","Data":"利用像素单元格投影后所形成的四边形，取其中较长的那个边来对像素的覆盖范围进行近似"}]}]},{"ID":"20240507171356-7z3iqyz","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240507171356-7z3iqyz","updated":"20240507171435"},"Children":[{"ID":"20240507171356-mnn73e4","Type":"NodeParagraph","Properties":{"id":"20240507171356-mnn73e4","updated":"20240507171418"},"Children":[{"Type":"NodeText","Data":"方法是使用四个梯度中绝对值最大的那个作为度量，这四个梯度分别是"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\partial u / \\partial x, \\partial v / \\partial x,\\partial u / \\partial y,\\partial v / \\partial y"},{"Type":"NodeText","Data":"​，它们代表了纹理坐标相对于屏幕轴向的变化量"}]},{"ID":"20240507171420-i1kv7on","Type":"NodeBlockquote","Properties":{"id":"20240507171420-i1kv7on","updated":"20240507171435"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240507171421-y2lnfh8","Type":"NodeParagraph","Properties":{"id":"20240507171421-y2lnfh8","updated":"20240507171435"},"Children":[{"Type":"NodeText","Data":"例如"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\partial u / \\partial x"},{"Type":"NodeText","Data":"代表了一个像素所对应的纹理值u，沿着屏幕x轴的变化量。"}]}]}]}]},{"ID":"20240507171419-5bsg457","Type":"NodeParagraph","Properties":{"id":"20240507171419-5bsg457","updated":"20240507171645"},"Children":[{"Type":"NodeText","Data":"计算第三个纹理坐标d的目的是确定沿着mipmap金字塔轴进行采样的层级，我们的目标是使得像素与纹素的比例至少为1:1，以达到Nyquist极限。"}]},{"ID":"20240507171606-h4rayj3","Type":"NodeParagraph","Properties":{"id":"20240507171606-h4rayj3","updated":"20240507171712"},"Children":[{"Type":"NodeText","Data":"这里计算坐标d的重要原则是，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"当一个像素单元格内包含多个纹素时，就需要增大d，从而访问尺寸更小，更模糊的mipmap层级"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240507171712-a63mmi2","Type":"NodeParagraph","Properties":{"id":"20240507171712-a63mmi2","updated":"20240507172132"},"Children":[{"Type":"NodeText","Data":"d类似于纹理级别，但d并不是一个整数值，而是级别之间距离的分数值。我们会对d两侧的miamap分别进行采样，即使用坐标"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"(u, v)"},{"Type":"NodeText","Data":"来从这两个mipmap中分别进行双线性插值，获得两个纹理值。最后按照参数d再对这两个纹理值进行一次线性插值。整个过程被称为三线性插值（trilinear interpolation），并且会逐像素地执行。"}]},{"ID":"20240507172133-hfxbsat","Type":"NodeParagraph","Properties":{"id":"20240507172133-hfxbsat","updated":"20240507172324"},"Children":[{"Type":"NodeText","Data":"用户可以通过"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"细节层次偏移"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"（level of detail bias，LOD bias），来对坐标d进行一定的控制，这是一个加在坐标d上的偏移量，它影响了纹理的相对感知锐度。如果我们将mipmap金字塔向上移动（即增大d），那么纹理会看起来更加模糊。"}]},{"ID":"20240507172206-tgs9165","Type":"NodeParagraph","Properties":{"id":"20240507172206-tgs9165","updated":"20240507172352"},"Children":[{"Type":"NodeText","Data":"对于任何给定的纹理，根据图像类型和使用方式的不同，良好的LOD偏移也是不同的。"}]},{"ID":"20240507172353-s59zq3j","Type":"NodeBlockquote","Properties":{"id":"20240507172353-s59zq3j","updated":"20240507172358"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240507172353-yto8l0y","Type":"NodeParagraph","Properties":{"id":"20240507172353-yto8l0y","updated":"20240507172358"},"Children":[{"Type":"NodeText","Data":"例如：对于有些模糊的第0级mipmap图像，可以使用一个负偏移量；而对于过滤不良（产生锯齿）的纹理图像则可以使用一个正偏移量。"}]}]},{"ID":"20240507172359-abpeibc","Type":"NodeParagraph","Properties":{"id":"20240507172359-abpeibc","updated":"20240507172406"},"Children":[{"Type":"NodeText","Data":"这个偏移量可以针对整个纹理进行指定，也可以在像素着色器中逐像素指定。为了获得更加精细的控制，可以由用户来提供坐标d，或者是提供用于计算它的梯度。"}]},{"ID":"20240507172407-kzr2r98","Type":"NodeParagraph","Properties":{"id":"20240507172407-kzr2r98","updated":"20240507172440"},"Children":[{"Type":"NodeText","Data":"Mipmap的好处是，它并不是去单独计算每个纹素对像素的影响，而是对预先生成的纹素集合进行访问和插值，无论纹理压缩的程度如何，这个过程的时间开销是固定的。"}]},{"ID":"20240507172445-50lo2vd","Type":"NodeParagraph","Properties":{"id":"20240507172445-50lo2vd","updated":"20240507172459"},"Children":[{"Type":"NodeText","Data":"然而Mipmap存在几个缺陷："}]},{"ID":"20240507172459-ewtz46r","Type":"NodeList","ListData":{},"Properties":{"id":"20240507172459-ewtz46r","updated":"20240507172926"},"Children":[{"ID":"20240507172459-v8i2o3j","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240507172459-v8i2o3j","updated":"20240507172926"},"Children":[{"ID":"20240507172459-g1z6ki0","Type":"NodeParagraph","Properties":{"id":"20240507172459-g1z6ki0","updated":"20240507172824"},"Children":[{"Type":"NodeText","Data":"过度模糊"}]},{"ID":"20240507172826-0c1rgmz","Type":"NodeParagraph","Properties":{"id":"20240507172826-0c1rgmz","updated":"20240507172926"},"Children":[{"Type":"NodeText","Data":"假设现在有一个像素单元格，它在u方向上覆盖了大量的纹素，而在v方向上只覆盖了少量的纹素，这种情况通常发生在相机以一个掠射角度来观察纹理表面的时候。在这种情况下，需要沿着纹理的其中一个轴进行缩小，沿着另一个轴进行放大，这会导致像素在纹理上的投影区域是一个长宽比很大的矩形；而我们在访问mipmap时，只能检索纹理上的正方形投影区域，无法检索矩形投影区域。为了避免走样，我们会选择较长的那个边所形成的正方形，来作为对像素单元格覆盖率的近似度量，这导致检索到的样本往往会相对模糊。"}]}]}]},{"ID":"20240507172552-bvotkrk","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240507172552-bvotkrk","updated":"20240510215006"},"Children":[{"Type":"NodeText","Data":"6.2.2.2 SAT表（Summed-Area表）"}]},{"ID":"20240507172956-5h7n1dv","Type":"NodeParagraph","Properties":{"id":"20240507172956-5h7n1dv","updated":"20240507173620"},"Children":[{"Type":"NodeText","Data":"面积积分表（SAT）是另一种能避免过度模糊的方法。"}]},{"ID":"20240507173048-gg0965x","Type":"NodeParagraph","Properties":{"id":"20240507173048-gg0965x","updated":"20240507173620"},"Children":[{"Type":"NodeText","Data":"想要使用这种方法，首先要创建一个尺寸与纹理相同的数组，但是颜色存储的精度要更高（例如：每个红绿蓝颜色分量都会占据16个bit）。"}]},{"ID":"20240507173053-ivn78ug","Type":"NodeParagraph","Properties":{"id":"20240507173053-ivn78ug","updated":"20240507173620"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240507173053-0src3yr.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"像素单元格被反向投影到纹理上，并被一个轴对齐矩形包围盒所包围，这个包围盒的四个角会用于访问SAT。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240507173101-5m2lv7t","Type":"NodeParagraph","Properties":{"id":"20240507173101-5m2lv7t","updated":"20240507173620"},"Children":[{"Type":"NodeText","Data":"在数组中的每个位置上，该位置上的纹素会和(0,0)处的纹素（原点）构成一个矩形，计算并存储区域中所有纹素值的总和。在纹理化的过程中，屏幕上像素在纹理上的投影区域是一个矩形；然后会通过SAT来确定这个矩形区域的平均颜色，并将其作为该像素的纹理颜色。平均颜色计算公式如下："}]},{"ID":"20240507173404-0h39f4o","Type":"NodeMathBlock","Properties":{"id":"20240507173404-0h39f4o","updated":"20240507173620"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\mathbf{c}=\\frac{\\mathbf{s}\\left[x_{u r}, y_{u r}\\right]-\\mathbf{s}\\left[x_{u r}, y_{l l}\\right]-\\mathbf{s}\\left[x_{l l}, y_{u r}\\right]+\\mathbf{s}\\left[x_{l l}, y_{l l}\\right]}{\\left(x_{u r}-x_{l l}\\right)\\left(y_{u r}-y_{l l}\\right)}\n\\tag{6.3}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240507173410-j7kcd2l","Type":"NodeParagraph","Properties":{"id":"20240507173410-j7kcd2l","updated":"20240507173620"},"Children":[{"Type":"NodeText","Data":"图6.14的第三行使用了SAT方法，图像右侧向远处地平线延申的线条变得更加清晰了，但是中间对角相交的线条仍然是很模糊的。原因是"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"当我们沿着对角线观察纹理的时候，像素投影所生成的区域是一个沿对角线的细长矩形，该矩形对应的包围盒中包含了大量无关的纹素"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240507173453-wd7ju85","Type":"NodeBlockquote","Properties":{"id":"20240507173453-wd7ju85","updated":"20240507173620"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240507173500-ymyi0cn","Type":"NodeParagraph","Properties":{"id":"20240507173500-ymyi0cn","updated":"20240507173505"},"Children":[{"Type":"NodeText","Data":"例如：在图6.17中，想象此时像素的投影区域是一个横跨纹理对角线的细长区域，它所对应的包围盒几乎会占据整个纹理，而真正位于像素投影区域内的纹素数量则很少。此时这种方法会对整个纹理矩形进行平均，这个结果包含了大量的无关纹素值，从而导致模糊的产生。"}]}]},{"ID":"20240507173506-6ub1q1o","Type":"NodeParagraph","Properties":{"id":"20240507173506-6ub1q1o","updated":"20240507173620"},"Children":[{"Type":"NodeText","Data":"SAT是各向异性过滤（anisotropic filtering）算法[691]的其中一个例子，这类算法用于检索非正方形投影区域的纹理值，SAT对于接近水平方向或者竖直方向的投影区域最为有效。"}]},{"ID":"20240507173531-xitlw4v","Type":"NodeParagraph","Properties":{"id":"20240507173531-xitlw4v","updated":"20240507173620"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"需要注意的是，对于16 × 16或者尺寸更小的纹理，SAT需要至少两倍的内存；而对于尺寸更大的纹理，则需要更高的存储精度，因为像素值的和会很大，精度过低可能会导致数值溢出。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"}]},{"ID":"20240507173543-jtgdwyq","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240507173543-jtgdwyq","updated":"20240510215006"},"Children":[{"Type":"NodeText","Data":"6.2.23 无约束的各向异性过滤"}]},{"ID":"20240507173634-4eb4k8w","Type":"NodeParagraph","Properties":{"id":"20240507173634-4eb4k8w","updated":"20240507173742"},"Children":[{"Type":"NodeText","Data":"在mipmap中的一个正方形区域进行采样可能采样到许多无关纹素，使表面模糊。这里我们将要介绍的算法，并不是使用单个mipmap采样区域来对该投影形成四边形进行近似，而是会使用多个正方形来进行近似。"}]},{"ID":"20240507173743-ukuiljl","Type":"NodeParagraph","Properties":{"id":"20240507173743-ukuiljl","updated":"20240507174113"},"Children":[{"Type":"NodeText","Data":"我们使用四边形中较短的那个边来确定d的值（而在原始的mipmap中，通常会使用较长的边来确定d），这样做会使得每个mipmap样本的平均面积更小（包含了更少的无关像素，因此会减少模糊的出现）。而四边形的长边则被用来创建一条与其平行，并且穿过四边形中点的"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"各向异性线"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"（line of anisotropy）。当各向异性的比例在1:1和2:1之间时，我们会沿着这条线取两个样本（如图6.18所示）；各向异性的比例越高，沿轴采集的样本就越多。"}]},{"ID":"20240507174045-8mv4mk8","Type":"NodeParagraph","Properties":{"id":"20240507174045-8mv4mk8","updated":"20240507174055"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240507174045-ixoeeof.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"像素单元格的反向投影会形成一个四边形，在较长的边之间构建一条各向异性线。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240507174057-j5xbmao","Type":"NodeParagraph","Properties":{"id":"20240507174057-j5xbmao","updated":"20240507174146"},"Children":[{"Type":"NodeText","Data":"这种方法对各向异性线的方向没有要求，因此它并不会出现类似SAT那样的限制。它只是在mipmap基础上对采样方法进行改进。如下图："}]},{"ID":"20240507174222-2b4kb00","Type":"NodeParagraph","Properties":{"id":"20240507174222-2b4kb00","updated":"20240507174237"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"20230611101334"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/20230611101334-20240507174222-g8tdfm4.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"mipmap和各向异性之间的对比。左侧使用了三线性插值的mipmap，右侧使用了 16:1 的各项异性mipmap。在向地平线延申的方向上，各向异性过滤可以提供更加清晰的结果与最少的锯齿。 "},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240507174417-avoj0h5","Type":"NodeParagraph","Properties":{"id":"20240507174417-avoj0h5","updated":"20240507174427"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240507174417-2jpo32p.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"左: 关闭(1倍显存) / 中: X2 (2倍显存) / 右: X16 (3倍显存)"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240507174425-ey2wn8j","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240507174425-ey2wn8j","updated":"20240510215006"},"Children":[{"Type":"NodeText","Data":"6.2.3 体积纹理"}]},{"ID":"20240507174550-yiv5j1p","Type":"NodeParagraph","Properties":{"id":"20240507174550-yiv5j1p","updated":"20240507174921"},"Children":[{"Type":"NodeText","Data":"对图像纹理直接进行扩展可以得到三维图像数据，它通过坐标(u, v, w)或者(s, t, r)来进行访问。"}]},{"ID":"20240507174922-c1sbp0s","Type":"NodeBlockquote","Properties":{"id":"20240507174922-c1sbp0s","updated":"20240507174927"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240507174924-4fzobrd","Type":"NodeParagraph","Properties":{"id":"20240507174924-4fzobrd","updated":"20240507174927"},"Children":[{"Type":"NodeText","Data":"例如：医学成像数据可以生成三维网格，通过在网格中移动成像平面，可以看到这些数据的二维切片。一个类似的想法是，使用这种数据形式来表示体积光，通过在体积内部找到该位置所对应的值，并结合光照方向，可以计算出表面上一点的光照。"}]}]},{"ID":"20240507174919-2lckwif","Type":"NodeParagraph","Properties":{"id":"20240507174919-2lckwif","updated":"20240507175052"},"Children":[{"Type":"NodeText","Data":"如今大部分GPU都支持体积纹理（volume texture）的mipmap，由于在体积纹理的单个mipmap级别内，需要使用三线性插值来进行过滤，因此在不同mipmap级别之间，需要四线性插值（quadrilinear interpolation）来进行过滤。由于需要对16个纹素的结果进行求平均，因此可能会导致一些精度不足的问题，这可以通过使用更高精度的体积纹理来进行解决。"}]},{"ID":"20240507175028-62ovjwh","Type":"NodeParagraph","Properties":{"id":"20240507175028-62ovjwh","updated":"20240507175118"},"Children":[{"Type":"NodeText","Data":"虽然体积纹理对于存储空间的要求比较高，并且过滤的计算成本也比较高，但它确实具有一些特殊的优势。由于可以直接使用纹理坐标来表示三维的空间位置，因此可以跳过为三维网格寻找一个良好二维参数化表示的复杂过程（UV拆分）。这避免了二维参数化时经常出现的扭曲和接缝问题。体积纹理也可以用来表示木材或者大理石等材质的体积结构，具有这种纹理的模型，看起来就像是使用这种材料雕刻出来的一样。"}]},{"ID":"20240507175129-nh62y1h","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240507175129-nh62y1h","updated":"20240510215006"},"Children":[{"Type":"NodeText","Data":"6.2.4 立方体贴图"}]},{"ID":"20240507175139-u9rpw7c","Type":"NodeParagraph","Properties":{"id":"20240507175139-u9rpw7c","updated":"20240507175150"},"Children":[{"Type":"NodeText","Data":"另一种类型的纹理叫做立方体纹理（cube texture）或者立方体贴图（cube map），它具有六个正方形的纹理，立方体的六个面分别对应了这个六个正方形纹理。访问立方体贴图需要使用一个包含三个分量的纹理坐标向量，这个向量代表了从立方体中心向外发射的射线方向。"}]},{"ID":"20240507175151-25c51n2","Type":"NodeParagraph","Properties":{"id":"20240507175151-25c51n2","updated":"20240507175214"},"Children":[{"Type":"NodeText","Data":"这个射线与立方体交点的计算过程如下：向量中绝对值最大的那个分量，决定了射线会射向哪个立方体表面（例如：向量(- 3.2,5.1,−8.4)代表了射线会射向−z面）。将剩余的两个坐标分量分别除以最大分量的绝对值（即8.4），此时这两个分量的大小位于[-1,1]内，然后再将其重新映射到[0,1]中以计算纹理坐标，例如：坐标(−3.2,5.1)会被映射为((−3.2/8.4 + 1)/2，(5.1/8.4 + 1)/2)≈(0.31,0.80)。"}]},{"ID":"20240507175304-u30o4zz","Type":"NodeParagraph","Properties":{"id":"20240507175304-u30o4zz","updated":"20240507175308"},"Children":[{"Type":"NodeText","Data":"立方体贴图对于表示方向函数的值而言非常有用；它们最常用于环境映射中（Ref 10.4.3）。"}]},{"ID":"20240507175307-qd0ew5y","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240507175307-qd0ew5y","updated":"20240510215006"},"Children":[{"Type":"NodeText","Data":"6.2.5 纹理表示"}]},{"ID":"20240507175316-yjhbjs3","Type":"NodeParagraph","Properties":{"id":"20240507175316-yjhbjs3","updated":"20240507175332"},"Children":[{"Type":"NodeText","Data":"本小节的重点则是纹理图集（texture atlas），纹理数组（texture array）以及无绑定的纹理（bindless textures），所有这些技术的目的都是为了在渲染过程中避免纹理的切换，因为切换纹理是有一些额外开销的。"}]},{"ID":"20240507175439-owm7t4g","Type":"NodeParagraph","Properties":{"id":"20240507175439-owm7t4g","updated":"20240507175450"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240507175439-euxaqzm.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"左图：纹理图集，其中9个较小的图像被组合为一个大纹理。右图：一种更加现代的方法是将较小的图像设置为纹理数组，大多数现代API中都有类似的概念。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240507175450-d2as2d6","Type":"NodeParagraph","Properties":{"id":"20240507175450-d2as2d6","updated":"20240507175737"},"Children":[{"Type":"NodeText","Data":"为了能够使得GPU批量处理尽可能多的任务，一般来说最好尽可能地避免改变它的状态（章节18.4.2）。为此，可以将多个图像放入一个尺寸更大的纹理中，这个纹理被叫做纹理图集，如上图左侧所示。"}]},{"ID":"20240507175800-r7g66sw","Type":"NodeParagraph","Properties":{"id":"20240507175800-r7g66sw","updated":"20240507175800"},"Children":[{"Type":"NodeText","Data":"当使用 wrapping/repeat或者mirror模式的时候，是无法使用纹理图集的，因为这些模式会对整个纹理产生影响，导致我们无法对子纹理进行正确的设置。"}]},{"ID":"20240507175801-f4645dw","Type":"NodeParagraph","Properties":{"id":"20240507175801-f4645dw","updated":"20240507175822"},"Children":[{"Type":"NodeText","Data":"另一个问题发生在为图集生成mipmap时，图集中的子纹理可能会与另一个子纹理相互混合。当然这个问题也有对应的解决方案，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"可以将子纹理的分辨率设置为2的整数次幂，然后在将每个子纹理放入纹理图集之前，提前为它们生成mipmap层次结构"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240507175816-6tayh43","Type":"NodeParagraph","Properties":{"id":"20240507175816-6tayh43","updated":"20240507175840"},"Children":[{"Type":"NodeText","Data":"对于上述的这些问题，一个更简单的解决方案是使用一种被称为纹理数组（texture array）的API结构，它完全避免了mipmap和repeat模式所带来的问题[452]，如上图右侧所示。"}]},{"ID":"20240507175836-5ktvij0","Type":"NodeParagraph","Properties":{"id":"20240507175836-5ktvij0","updated":"20240507175919"},"Children":[{"Type":"NodeText","Data":"一个纹理数组中的所有子纹理都需要具有相同的尺寸、格式、mipmap层次结构和MSAA设置。与纹理图集一样，纹理数组只需要进行一次设置，然后就可以通过着色器中的索引来访问数组中的任何元素，这种方法要比分别绑定每个子纹理快5倍。"}]},{"ID":"20240507175919-5mfh03k","Type":"NodeParagraph","Properties":{"id":"20240507175919-5mfh03k","updated":"20240507180017"},"Children":[{"Type":"NodeText","Data":"现代图形API对于"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"无绑定纹理（bindless texture）"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"的支持，也有助于避免状态切换所带来的额外开销。"}]},{"ID":"20240507180011-wet3so1","Type":"NodeParagraph","Properties":{"id":"20240507180011-wet3so1","updated":"20240507180011"},"Children":[{"Type":"NodeText","Data":"如果没有无绑定纹理的话，则需要使用API来将纹理绑定到特定的纹理单元中，这会带来很多问题，其中一个问题是纹理单元数量的是有上限的，这使得程序员的工作变得更加复杂。"}]},{"ID":"20240507180018-e5fxu0e","Type":"NodeParagraph","Properties":{"id":"20240507180018-e5fxu0e","updated":"20240507180032"},"Children":[{"Type":"NodeText","Data":"对于无绑定纹理而言，纹理的使用数量是没有上限的，因为每个纹理都只通过一个64位的指针（有时称为句柄handle）来与其数据结构相关联。"}]},{"ID":"20240507180038-gz98j0o","Type":"NodeParagraph","Properties":{"id":"20240507180038-gz98j0o","updated":"20240507180048"},"Children":[{"Type":"NodeText","Data":"可以通过多种方式来访问这些句柄，例如通过uniform buffer、可变数据、其他纹理，以及着色器存储缓冲对象（shader storage buffer object，SSBO）等。"}]},{"ID":"20240507180054-g2sawnk","Type":"NodeParagraph","Properties":{"id":"20240507180054-g2sawnk","updated":"20240507180054"},"Children":[{"Type":"NodeText","Data":"应用程序需要确保纹理驻留在GPU端。无绑定纹理避免了驱动程序中任何类型的绑定开销，这使得渲染速度更快。"}]},{"ID":"20240507180056-wez3ttg","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240507180056-wez3ttg","updated":"20240510215006"},"Children":[{"Type":"NodeText","Data":"6.2.6 纹理压缩"}]},{"ID":"20240507180101-ca5s6jz","Type":"NodeParagraph","Properties":{"id":"20240507180101-ca5s6jz","updated":"20240507181246"},"Children":[{"Type":"NodeText","Data":"固定压缩比的纹理压缩（fixed-rate texture compression）是一种直接解决内存、带宽以及缓存问题的解决方案。通过让GPU对纹理进行实时的解码压缩，能够使得纹理占据更少的内存，从而增加有效的缓存大小。同样重要的是，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"这样的纹理使用起来会更加高效，因为在访问纹理时，对于内存带宽的开销变少了。能够对纹理进行压缩，也意味着能够支持更大尺寸的纹理"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240507180150-yc61g1q","Type":"NodeBlockquote","Properties":{"id":"20240507180150-yc61g1q","updated":"20240507181246"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240507180150-1o8o0hh","Type":"NodeParagraph","Properties":{"id":"20240507180150-1o8o0hh","updated":"20240507180204"},"Children":[{"Type":"NodeText","Data":"例如：在"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"512\\times512"},{"Type":"NodeText","Data":"的分辨率下，每个纹素使用3个字节的未压缩纹理将会占用768 kB空间；而在使用纹理压缩之后（例如压缩比为6:1），一个"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"1024\\times 1024"},{"Type":"NodeText","Data":"尺寸的纹理也只需要512 kB的空间。"}]}]},{"ID":"20240507180154-hkygn72","Type":"NodeParagraph","Properties":{"id":"20240507180154-hkygn72","updated":"20240507181246"},"Children":[{"Type":"NodeText","Data":"DXTC是DirectX的标准纹理压缩方法，因为几乎所有GPU都支持这种纹理压缩方法。"}]},{"ID":"20240507180307-56vxi37","Type":"NodeParagraph","Properties":{"id":"20240507180307-56vxi37","updated":"20240507181246"},"Children":[{"Type":"NodeText","Data":"这种方法的优点在于，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"可以创建大小固定的压缩图像，具有独立编码的片段，并且解码过程十分简单（因此速度很快）"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240507180346-xauj14q","Type":"NodeParagraph","Properties":{"id":"20240507180346-xauj14q","updated":"20240507181246"},"Children":[{"Type":"NodeText","Data":"图像的每个压缩部分都可以被单独解码，没有共享查找表或者其他依赖关系，这简化了解码过程。"}]},{"ID":"20240507180347-kae0u4n","Type":"NodeParagraph","Properties":{"id":"20240507180347-kae0u4n","updated":"20240507181246"},"Children":[{"Type":"NodeText","Data":"DXTC/BC压缩方案有七种变体，它们之间有一些共同的特性。这种压缩方案的编码是在4 × 4范围内的纹素块上（也称为tile）上完成的，每个纹素块都可以进行单独编码；这个编码过程是基于插值的，对于每个编码量，会存储两个参考值（即颜色）。它会在两个参考值之间所构成的直线上选择一个值，即在两个参考颜色之间进行插值。这种压缩方案最终只会存储两个参考颜色，以及每个像素的短索引值。"}]},{"ID":"20240507180421-y4wlml5","Type":"NodeParagraph","Properties":{"id":"20240507180421-y4wlml5","updated":"20240507181246"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240507180421-cjrsfzn.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"不同的纹理压缩格式。表中的所有压缩方法都作用于 4 \\times 4 的纹素块上。表中的Storage列代表了最终存储所占据的空间，其中前面的是每个纹素块的所占据的字节数（byte，B），后面的是每个纹素所占据的bit数（bits per texel，bpt）。在Ref colors列中，前面的英文符号代表具体的通道情况，后面的数字代表了每个通道所占据的bit数。例如：RGB565代表了红色通道有5个bit，蓝色通道有6个bit，绿色通道有5个bit。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240507180434-lq81bxq","Type":"NodeBlockquote","Properties":{"id":"20240507180434-lq81bxq","updated":"20240507181246"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240507180532-4zqhhqq","Type":"NodeParagraph","Properties":{"id":"20240507180532-4zqhhqq","updated":"20240507180535"},"Children":[{"Type":"NodeText","Data":"另一种DXT1模式为透明像素保留了四个可能的插值因子中的一个，此时由于alpha值的存在，可能的像素颜色数量会被限制为三个——两个参考值及其平均值。"}]}]},{"ID":"20240507180536-kvbthjr","Type":"NodeParagraph","Properties":{"id":"20240507180536-kvbthjr","updated":"20240507181246"},"Children":[{"Type":"NodeText","Data":"这些压缩方案的主要缺点在于，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"它们都是有损压缩，也就是说，通常我们无法从压缩纹理中还原出原始图像"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。在实际应用中，如果使用得当，这些压缩方案通常可以提供可接受的图像保真度。"}]},{"ID":"20240507180606-3kla1d0","Type":"NodeParagraph","Properties":{"id":"20240507180606-3kla1d0","updated":"20240507181246"},"Children":[{"Type":"NodeText","Data":"OpenGL ES选择了另一种压缩算法，被称为Ericsson纹理压缩（Ericsson texture compression，ETC），这种压缩算法被内置在API中。"}]},{"ID":"20240507180634-udlmmsd","Type":"NodeParagraph","Properties":{"id":"20240507180634-udlmmsd","updated":"20240507181246"},"Children":[{"Type":"NodeText","Data":"它将4×4的纹素块编码为64 bit，即每个像素使用4 bit，其基本思想如图6.21所示。每2 × 4块（或者4 × 2，取决于哪个的质量最好）会存储一个基色（base color）。每个纹素块还会从一个很小的静态查找表中选择四个常量，纹素块中的每个纹素，都可以选择机上其中的一个值，这会逐像素的修改其亮度值。这种压缩算法的图像质量与DXTC相当。"}]},{"ID":"20240507180703-6fp9jxd","Type":"NodeParagraph","Properties":{"id":"20240507180703-6fp9jxd","updated":"20240507181246"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240507180703-pwtlo6s.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"ETC压缩方法会对像素块的颜色进行编码，然后通过逐像素的亮度修改来获得最终的纹理颜色。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240507180659-wyq7fff","Type":"NodeParagraph","Properties":{"id":"20240507180659-wyq7fff","updated":"20240507181246"},"Children":[{"Type":"NodeText","Data":"对于法线贴图（将在章节6.7.2中进行讨论）的压缩需要注意一些问题，因为针对RGB颜色进行设计的压缩格式，通常并不适用于法线的xyz数据。大多数法线贴图的存储方法，都会利用已知法线为单位长度这个事实，并"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"进一步假设其z分量为正"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"（对于切线空间法线而言，这是一个合理的假设）。因此可以只存储"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"x和y"},{"Type":"NodeText","Data":"分量，运行时计算"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"z"},{"Type":"NodeText","Data":"："}]},{"ID":"20240507180818-kmo0hen","Type":"NodeMathBlock","Properties":{"id":"20240507180818-kmo0hen","updated":"20240507181246"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"n_{z}=\\sqrt{1-n_{x}^{2}-n_{y}^{2}}\n\\tag{6.4}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240507180745-p8m2qvn","Type":"NodeParagraph","Properties":{"id":"20240507180745-p8m2qvn","updated":"20240507181246"},"Children":[{"Type":"NodeText","Data":"由于大多数GPU并不原生支持三分量的纹理，一般只会原生支持四分量的纹理，但是这样的话就会浪费一个分量；而将三分量法线转换为两分量进行存储，就可以避免对第四个分量空间的浪费。"}]},{"ID":"20240507180859-aq9deew","Type":"NodeParagraph","Properties":{"id":"20240507180859-aq9deew","updated":"20240507181246"},"Children":[{"Type":"NodeText","Data":"对x分量和y分量的进一步压缩，通常是使用BC5或者3Dc格式来实现的，如图6.22所示。"}]},{"ID":"20240507180918-rhpvq5f","Type":"NodeParagraph","Properties":{"id":"20240507180918-rhpvq5f","updated":"20240507181246"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240507180918-vsa3oy2.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"球面上的单位法线只需要编码 x 分量和 y 分量即可。右侧：对于BC4/3Dc， xy 平面上的一个轴对齐包围盒限制了法线的范围，每个 4 × 4 的纹素块可以在这个 8 × 8 网格中选择法线（为了清晰，这里只显示 4 × 4 法线）。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240507180932-bdihrie","Type":"NodeParagraph","Properties":{"id":"20240507180932-bdihrie","updated":"20240507181246"},"Children":[{"Type":"NodeText","Data":"剩余部分请参见原文。因为纹理压缩并不是我想重点了解的内容。"}]},{"ID":"20240507181042-8yf4df4","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240507181042-8yf4df4","updated":"20240510215006"},"Children":[{"Type":"NodeText","Data":"6.3 程序化纹理"}]},{"ID":"20240507181223-fgyo31c","Type":"NodeParagraph","Properties":{"id":"20240507181223-fgyo31c","updated":"20240507181324"},"Children":[{"Type":"NodeText","Data":"都是给定一个纹理空间中的坐标位置，然后在图像中进行查找，从而获得纹理值。还有一种方法是"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"对函数进行求值，然后作为对应位置上的纹理值，这就是程序化纹理"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"（procedural texture）。"}]},{"ID":"20240507181324-zfnch41","Type":"NodeParagraph","Properties":{"id":"20240507181324-zfnch41","updated":"20240507181337"},"Children":[{"Type":"NodeText","Data":"程序化纹理通常运用于离线渲染中，在实时渲染中更加常见的则是图像纹理，这是因为现代GPU中的图像纹理硬件是非常高效的，可以在一秒钟内执行数十亿次的纹理访问操作。"}]},{"ID":"20240507181358-ijit7lr","Type":"NodeBlockquote","Properties":{"id":"20240507181358-ijit7lr","updated":"20240507181405"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240507181402-5gp65t7","Type":"NodeParagraph","Properties":{"id":"20240507181402-5gp65t7","updated":"20240507181405"},"Children":[{"Type":"NodeText","Data":"然而，目前的GPU架构正在向着更低的计算成本，以及更昂贵（相对）的存储访问发展，也就是说，存储访问和带宽限制越来越成为GPU的性能瓶颈。这些趋势使得程序化纹理在实时渲染中得到了更加广泛的应用。"}]}]},{"ID":"20240507181406-mwux791","Type":"NodeParagraph","Properties":{"id":"20240507181406-mwux791","updated":"20240507181539"},"Children":[{"Type":"NodeText","Data":"最为常见的一种应用是，使用"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"一个或者多个噪声函数来生成纹理值，"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"如图6.24所示"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"20230611101612"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/20230611101612-20240507181512-b0q0d04.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"两个使用的实时程序化纹理生成的体积纹理。左边的大理石是使用光线步进（ray marching）渲染的半透明体积纹理。右边的物体是使用复杂的程序化木材着色器 \\[1054\\] 生成的图像，并将其在“真实”环境（背景）中进行了渲染。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240507181602-z116bsm","Type":"NodeParagraph","Properties":{"id":"20240507181602-z116bsm","updated":"20240507181602"},"Children":[{"Type":"NodeText","Data":"由于计算噪声函数的成本较大，因此三维数组中的点通常都是预先计算好的，并使用这些点进行插值从而获得相应的纹理值。"}]},{"ID":"20240507181653-ggdzk9r","Type":"NodeParagraph","Properties":{"id":"20240507181653-ggdzk9r","updated":"20240507181653"},"Children":[{"Type":"NodeText","Data":"其他的程序化方法也是可行的。"}]},{"ID":"20240507181658-k0h8htq","Type":"NodeList","ListData":{},"Properties":{"id":"20240507181658-k0h8htq","updated":"20240507181705"},"Children":[{"ID":"20240507181658-0v1t4ej","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240507181658-0v1t4ej","updated":"20240507181658"},"Children":[{"ID":"20240507181658-9keqlbe","Type":"NodeParagraph","Properties":{"id":"20240507181658-9keqlbe","updated":"20240507181658"},"Children":[{"Type":"NodeText","Data":"例如：通过测量从每个位置到一组“特征点”（分散在空间中）的距离，来构建蜂窝状纹理（cellular texture）。"}]}]},{"ID":"20240507181705-s0xboz1","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240507181705-s0xboz1","updated":"20240507181705"},"Children":[{"ID":"20240507181705-rgqwqd0","Type":"NodeParagraph","Properties":{"id":"20240507181705-rgqwqd0","updated":"20240507181705"},"Children":[{"Type":"NodeText","Data":"还可以用不同的方法对这些生成的最近距离进行映射，例如：改变颜色或者着色法线，从而生成看起来像细胞、石板、蜥蜴皮肤以及其他自然图案的纹理。"}]}]}]},{"ID":"20240507181716-cr8ulqg","Type":"NodeParagraph","Properties":{"id":"20240507181716-cr8ulqg","updated":"20240507181716"},"Children":[{"Type":"NodeText","Data":"另一种类型的程序化纹理是物理模拟或者其他交互过程的结果，例如水面波纹或者扩展裂缝。在这种情况下，程序化纹理可以根据动态条件的不同，有效地生产无限种变化。"}]},{"ID":"20240507181731-r09afv2","Type":"NodeParagraph","Properties":{"id":"20240507181731-r09afv2","updated":"20240507181741"},"Children":[{"Type":"NodeText","Data":"当生成一个程序化的二维纹理时，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"参数化问题（UV）可能要比创建纹理更加困难，因为在传统的纹理制作过程中，可以对UV拉伸或者UV接缝进行手动调整，而程序化纹理则不行。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"}]},{"ID":"20240507181741-nd2fs5t","Type":"NodeParagraph","Properties":{"id":"20240507181741-nd2fs5t","updated":"20240507181748"},"Children":[{"Type":"NodeText","Data":"对程序化纹理的抗锯齿处理，要比图像纹理的抗锯齿既困难和又容易。"}]},{"ID":"20240507181839-n0nzc2c","Type":"NodeList","ListData":{},"Properties":{"id":"20240507181839-n0nzc2c","updated":"20240507181855"},"Children":[{"ID":"20240507181840-lfm272s","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240507181840-lfm272s","updated":"20240507181840"},"Children":[{"ID":"20240507181840-ncq6ngp","Type":"NodeParagraph","Properties":{"id":"20240507181840-ncq6ngp","updated":"20240507181847"},"Children":[{"Type":"NodeText","Data":"一方面，类似mipmap这样的预计算方法是不可行的，这会给程序员带来极大的负担。"}]}]},{"ID":"20240507181848-0ykq3ak","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240507181848-0ykq3ak","updated":"20240507181855"},"Children":[{"ID":"20240507181848-w0gafvy","Type":"NodeParagraph","Properties":{"id":"20240507181848-w0gafvy","updated":"20240507181855"},"Children":[{"Type":"NodeText","Data":"另一方面，在生成程序化纹理的时候，我们实际上已经知道了有关于纹理内容的“内部信息”，因此可以对其进行调整，从而避免锯齿现象。"}]}]}]},{"ID":"20240507181856-5xn62ud","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240507181856-5xn62ud","updated":"20240510215006"},"Children":[{"Type":"NodeText","Data":"6.4 纹理动画"}]},{"ID":"20240507181937-80gl151","Type":"NodeParagraph","Properties":{"id":"20240507181937-80gl151","updated":"20240507182021"},"Children":[{"Type":"NodeText","Data":"应用于表面上的图像纹理也不一定是静态的。"}]},{"ID":"20240507182022-wgh5mt0","Type":"NodeBlockquote","Properties":{"id":"20240507182022-wgh5mt0","updated":"20240507182025"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240507182022-2pmxqtd","Type":"NodeParagraph","Properties":{"id":"20240507182022-2pmxqtd","updated":"20240507182025"},"Children":[{"Type":"NodeText","Data":"例如：视频源（video source）可以用作一种随帧变化的特殊纹理。"}]}]},{"ID":"20240507182059-qmpdach","Type":"NodeParagraph","Properties":{"id":"20240507182059-qmpdach","updated":"20240507182100"},"Children":[{"Type":"NodeText","Data":"纹理坐标也不一定是静态的。无论是在网格数据本身对纹理坐标进行修改，还是通过顶点着色器或者像素着色器中的函数，来对纹理坐标进行修改，应用程序设计人员都可以显式地改变帧与帧之间的纹理坐标。"}]},{"ID":"20240507182108-qpakmw3","Type":"NodeBlockquote","Properties":{"id":"20240507182108-qpakmw3","updated":"20240507182136"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240507182109-i3aicw8","Type":"NodeParagraph","Properties":{"id":"20240507182109-i3aicw8","updated":"20240507182136"},"Children":[{"Type":"NodeText","Data":"想象一下，现在我们有了一个已经建模好的瀑布模型，并且它已经被一个图像纹理化了，使得它看起来很像瀑布。假设纹理坐标v是水流的方向，为了让水流动起来，必须从每一帧的坐标v中减去一定的数值。纹理坐标的减法操作会使得纹理本身看起来正在向前移动。"}]}]},{"ID":"20240507182106-jg6qbtl","Type":"NodeParagraph","Properties":{"id":"20240507182106-jg6qbtl","updated":"20240507182221"},"Children":[{"Type":"NodeText","Data":"可以通过对纹理坐标应用变换矩阵来生成更加精细的效果。除了平移之外，它还允许其他的线性变换操作，例如缩放、旋转和剪切[1192, 1904]，图像扭曲（image warping）和变形转换（morphing transforms）[1729]，以及广义投影[638]等。通过在CPU或者着色器中应用变换函数，可以生成更复杂的效果。"}]},{"ID":"20240507182207-4g5p2p1","Type":"NodeParagraph","Properties":{"id":"20240507182207-4g5p2p1","updated":"20240507182226"},"Children":[{"Type":"NodeText","Data":"通过使用纹理混合（texture blending）技术，还可以实现其他的动画效果。"}]},{"ID":"20240507182227-bfql7io","Type":"NodeBlockquote","Properties":{"id":"20240507182227-bfql7io","updated":"20240507182230"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240507182227-fm4ynir","Type":"NodeParagraph","Properties":{"id":"20240507182227-fm4ynir","updated":"20240507182230"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"例如：从一个大理石纹理出发，将其渐变为一个肉质纹理，从而使得雕像看起来像是活过来一样"},{"Type":"NodeText","Data":"["},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"1215]。"}]}]},{"ID":"20240507182230-2dystn0","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240507182230-2dystn0","updated":"20240510215006"},"Children":[{"Type":"NodeText","Data":"6.5 材质映射"}]},{"ID":"20240507182235-fpf8s0q","Type":"NodeParagraph","Properties":{"id":"20240507182235-fpf8s0q","updated":"20240507182258"},"Children":[{"Type":"NodeText","Data":"纹理的一个常见用途是对材质属性进行修改，从而影响着色方程的计算结果。"}]},{"ID":"20240507182300-x0e76qc","Type":"NodeParagraph","Properties":{"id":"20240507182300-x0e76qc","updated":"20240507182304"},"Children":[{"Type":"NodeText","Data":"现实世界中的物体通常都会具有不同的表面材质属性，为了模拟这样的物体，像素着色器可以从纹理中读取纹理值，并在计算着色方程之前，使用它们来修改材质的参数。"}]},{"ID":"20240507182305-4ro70qx","Type":"NodeParagraph","Properties":{"id":"20240507182305-4ro70qx","updated":"20240507182311"},"Children":[{"Type":"NodeText","Data":"纹理最常修改的参数就是表面是颜色，这种纹理通常被称为反照率颜色贴图（albedo color map）或者漫反射颜色贴图（diffuse color map）。"}]},{"ID":"20240507182321-vmrqeb6","Type":"NodeParagraph","Properties":{"id":"20240507182321-vmrqeb6","updated":"20240507182323"},"Children":[{"Type":"NodeText","Data":"但是，理论上任何参数都可以被纹理进行修改，例如：替换、相乘或者以其他方式等。如下图"}]},{"ID":"20240507182334-qm2ermw","Type":"NodeParagraph","Properties":{"id":"20240507182334-qm2ermw","updated":"20240507182340"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"20230611101629"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/20230611101629-20240507182334-dfdtq7c.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"金属砖块和灰浆材质。右边的纹理分别代表了表面颜色、粗糙度（越亮越粗糙）和凹凸高度（越亮起伏程度越大）。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240507182345-23oh8qd","Type":"NodeParagraph","Properties":{"id":"20240507182345-23oh8qd","updated":"20240507182406"},"Children":[{"Type":"NodeText","Data":"材质的纹理还有更加广泛的用途。纹理还可以用来控制像素着色器本身的流程以及函数功能，而不是简单地修改着色方程中的参数。具有不同着色方程和参数的多个材质，可以同时被应用于一个表面上，通过使用一个特殊纹理，来指定表面的哪些区域具有哪些材质，从而在每个区域上执行不同的着色代码。"}]},{"ID":"20240507182406-lpoadcd","Type":"NodeBlockquote","Properties":{"id":"20240507182406-lpoadcd","updated":"20240507182413"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240507182407-ancy4s3","Type":"NodeParagraph","Properties":{"id":"20240507182407-ancy4s3","updated":"20240507182413"},"Children":[{"Type":"NodeText","Data":"例如：在具有生锈区域的金属表面上，可以使用一个特殊贴图来指示生锈的位置，根据纹理查找的结果，来决定是执行生锈着色器还是执行闪亮的金属着色器（章节9.5.2）。"}]}]},{"ID":"20240507182414-14idltp","Type":"NodeParagraph","Properties":{"id":"20240507182414-14idltp","updated":"20240507182450"},"Children":[{"Type":"NodeText","Data":"着色模型中的一些输入参数（例如表面颜色），与着色器的最终颜色输出具有线性关系。"}]},{"ID":"20240507182454-rpe5c6q","Type":"NodeParagraph","Properties":{"id":"20240507182454-rpe5c6q","updated":"20240507182503"},"Children":[{"Type":"NodeText","Data":"对于包含非线性着色输入参数的纹理而言，例如粗糙度或者凹凸贴图（章节6.7），则需要更多的注意和处理，来避免锯齿和走样的出现。（Ref 9.13）"}]},{"ID":"20240507182503-7pf9gi0","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240507182503-7pf9gi0","updated":"20240510215006"},"Children":[{"Type":"NodeText","Data":"6.6 Alpha映射"}]},{"ID":"20240507182511-08eq4s3","Type":"NodeParagraph","Properties":{"id":"20240507182511-08eq4s3","updated":"20240510214222"},"Children":[{"Type":"NodeText","Data":"本小节将讨论如何使用带有alpha通道的纹理，以及这些方法的各种限制和对应的解决方案。"}]},{"ID":"20240510214223-m2ic42a","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240510214223-m2ic42a","updated":"20240510215006"},"Children":[{"Type":"NodeText","Data":"6.6.1 贴花（decal）"}]},{"ID":"20240510214244-96qh6ga","Type":"NodeParagraph","Properties":{"id":"20240510214244-96qh6ga","updated":"20240510214316"},"Children":[{"Type":"NodeText","Data":"例如：假设我们想在茶壶上放置一张花的图片，我们并不需要花的整个画面，只需要花所在的部分即可；"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"对于那些不包含花的纹素，我们可以将它的alpha值设为0，使这些部分变得透明"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"，这样它就没有任何效果了。"}]},{"ID":"20240510214317-zqb2lcx","Type":"NodeParagraph","Properties":{"id":"20240510214317-zqb2lcx","updated":"20240510214401"},"Children":[{"Type":"NodeText","Data":"因此，通过正确设置贴花纹理的alpha值，我们可以使用贴花纹理来替换对应的底层表面，或者将二者混合。通常，我们可以使用一个clamp转换函数与透明边框，将贴花的单个副本（相对于重复纹理）应用到表面上。"}]},{"ID":"20240510214407-gy3l1a5","Type":"NodeParagraph","Properties":{"id":"20240510214407-gy3l1a5","updated":"20240510214415"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240510214407-tejz9qx.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"实现贴花的一种方法。首先使用场景来渲染一个帧缓冲，然后再渲染一个box，对于box内的所有顶点，贴花纹理会被投影到帧缓冲上。box中最左侧的纹素是完全透明的，因此它不会影响帧缓冲；box中的黄色纹素是不可见的，因为它会被投影到表面的隐藏部分。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240510214416-fp1qka7","Type":"NodeParagraph","Properties":{"id":"20240510214416-fp1qka7","updated":"20240510214521"},"Children":[{"Type":"NodeText","Data":"细节见：Ref: 20.2"}]},{"ID":"20240510214601-678hvio","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240510214601-678hvio","updated":"20240510215006"},"Children":[{"Type":"NodeText","Data":"6.6.2 镂空"}]},{"ID":"20240510214610-dcj13t8","Type":"NodeParagraph","Properties":{"id":"20240510214610-dcj13t8","updated":"20240510214640"},"Children":[{"Type":"NodeText","Data":"alpha值的另一个类似应用是制作镂空（cutout）效果。假设我们制作了一个灌木的贴花图像，并将其应用到场景中的一个矩形上。"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"这个原理和贴花是相同的，不同之处在于，这个灌木图像并不是和底层表面对应的，而是会绘制在它背后的任何几何图形上。通过这种方式，可以仅仅使用单个矩形，便能够渲染出具有复杂轮廓的物体"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240510214654-a38wrwh","Type":"NodeParagraph","Properties":{"id":"20240510214654-a38wrwh","updated":"20240510214717"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240510214654-0gnljai.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"左边是灌木纹理贴图及其对应的1 bit alpha通道贴图。右边是灌木贴图渲染在单个矩形上的效果；通过添加旋转90度的第二个矩形副本，可以创建一个廉价的三维灌木丛。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240510214717-3mowi3j","Type":"NodeParagraph","Properties":{"id":"20240510214717-3mowi3j","updated":"20240510214925"},"Children":[{"Type":"NodeText","Data":"在这个灌木的例子中，如果观察者围绕它进行旋转，这个视觉错觉就会露陷，因为这个灌木矩形实际上并没有厚度。"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"一种解决方案是将这个灌木矩形复制一份，并沿着树干旋转90度，使得两个灌木矩形相互垂直"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。这两个矩形构成了一个廉价的三维灌木效果，它有时会被称为“交叉树”，从地面上进行观察的时候，这种视错觉是相当有效的，如上图所示。"}]},{"ID":"20240510214830-az0260k","Type":"NodeParagraph","Properties":{"id":"20240510214830-az0260k","updated":"20240510214842"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240510214830-qffdd4l.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"从离开地面一点的地方来观察这个“交叉树”灌木，这种视错觉就消失了。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240510214844-cl77lbo","Type":"NodeParagraph","Properties":{"id":"20240510214844-cl77lbo","updated":"20240510214922"},"Children":[{"Type":"NodeText","Data":"如果观众移动到地面以上，那么这种视错觉也会露陷，因为在灌木上面可以看到两个明显切口，如上图。可以使用不同方式来添加更多的镂空纹理，从而提供更令人信服的模型。"}]},{"ID":"20240510214947-a3tksz8","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240510214947-a3tksz8","updated":"20240510215006"},"Children":[{"Type":"NodeText","Data":"6.6.3 其他"}]},{"ID":"20240510215002-euxdr53","Type":"NodeParagraph","Properties":{"id":"20240510215002-euxdr53","updated":"20240510215006"},"Children":[{"Type":"NodeText","Data":"将alpha贴图和纹理动画结合在一起，可以产生令人信服的特殊效果，例如闪烁的火炬，植物生长，爆炸和大气效果等。"}]},{"ID":"20240510215014-hr9w2pg","Type":"NodeParagraph","Properties":{"id":"20240510215014-hr9w2pg","updated":"20240510215032"},"Children":[{"Type":"NodeText","Data":"使用alpha贴图来渲染物体有几个可选的方式。"}]},{"ID":"20240510215036-s349fpa","Type":"NodeList","ListData":{},"Properties":{"id":"20240510215036-s349fpa","updated":"20240510221653"},"Children":[{"ID":"20240510215037-0rctcfq","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240510215037-0rctcfq","updated":"20240510215037"},"Children":[{"ID":"20240510215037-mp6s0sl","Type":"NodeParagraph","Properties":{"id":"20240510215037-mp6s0sl","updated":"20240510215043"},"Children":[{"Type":"NodeText","Data":"alpha混合（章节5.5）允许透明度值为小数，从而实现了物体边缘的抗锯齿，以及部分透明物体的渲染。但是"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"alpha混合需要在渲染不透明三角形之后，再去渲染透明的三角形，并且需要严格按照从后向前的顺序进行渲染"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240510215045-acp9vnt","Type":"NodeParagraph","Properties":{"id":"20240510215045-acp9vnt","updated":"20240510215128"},"Children":[{"Type":"NodeText","Data":"这种方式无法实现刚才提到的简单交叉树。因为它包含两个镂空纹理，这个例子中没有任何一个渲染顺序是正确的。因为两个四边形相互交叉。"}]}]},{"ID":"20240510215156-2gu8vvd","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240510215156-2gu8vvd"},"Children":[{"ID":"20240510215156-jhtuzec","Type":"NodeParagraph","Properties":{"id":"20240510215156-jhtuzec","updated":"20240510215208"},"Children":[{"Type":"NodeText","Data":"使用alpha测试可以改善这个问题，做法如下："}]},{"ID":"20240510215208-v4r7u1o","Type":"NodeMathBlock","Properties":{"id":"20240510215208-v4r7u1o","updated":"20240510215221"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\mathrm{if (texture.a \u003c alphaThreshold) \\quad discard}\n\\tag{6.9}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240510215223-zgfiuo8","Type":"NodeParagraph","Properties":{"id":"20240510215223-zgfiuo8","updated":"20240510215253"},"Children":[{"Type":"NodeText","Data":"其中"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathrm{texture.a}"},{"Type":"NodeText","Data":"代表了从纹理中检索到的对应"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"alpha"},{"Type":"NodeText","Data":"值，参数"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathrm{alphaThreshold}"},{"Type":"NodeText","Data":"是用户提供的阈值，它将决定哪些片元会被丢弃。"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"这个二元的可见性测试允许以任意顺序来渲染三角形，因为透明的片元都会被丢弃"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240510215310-h349ark","Type":"NodeParagraph","Properties":{"id":"20240510215310-h349ark","updated":"20240510215320"},"Children":[{"Type":"NodeText","Data":"将完全透明的片元直接丢弃还有额外的好处，它节省了后续着色器处理和合并的计算成本，同时还可以避免将z-buffer中的像素错误地标记为可见。"}]},{"ID":"20240510215333-9a3abv4","Type":"NodeBlockquote","Properties":{"id":"20240510215333-9a3abv4","updated":"20240510215352"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240510215352-kurr83m","Type":"NodeParagraph","Properties":{"id":"20240510215352-kurr83m","updated":"20240510215403"},"Children":[{"Type":"NodeText","Data":"对于镂空纹理而言，我们通常会将这个阈值设置为大于0.0的值，比如0.5或者更高。或者再进一步，直接忽略alpha值，不使用它们进行混合；这样做可以避免乱序所带来的瑕疵，但是结果的质量会很低，因为只有两个级别的透明度（完全不透明和完全透明）是可用的"}]}]}]},{"ID":"20240510215411-pjpoog5","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240510215411-pjpoog5"},"Children":[{"ID":"20240510215411-9rjbvwm","Type":"NodeParagraph","Properties":{"id":"20240510215411-9rjbvwm","updated":"20240510215505"},"Children":[{"Type":"NodeText","Data":"还可以对每个模型执行两个Pass，第一个Pass用于渲染不透明的镂空样本，同时写入zbuffer，另一个pass用于渲染半透明样本但不写入zbuffer。"}]}]},{"ID":"20240510215509-86nrbxa","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240510215509-86nrbxa"},"Children":[{"ID":"20240510215509-57giiab","Type":"NodeParagraph","Properties":{"id":"20240510215509-57giiab","updated":"20240510215526"},"Children":[{"Type":"NodeText","Data":"alpha测试可能导致过度放大或过度缩小。"}]},{"ID":"20240510215539-zjaeo0j","Type":"NodeParagraph","Properties":{"id":"20240510215539-zjaeo0j","updated":"20240510215542"},"Children":[{"Type":"NodeText","Data":"当alpha测试与mipmap一起使用的时候，如果不进行特殊处理，那么效果会很差，如下："}]},{"ID":"20240510215546-m3xf81w","Type":"NodeParagraph","Properties":{"id":"20240510215546-m3xf81w","updated":"20240510215558"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240510215546-gacng00.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"上图：alpha测试与mipmap没有进行任何的修正。下图：根据覆盖率重新调整alpha值的alpha测试结果。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240510215602-6uco19r","Type":"NodeParagraph","Properties":{"id":"20240510215602-6uco19r","updated":"20240510215639"},"Children":[{"Type":"NodeText","Data":"如图6.29顶部所示，树木的叶子会比预期变得更加透明。"}]},{"ID":"20240510215641-vcayc6q","Type":"NodeParagraph","Properties":{"id":"20240510215641-vcayc6q","updated":"20240510215648"},"Children":[{"Type":"NodeText","Data":"可以用一个例子解释："}]},{"ID":"20240510215738-64nwp0e","Type":"NodeBlockquote","Properties":{"id":"20240510215738-64nwp0e","updated":"20240510215738"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240510215738-p61yr54","Type":"NodeParagraph","Properties":{"id":"20240510215738-p61yr54","updated":"20240510215747"},"Children":[{"Type":"NodeText","Data":"假设我们现在有一个具有四个alpha值的一维纹理，即(0.0,1.0,1.0,0.0)；而在平均之后，下一个mipmap层级所对应的纹素值会变为(0.5,0.5)，最高层级mipmap所对应的纹素值为(0.5)。现在，假设我们现在使用"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\alpha_t = 0.75"},{"Type":"NodeText","Data":"来作为alpha测试的阈值。当访问第0级的mipmap时，4个纹素中的1.5个可以通过alpha测试，不会被丢弃。但是，当访问剩下两个mipmap层级时，由于0.5 \u003c 0.75，因此所有纹素都会被丢弃。"}]}]},{"ID":"20240510215648-6pjaonp","Type":"NodeParagraph","Properties":{"id":"20240510215648-6pjaonp","updated":"20240510215822"},"Children":[{"Type":"NodeText","Data":"下图是另一个例子："}]},{"ID":"20240510215837-nz9uyco","Type":"NodeParagraph","Properties":{"id":"20240510215837-nz9uyco","updated":"20240510215853"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"20230611101813"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/20230611101813-20240510215837-w95pmrh.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"第一行是叶子图案不同mipmap层级的结果，更高的mipmap层级放大了叶子的可见性。在第二行中，mipmap进行了阈值为0.5的alpha测试处理，这个过程展示了随着物体与相机距离的增加，其在屏幕上占据像素数量越来越少。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240510215911-dvv0mnq","Type":"NodeParagraph","Properties":{"id":"20240510215911-dvv0mnq","updated":"20240510215925"},"Children":[{"Type":"NodeText","Data":"一种解决方案是："}]},{"ID":"20240510215926-gygj3m0","Type":"NodeMathBlock","Properties":{"id":"20240510215926-gygj3m0","updated":"20240510215935"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\mathrm{ if (texture.a \u003c random()) \\quad discard }\n\\tag{6.11}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240510215937-qn8ue4g","Type":"NodeParagraph","Properties":{"id":"20240510215937-qn8ue4g","updated":"20240510220002"},"Children":[{"Type":"NodeText","Data":"random返回在[0,1]中的一个均匀值。，这意味着平均而言，这个操作会产生正确的结果。"}]},{"ID":"20240510220011-819j3s1","Type":"NodeParagraph","Properties":{"id":"20240510220011-819j3s1","updated":"20240510220035"},"Children":[{"Type":"NodeText","Data":"实践中会将此随机函数替换为哈希函数从而避免时空上的高频噪声："}]},{"ID":"20240510220035-3cdoq5m","Type":"NodeMathBlock","Properties":{"id":"20240510220035-3cdoq5m","updated":"20240510220122"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\begin{aligned} \\text { float } \u0026 \\operatorname{hash} 2 D(x, y)\\{ \n\\\\\u0026\\operatorname{return} \\enspace \\operatorname{fract}(1.0 e 4 * \\sin (17.0 * x+0.1 * y) \\enspace * \n\\\\\u0026 (0.1+\\operatorname{abs}(\\sin (13.0 * y+x)))) ;\n\\}\\end{aligned}\n\\tag{6.12}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240510220054-r0b4vqq","Type":"NodeParagraph","Properties":{"id":"20240510220054-r0b4vqq","updated":"20240510220104"},"Children":[{"Type":"NodeText","Data":"通过嵌套调用可以创建一个三维哈希："}]},{"ID":"20240510220105-xc1z31w","Type":"NodeMathBlock","Properties":{"id":"20240510220105-xc1z31w","updated":"20240510220237"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\mathrm{ float \\enspace hash3D(x,y,z)\\enspace \\{ \\enspace return \\enspace hash2D(hash2D(x,y),z); \\}  }"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240510220238-78yugaj","Type":"NodeParagraph","Properties":{"id":"20240510220238-78yugaj","updated":"20240510220259"},"Children":[{"Type":"NodeText","Data":"哈希函数的输入是，物体局部空间坐标除以该坐标相对于屏幕空间（x方向和y方向）的最大导数，然后再对其进行clamp操作。"}]},{"ID":"20240510220322-nxv0q7k","Type":"NodeParagraph","Properties":{"id":"20240510220322-nxv0q7k","updated":"20240510220340"},"Children":[{"Type":"NodeText","Data":"如果要活的z方向上的稳定性最好与时域抗锯齿技术相结合。"}]},{"ID":"20240510220616-ziprmiu","Type":"NodeParagraph","Properties":{"id":"20240510220616-ziprmiu","updated":"20240510220622"},"Children":[{"Type":"NodeText","Data":"这个方法"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"随着距离的增加而渐隐，在近距离时我们根本不会看到任何随机效果"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。该方法的优点在于，每个片元的结果在平均上都是正确的。alpha测试放大情况相下会显示出波纹瑕疵，这个通过将成alpha贴图预计算为一个距离场来避免。"}]}]},{"ID":"20240510220801-e6npcv1","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240510220801-e6npcv1","updated":"20240510221653"},"Children":[{"ID":"20240510220801-lilods2","Type":"NodeParagraph","Properties":{"id":"20240510220801-lilods2","updated":"20240510220823"},"Children":[{"Type":"NodeText","Data":"Alpha To cOVERAGE以及类似的透明度自适应抗锯齿。"}]},{"ID":"20240510220823-rkuel0v","Type":"NodeParagraph","Properties":{"id":"20240510220823-rkuel0v","updated":"20240510220854"},"Children":[{"Type":"NodeText","Data":"这些方法将片元透明度值转换为像素内覆盖的样本数，类似点阵剔除半透明法，只不过这里作用于亚像素级别。"}]},{"ID":"20240510220855-8flwvwu","Type":"NodeBlockquote","Properties":{"id":"20240510220855-8flwvwu","updated":"20240510220856"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240510220856-03l8a6e","Type":"NodeParagraph","Properties":{"id":"20240510220856-03l8a6e","updated":"20240510220909"},"Children":[{"Type":"NodeText","Data":"假设每个像素有四个样本位置，现在有一个片元覆盖了一个像素，但是由于镂空纹理的影响，其透明度为25%（即75%不透明）。Alpha To Coverage模式使得该片元变得完全不透明，尽管它只覆盖了四个样本中的三个。"}]}]},{"ID":"20240510220918-oqk8pz8","Type":"NodeParagraph","Properties":{"id":"20240510220918-oqk8pz8","updated":"20240510220959"},"Children":[{"Type":"NodeText","Data":"这个模式对镂空纹理而言十分有用，例如重叠的草叶。由于绘制的每个样本都是完全不透明的，因此最近的叶子会将以相同的方式，在其边缘处遮挡后面的物体。由于此时关闭了alpha混合，因此不需要进行排序，就可以正确地混合半透明的边缘像素"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"。"}]},{"ID":"20240510221008-a8jnphc","Type":"NodeParagraph","Properties":{"id":"20240510221008-a8jnphc","updated":"20240510221016"},"Children":[{"Type":"NodeText","Data":"Alpha To Coverage对于alpha测试的抗锯齿而言是非常好的，但是在alpha混合的时候，可能会出现瑕疵。'"}]},{"ID":"20240510221016-g5e37ue","Type":"NodeBlockquote","Properties":{"id":"20240510221016-g5e37ue","updated":"20240510221030"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240510221017-v6q90pb","Type":"NodeParagraph","Properties":{"id":"20240510221017-v6q90pb","updated":"20240510221030"},"Children":[{"Type":"NodeText","Data":"例如：两个具有相同alpha覆盖百分比的alpha混合片元，将会使用相同的亚像素模式，这意味着一个片元将会完全覆盖另一个片元，而不是与之混合。"}]}]},{"ID":"20240510221049-srax3mi","Type":"NodeParagraph","Properties":{"id":"20240510221049-srax3mi","updated":"20240510221449"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"20230611101829"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/20230611101829-20240510221049-egcljhk.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"使用不同技术进行渲染的叶子纹理，在叶子的边缘部分使用了alpha覆盖。从左到右分别是：alpha测试，alpha混合，Alpha To Coverage，Alpha To Coverage+边缘锐化。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240510221646-j4bn18a","Type":"NodeParagraph","Properties":{"id":"20240510221646-j4bn18a","updated":"20240510221653"},"Children":[{"Type":"NodeText","Data":"阅读："},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20240510221620-7hldw2l","TextMarkBlockRefSubtype":"d","TextMarkTextContent":"UE426终于实现了Alpha to Coverage"}]}]}]},{"ID":"20240510221534-32j8kxn","Type":"NodeList","ListData":{},"Properties":{"id":"20240510221534-32j8kxn","updated":"20240510222330"},"Children":[{"ID":"20240510221536-jjayf7f","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240510221536-jjayf7f","updated":"20240510222330"},"Children":[{"ID":"20240510221536-28fdvlk","Type":"NodeParagraph","Properties":{"id":"20240510221536-28fdvlk","updated":"20240510221556"},"Children":[{"Type":"NodeText","Data":"对于任何alpha映射的使用，需要理解双线性插值颜色的影响原理。"}]},{"ID":"20240510221701-k3jhif3","Type":"NodeBlockquote","Properties":{"id":"20240510221701-k3jhif3","updated":"20240510221702"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240510221702-3w6189f","Type":"NodeParagraph","Properties":{"id":"20240510221702-3w6189f","updated":"20240510221755"},"Children":[{"Type":"NodeText","Data":"想象两个相邻的纹素：rgbα =(255,0,0,255)代表了不透明红色，其相邻的rgbα =(0,0,0,2)代表了几乎完全透明的黑色。那么两个纹素中间位置上的rgbα值是多少呢？最简单的插值方法可以获得(127,0,0,128)，这个rgb值是一个“较暗”的红色。然而，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"这个结果实际上并没有变暗，它是一个预乘了alpha的全红色"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20240510221748-4fk38qc","Type":"NodeParagraph","Properties":{"id":"20240510221748-4fk38qc","updated":"20240510221755"},"Children":[{"Type":"NodeText","Data":"如果我们要对alpha进行插值的话，为了"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"得到正确的插值结果，我们需要确保被插值的颜色在插值之前就已经预乘了alpha"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240510221758-s7lelgu","Type":"NodeBlockquote","Properties":{"id":"20240510221758-s7lelgu","updated":"20240510221759"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240510221759-cmt9sek","Type":"NodeParagraph","Properties":{"id":"20240510221759-cmt9sek","updated":"20240510221852"},"Children":[{"Type":"NodeText","Data":"例如："}]},{"ID":"20240510221932-olpvmg7","Type":"NodeParagraph","Properties":{"id":"20240510221932-olpvmg7","updated":"20240510221932"},"Children":[{"Type":"NodeText","Data":"假设刚才那个几乎透明的邻居纹素被设置为rgbα =(0,255,0,2)，即几乎完全透明的绿色。这个颜色没有预乘alpha，在插值时得到的结果是(127,127,0,128)，这个几乎完全透明的绿色会把结果变成（预乘了alpha）黄色。"}]},{"ID":"20240510221924-tqhguqb","Type":"NodeParagraph","Properties":{"id":"20240510221924-tqhguqb","updated":"20240510221924"},"Children":[{"Type":"NodeText","Data":"这个相邻纹素的alpha预乘版本是(0,2,0,2)，它会给出正确的预乘颜色结果，即(127,1,0,128)。这个结果才是有意义的，因为生成的颜色以红色为主，还有一抹很难察觉的绿色。"}]}]},{"ID":"20240510222149-k6pzovt","Type":"NodeParagraph","Properties":{"id":"20240510222149-k6pzovt","updated":"20240510222154"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"如果忽略双线性插值给出的预乘结果，则会导致贴花物体和镂空物体周围出现黑色的边缘。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"}]},{"ID":"20240510222205-aywlcse","Type":"NodeParagraph","Properties":{"id":"20240510222205-aywlcse","updated":"20240510222212"},"Children":[{"Type":"NodeText","Data":"最好的策略就是在进行双线性插值之前，就进行alpha预乘。"}]},{"ID":"20240510222251-6h32451","Type":"NodeParagraph","Properties":{"id":"20240510222251-6h32451","updated":"20240510222252"},"Children":[{"Type":"NodeText","Data":"然而，双线性插值通常是由GPU执行的，而在执行这个操作之前，着色器并不能对纹素值进行操作。图片也无法以PNG等文件格式进行预乘，因为这样做会失去色彩精度。这两个因素结合在一起，会导致在使用alpha映射时，产生默认的黑色边缘。"}]},{"ID":"20240510222252-2lphpok","Type":"NodeParagraph","Properties":{"id":"20240510222252-2lphpok","updated":"20240510222330"},"Children":[{"Type":"NodeText","Data":"一个常见的解决方法是"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"对镂空纹理进行预处理，将透明的“黑色”纹素涂上来自附近不透明纹素的颜色"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。所有透明区域通常都需要使用这种方式来重新进行绘制，这个过程可以手动完成或者自动完成，这样mipmap的各个层级也可以避免边缘问题。同样值得注意的是，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"在使用alpha值来生成mipmap的时候，也应当使用alpha预乘的颜色值"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]}]}]},{"ID":"20240510221658-0f129nm","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240510221658-0f129nm","updated":"20240510222342"},"Children":[{"Type":"NodeText","Data":"6.7 凹凸映射"}]},{"ID":"20240510222342-3cfmwyd","Type":"NodeParagraph","Properties":{"id":"20240510222342-3cfmwyd","updated":"20240510222428"},"Children":[{"Type":"NodeText","Data":"物体表面上的细节可以分为三种尺度：覆盖大量像素的宏观特征（macro-feature）、覆盖几个像素的细观特征（meso-feature，或者叫做介观）以及尺寸远小于一个像素的微观特征（micro-feature）。"}]},{"ID":"20240510222428-kff80rr","Type":"NodeParagraph","Properties":{"id":"20240510222428-kff80rr","updated":"20240510222538"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"宏观几何"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"（macrogeometry）由顶点、三角形或者其他几何图元构成。"}]},{"ID":"20240510222451-d4a10ml","Type":"NodeBlockquote","Properties":{"id":"20240510222451-d4a10ml","updated":"20240510222454"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240510222451-13ydkzd","Type":"NodeParagraph","Properties":{"id":"20240510222451-13ydkzd","updated":"20240510222454"},"Children":[{"Type":"NodeText","Data":"创建一个三维角色时，四肢和头部通常都是在宏观尺度上进行建模的。"}]}]},{"ID":"20240510222455-ilk83ct","Type":"NodeParagraph","Properties":{"id":"20240510222455-ilk83ct","updated":"20240510222541"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"微观几何"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"则会被封装在着色模型中，通常在像素着色器中进行实现，并使用纹理贴图作为着色方程的输入参数。"}]},{"ID":"20240510222512-7oy1akw","Type":"NodeParagraph","Properties":{"id":"20240510222512-7oy1akw","updated":"20240510222514"},"Children":[{"Type":"NodeText","Data":"着色模型可以用来模拟表面微观几何与光线之间的相互作用。"}]},{"ID":"20240510222514-8m47p4r","Type":"NodeBlockquote","Properties":{"id":"20240510222514-8m47p4r","updated":"20240510222522"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240510222515-k68f1zh","Type":"NodeParagraph","Properties":{"id":"20240510222515-k68f1zh","updated":"20240510222522"},"Children":[{"Type":"NodeText","Data":"例如：表面有光泽的物体在微观上是光滑的，而漫反射的表面在微观上则是粗糙的。角色的皮肤和衣服看起来具有不同的材质，这是因为它们使用了不同的着色器，或者至少在这些着色器中使用了不同的参数。"}]}]},{"ID":"20240510222523-hlrkm24","Type":"NodeParagraph","Properties":{"id":"20240510222523-hlrkm24","updated":"20240510222544"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"细观几何"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"（meso-geometry，介观几何）描述了宏观尺度和微观尺度之间的一切特征。"}]},{"ID":"20240510222545-rx5jnk7","Type":"NodeParagraph","Properties":{"id":"20240510222545-rx5jnk7","updated":"20240510222554"},"Children":[{"Type":"NodeText","Data":"它包含的细节过于复杂，以致于无法使用单个三角形来进行有效地渲染；但是这个尺度对于观察者而言已经足够大了，可以在几个像素上分辨出表面曲率的细微变化。"}]},{"ID":"20240510222556-khteu3o","Type":"NodeBlockquote","Properties":{"id":"20240510222556-khteu3o","updated":"20240510222604"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240510222556-zdhe4me","Type":"NodeParagraph","Properties":{"id":"20240510222556-zdhe4me","updated":"20240510222604"},"Children":[{"Type":"NodeText","Data":"例如：角色脸上的皱纹、肌肉组织的细节、衣服上的褶皱和接缝，都属于细观范畴。"}]}]},{"ID":"20240510222603-u4ip7so","Type":"NodeParagraph","Properties":{"id":"20240510222603-u4ip7so","updated":"20240510222619"},"Children":[{"Type":"NodeText","Data":"一类统称为凹凸映射技术的方法，通常用于建模这样的细观尺度，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"它们会在像素级别上调整着色参数，使得观众能感知到基础几何形状之外的微小扰动，同时使得基础几何形状保持平坦"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240510222620-6797d0y","Type":"NodeParagraph","Properties":{"id":"20240510222620-6797d0y","updated":"20240510222654"},"Children":[{"Type":"NodeText","Data":"不同类型凹凸映射技术的主要区别"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"在于它们表示细节特征的具体方式"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240510222655-liz270t","Type":"NodeParagraph","Properties":{"id":"20240510222655-liz270t","updated":"20240510222727"},"Children":[{"Type":"NodeText","Data":"细观几何的变化因素包括"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"现实主义水平和细节特征的复杂程度"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240510222727-rkjrcf3","Type":"NodeBlockquote","Properties":{"id":"20240510222727-rkjrcf3","updated":"20240510222738"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240510222738-d5zleim","Type":"NodeParagraph","Properties":{"id":"20240510222738-d5zleim","updated":"20240510222738"},"Children":[{"Type":"NodeText","Data":"例如：数字艺术家通常会在模型中雕刻细节，然后使用软件将这些几何元素转换为一个或多个纹理贴图，例如凹凸贴图以及可能的缝隙暗化（crevice-darkening）纹理。"}]}]},{"ID":"20240510222739-qk2z8vq","Type":"NodeParagraph","Properties":{"id":"20240510222739-qk2z8vq","updated":"20240510222822"},"Children":[{"Type":"NodeText","Data":"linn在1978年提出了在纹理中编码细观尺度细节的想法[160]。他观察到：如果在着色过程中，我们"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"使用稍微扰动的表面法线来代替真实的表面法线，这样表面看起来就像是具有了小尺度细节一样"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。他将描述表面法线扰动的数据存储在数组中。"}]},{"ID":"20240510222822-nxkoa76","Type":"NodeParagraph","Properties":{"id":"20240510222822-nxkoa76","updated":"20240510222833"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"其中最关键的想法是，我们不是使用纹理贴图来改变光照方程中的颜色参数，而是使用纹理贴图来修改表面的法线数据。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"}]},{"ID":"20240510222833-i2cxpj8","Type":"NodeParagraph","Properties":{"id":"20240510222833-i2cxpj8","updated":"20240510222846"},"Children":[{"Type":"NodeText","Data":"表面原本的几何法线保持不变；我们只是修改了光照方程中所使用的法线；这个操作并没有物理意义上的等效操作，虽然我们对表面法线进行一些修改，但是表面本身在几何意义上仍然是保持光滑的。"}]},{"ID":"20240510222847-feigna6","Type":"NodeParagraph","Properties":{"id":"20240510222847-feigna6","updated":"20240510222943"},"Children":[{"Type":"NodeText","Data":"对于凹凸映射而言，表面法线必须相对于某个参照系改变自身的方向。为了实现这个操作，每个顶点都会存储一个"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"切线坐标系"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"（tangent frame），它也称为切线空间基底（tangent-space basis）。这个参考系"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"用于将光线转换到表面着色点的局部空间中（反之亦可），从而计算扰动法线的效果"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240510223009-8lkgqff","Type":"NodeParagraph","Properties":{"id":"20240510223009-8lkgqff","updated":"20240510223031"},"Children":[{"Type":"NodeText","Data":"对于一个应用了法线贴图的多边形表面，除了顶点法线之外，我们还存储了所谓的"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"切线向量（tangent vector）"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"副切线向量（bitangent vector）"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。其中副切线有时也被错误地称为副法线（binormal vector）。"}]},{"ID":"20240510222928-wvecowx","Type":"NodeParagraph","Properties":{"id":"20240510222928-wvecowx","updated":"20240510223048"},"Children":[{"Type":"NodeText","Data":"切线向量和副切线向量代表了物体空间坐标系中，法线贴图本身的坐标轴，因为这里的目标是将光线转换到相对于法线贴图的局部空间中，详见图6.32。"}]},{"ID":"20240510223059-dmbcj6y","Type":"NodeParagraph","Properties":{"id":"20240510223059-dmbcj6y","updated":"20240510223108"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240510223059-gpdwcvo.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"上图展示了两个球面化的三角形，并展示了其切线坐标系。诸如球体和圆环面这样的形状，有一个很自然的切线空间基底，正如圆环面上的经纬度线所展示的那样。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240510223142-knt55ca","Type":"NodeParagraph","Properties":{"id":"20240510223142-knt55ca","updated":"20240510223159"},"Children":[{"Type":"NodeText","Data":"这三个向量，法向量"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{n}"},{"Type":"NodeText","Data":"，切线向量"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{t}"},{"Type":"NodeText","Data":"，和副切线向量"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{b}"},{"Type":"NodeText","Data":"，构成一个基底矩阵："}]},{"ID":"20240510223142-aswpa07","Type":"NodeMathBlock","Properties":{"id":"20240510223142-aswpa07","updated":"20240510223153"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\left(\\begin{array}{cccc}t_{x} \u0026 t_{y} \u0026 t_{z} \u0026 0 \\\\ b_{x} \u0026 b_{y} \u0026 b_{z} \u0026 0 \\\\ n_{x} \u0026 n_{y} \u0026 n_{z} \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1\\end{array}\\right) \\tag{6.13}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240510223142-ncgp12s","Type":"NodeParagraph","Properties":{"id":"20240510223142-ncgp12s","updated":"20240510223207"},"Children":[{"Type":"NodeText","Data":"这个矩阵有时会缩写为"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"TBN"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"它用于将光线方向（对于给定顶点）从世界空间转换到切线空间中"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240510223202-bx7tv9z","Type":"NodeParagraph","Properties":{"id":"20240510223202-bx7tv9z","updated":"20240510223310"},"Children":[{"Type":"NodeText","Data":"一种节省存储空间的方法是，只存储顶点的切线和副切线，然后使用它们的叉乘来计算法线；然而，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"这种方法只有在TBN矩阵的手性（handedness）总是相同的情况下才有效"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240510223302-fqp6lan","Type":"NodeBlockquote","Properties":{"id":"20240510223302-fqp6lan","updated":"20240510223503"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240510223459-nsmtdtz","Type":"NodeParagraph","Properties":{"id":"20240510223459-nsmtdtz","updated":"20240510223503"},"Children":[{"Type":"NodeText","Data":"实践中的很多模型都是对称的，例如：飞机、人体、文件柜以及其他对称物体等。由于纹理会占据大量的存储空间，为了降低对称模型的纹理存储空间，因此它们通常会被镜像到对称模型上；即物体上的纹理只有一半会被存储下来，然后再使用纹理映射，将其应用在模型对称的两侧上。在这种情况下，切空间的手性在对称的两侧是不同的，不满足手性相同的假设。"}]}]},{"ID":"20240510223504-65dl5st","Type":"NodeParagraph","Properties":{"id":"20240510223504-65dl5st","updated":"20240510223523"},"Children":[{"Type":"NodeText","Data":"当然还可以在每个顶点上存储额外的bit信息来指示手性，这样也可以避免存储法线。"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"如果存在这个额外的手性bit的话，它会被用来修正切线和副切线的叉乘结果（取反），从而生成正确的法线"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240510223527-d5aiswx","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240510223527-d5aiswx","updated":"20240510223550"},"Children":[{"Type":"NodeText","Data":"6.7.1 Blinn方法"}]},{"ID":"20240510223551-ldpi502","Type":"NodeParagraph","Properties":{"id":"20240510223551-ldpi502","updated":"20240510223632"},"Children":[{"Type":"NodeText","Data":"Blinn原始的凹凸映射方法是，在纹理的每个纹素上存储两个带符号的值，"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"b_u和b_v"},{"Type":"NodeText","Data":"。这两个值代表了沿图像u轴和v轴法线的改变量。"}]},{"ID":"20240510223629-8d9h7si","Type":"NodeParagraph","Properties":{"id":"20240510223629-8d9h7si","updated":"20240510223651"},"Children":[{"Type":"NodeText","Data":"也就是说，这个纹理值（通常是双线性插值而来的）用于对两个垂直于法线的向量进行缩放，然后将这两个向量加到法线上，从而来改变法线的方向。"}]},{"ID":"20240510223729-io4pdbd","Type":"NodeParagraph","Properties":{"id":"20240510223729-io4pdbd","updated":"20240510223730"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240510223728-xog9o5m.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240510223737-u73mg9a","Type":"NodeParagraph","Properties":{"id":"20240510223737-u73mg9a","updated":"20240510223826"},"Children":[{"Type":"NodeText","Data":"左图中，在凹凸纹理中检索到了对应的值 "},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"(b\\_u, b\\_v) "},{"Type":"NodeText","Data":"，法线 "},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{n} "},{"Type":"NodeText","Data":"会在 "},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"u "},{"Type":"NodeText","Data":"和 "},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"v "},{"Type":"NodeText","Data":"两个方向上被这个值进行修改，最终得到 "},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{n}^{\\prime} "},{"Type":"NodeText","Data":"（这个新法线是非归一化的）。右图展示了高度场及其对着色法线的影响，这些法线可以在不同高度之间进行插值，从而获得更加平滑的效果。"}]},{"ID":"20240510223812-mo6m73w","Type":"NodeParagraph","Properties":{"id":"20240510223812-mo6m73w","updated":"20240510223904"},"Children":[{"Type":"NodeText","Data":"另一种用于表示凸起的方法是，使用高度场来修改表面法线的方向。每个单色的纹理值都代表了一个高度：在纹理中，白色代表较高的区域，黑色则代表较低的区域（反之亦然），如下图："}]},{"ID":"20240510223909-zoraqos","Type":"NodeParagraph","Properties":{"id":"20240510223909-zoraqos","updated":"20240510223916"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240510223908-5exb0dt.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"波浪高度场凹凸图像及其在球体上的应用效果。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240510223916-b2hkw9c","Type":"NodeParagraph","Properties":{"id":"20240510223916-b2hkw9c","updated":"20240510224008"},"Children":[{"Type":"NodeText","Data":"这个由纹理值定义的高度场，用于推导出u和v的带符号值，类似于第一种方法中使用的值。具体的推导方式是通过相邻列之间的差来得到u的斜率，以及相邻行之间的差来得到v的斜率。"}]},{"ID":"20240510224010-5ejur3k","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240510224010-5ejur3k","updated":"20240510224017"},"Children":[{"Type":"NodeText","Data":"6.7.2 法线映射"}]},{"ID":"20240510224017-s8qn9h1","Type":"NodeParagraph","Properties":{"id":"20240510224017-s8qn9h1","updated":"20240510224027"},"Children":[{"Type":"NodeText","Data":"凹凸贴图的一个常用方法是直接存储法线贴图（normal map），其算法和结果与Blinn的方法在数学上是等价的；二者的不同之处在于存储格式以及像素着色器中的计算操作。"}]},{"ID":"20240510224059-ybvx7i7","Type":"NodeParagraph","Properties":{"id":"20240510224059-ybvx7i7","updated":"20240510224101"},"Children":[{"Type":"NodeText","Data":"法线贴图将(x, y, z)映射到[−1,1]中，例如：对于8 bit纹理而言，x轴上的值0表示−1.0，值255则表示1.0。图6.35给出了一个例子：[128,128,255]是一个浅蓝色，具有该颜色值的平面，其法线为[0,0,1]。"}]},{"ID":"20240510224110-y2kntut","Type":"NodeParagraph","Properties":{"id":"20240510224110-y2kntut","updated":"20240510224121"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240510224110-gzpmb72.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"使用法线贴图进行凹凸映射。图像的每个颜色通道，实际上都是表面法线坐标的一个分量。红色通道代表了法线在 x 方向上的偏移；法线贴图的颜色越红，代表了修正后的法线越指向右。绿色通道是 y 方向上的偏移，蓝色通道是 z 方向上的偏移。右边是使用法线贴图生成的图像，请注意立方体顶部的扁平外观。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240510224123-a1m5zlo","Type":"NodeParagraph","Properties":{"id":"20240510224123-a1m5zlo","updated":"20240510224253"},"Children":[{"Type":"NodeText","Data":"这种法线贴图的表示方法，最初是作为世界空间法线贴图引入的，现在在实践中已经很少使用了。"}]},{"ID":"20240510224307-xh5dy9o","Type":"NodeParagraph","Properties":{"id":"20240510224307-xh5dy9o","updated":"20240510224314"},"Children":[{"Type":"NodeText","Data":"世界空间和模型空间的表示方法，都将法线贴图与特定方向的特定几何形状相绑定，这大大限制了法线贴图的可复用性。"}]},{"ID":"20240510224712-ct4y68y","Type":"NodeParagraph","Properties":{"id":"20240510224712-ct4y68y","updated":"20240510224746"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"相反，扰动法线通常会在切线空间中进行存储和检索，即相对于表面本身的空间。这允许表面发生形变，以及在最大程度上保证了法线贴图的可复用性"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。切线空间中的法线映射也可以很好地进行压缩，因为z分量（与未受干扰的表面法线相对齐的分量）的符号通常可以假设为正。"}]},{"ID":"20240510224751-fn45lh9","Type":"NodeParagraph","Properties":{"id":"20240510224751-fn45lh9","updated":"20240510224809"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240510224751-he2pjz7.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"一个在游戏场景中使用法线贴图进行凹凸映射的例子。左上角：没有应用右侧的两个法线贴图。左下角：应用了法线贴图。右边：法线贴图。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240510224809-88u9luw","Type":"NodeParagraph","Properties":{"id":"20240510224809-88u9luw","updated":"20240510224824"},"Children":[{"Type":"NodeText","Data":"与颜色纹理的过滤相比，对法线贴图的过滤是一个困难的问题。一般来说，法线与着色结果之间的关系并不是线性的，因此标准的滤波方法可能会产生令人讨厌的瑕疵。"}]},{"ID":"20240510224842-0cru4si","Type":"NodeParagraph","Properties":{"id":"20240510224842-0cru4si","updated":"20240510224842"},"Children":[{"Type":"NodeText","Data":"Lambertian材质表面是一种特殊情况，法线贴图对着色结果的影响几乎是线性的；Lambertian的着色操作几乎完全是一个点乘，这是一个线性运算。"}]},{"ID":"20240510224913-6z43rmd","Type":"NodeParagraph","Properties":{"id":"20240510224913-6z43rmd","updated":"20240510224915"},"Children":[{"Type":"NodeText","Data":"取一组法线的平均值，并对平均后法线进行点乘运算；与取单个法线的点乘结果，然后再进行平均是一样的，其数学形式如下："}]},{"ID":"20240510224844-ldhshe8","Type":"NodeMathBlock","Properties":{"id":"20240510224844-ldhshe8","updated":"20240510224851"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\mathbf{l} \\cdot\\left(\\frac{\\sum_{j=1}^{n} \\mathbf{n}_{j}}{n}\\right)=\\frac{\\sum_{j=1}^{n}\\left(\\mathbf{l} \\cdot \\mathbf{n}_{j}\\right)}{n}.\n\\tag{6.14}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240510224851-ygeiv0e","Type":"NodeParagraph","Properties":{"id":"20240510224851-ygeiv0e","updated":"20240510224959"},"Children":[{"Type":"NodeText","Data":"请注意，这个平均法线向量在使用之前并没有进行归一化处理。一些通常用于法线贴图的纹理压缩方法（例如从另外两个分量中重建z分量）并不支持非单位长度的法线，因此使用非归一化的法线贴图可能会造成压缩困难。"}]},{"ID":"20240510224959-4magd5i","Type":"NodeParagraph","Properties":{"id":"20240510224959-4magd5i","updated":"20240510225018"},"Children":[{"Type":"NodeText","Data":"在非Lambertian表面的情况下，需要将着色方程的输入参数作为一个整体来进行过滤，而不是单独对法线贴图进行过滤，这样可能会产生更好的效果。 Ref: 9.13"}]},{"ID":"20240510225018-cga54gb","Type":"NodeParagraph","Properties":{"id":"20240510225018-cga54gb","updated":"20240510225036"},"Children":[{"Type":"NodeText","Data":"最后，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"还可以从高度贴图h(x, y)中推导出法线贴图"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"，具体的做法如下[405]：首先，使用中心差分来计算x和y方向上梯度的近似值："}]},{"ID":"20240510225038-yjgf5tc","Type":"NodeMathBlock","Properties":{"id":"20240510225038-yjgf5tc","updated":"20240510225042"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"h_{x}(x, y)=\\frac{h(x+1, y)-h(x-1, y)}{2}, \\\\[2mm]\nh_{y}(x, y)=\\frac{h(x, y+1)-h(x, y-1)}{2}.\n \\tag{6.15}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240510225042-t9ynk4e","Type":"NodeParagraph","Properties":{"id":"20240510225042-t9ynk4e","updated":"20240510225051"},"Children":[{"Type":"NodeText","Data":"则在纹素(x, y)处的"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"非归一化法线"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"为："}]},{"ID":"20240510225048-wf1rlis","Type":"NodeMathBlock","Properties":{"id":"20240510225048-wf1rlis","updated":"20240510225057"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\mathbf{n}(x, y)=\\left(-h_{x}(x, y),-h_{y}(x, y), 1\\right)\n\\tag{6.16}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240510225101-yw3t23x","Type":"NodeParagraph","Properties":{"id":"20240510225101-yw3t23x","updated":"20240510225101"},"Children":[{"Type":"NodeText","Data":"在进行实际计算的时候需要格外注意纹理的边界。"}]},{"ID":"20240510225104-86zo1yt","Type":"NodeParagraph","Properties":{"id":"20240510225104-86zo1yt","updated":"20240510225111"},"Children":[{"Type":"NodeText","Data":"地平线映射可以用来进一步增强法线贴图，它可以让凸起的部分在其表面上投射阴影。"}]},{"ID":"20240510225113-149jauo","Type":"NodeParagraph","Properties":{"id":"20240510225113-149jauo","updated":"20240510225115"},"Children":[{"Type":"NodeText","Data":"Ref:11.4"}]},{"ID":"20240510225116-vj9smrk","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240510225116-vj9smrk","updated":"20240510230156"},"Children":[{"Type":"NodeText","Data":"6.8 视差映射"}]},{"ID":"20240510225141-ckomuvm","Type":"NodeParagraph","Properties":{"id":"20240510225141-ckomuvm","updated":"20240510230156"},"Children":[{"Type":"NodeText","Data":"凹凸映射和法线映射存在的一个问题是，表"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"面上凹凸的位置永远不会随着视角的变化而变化，也不会发生互相遮挡的情况"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240510225146-n019obw","Type":"NodeBlockquote","Properties":{"id":"20240510225146-n019obw","updated":"20240510230156"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240510225146-yubwvtd","Type":"NodeParagraph","Properties":{"id":"20240510225146-yubwvtd","updated":"20240510225159"},"Children":[{"Type":"NodeText","Data":"例如：如果我们以一个掠射视角，沿着真正的砖墙进行观察，从某个角度开始，我们就看不到砖与砖之间的砂浆了，这是因为砂浆相对于砖块而言是凹下去的。墙壁的凹凸贴图永远无法表现这种类型的遮挡关系，因为它仅仅是改变了表面的法线。想要实现这种表面自遮挡效果，最好是让这些凸起对表面上每个像素渲染的位置产生实际影响。"}]}]},{"ID":"20240510225341-ogv4742","Type":"NodeParagraph","Properties":{"id":"20240510225341-ogv4742","updated":"20240510230156"},"Children":[{"Type":"NodeText","Data":"视差（parallax）这个概念指的是，当观察者的位置发送移动时，物体的位置也会相对发生移动；当观察者移动时，凸起部分应当看起来具有高度感。"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"视差映射的核心思想是通过检查可见物体的高度，对像素中应当看到的内容进行有根据的猜测"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240510225216-isf5cqk","Type":"NodeParagraph","Properties":{"id":"20240510225216-isf5cqk","updated":"20240510230156"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"20230611102022"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/20230611102022-20240510225216-5xftbrc.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240510225220-wak5k5v","Type":"NodeParagraph","Properties":{"id":"20240510225220-wak5k5v","updated":"20240510230156"},"Children":[{"Type":"NodeText","Data":"左边是视差映射的目标：根据观察向量穿过高度场的位置，找到表面上被观察到的 实际 位置。视差映射通过获取矩形位置上的高度，并使用它来找到新的位置"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":" \\mathbf{p}_{adj}"},{"Type":"NodeText","Data":" 来对 "},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{p}_{ideal} "},{"Type":"NodeText","Data":"进行一阶近似。"}]},{"ID":"20240510225259-mev6iwx","Type":"NodeParagraph","Properties":{"id":"20240510225259-mev6iwx","updated":"20240510230156"},"Children":[{"Type":"NodeText","Data":"对于视差映射而言，表面的凸起会被存储在一个高度场纹理中。"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"当观察表面上的某个像素时，将会检索该位置对应的高度场值，并将其用于对纹理坐标进行移动，从而对表面上的不同部分进行检索"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。具体移动多少距离，取决于检索到的高度值以及眼睛到表面上该点的角度，这个过程如上图所示。"}]},{"ID":"20240510225430-zkzaw27","Type":"NodeParagraph","Properties":{"id":"20240510225430-zkzaw27","updated":"20240510230156"},"Children":[{"Type":"NodeText","Data":"这个高度场值要么存储在一个单独的纹理中，要么被打包在其他纹理未使用的颜色通道或者alpha通道中（"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"在打包不相关纹理的时候必须十分小心，因为这可能会对压缩质量产生负面影响"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"）。"}]},{"ID":"20240510225449-b956oyp","Type":"NodeParagraph","Properties":{"id":"20240510225449-b956oyp","updated":"20240510230156"},"Children":[{"Type":"NodeText","Data":"在用于移动坐标之前，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"高度场的值还会被缩放和偏移"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"：缩放的大小取决于高度场在地表之上（或者地表之下）延伸的高度；偏移取决于不发生变化的“海平面”高度。"}]},{"ID":"20240510225451-nfovkrx","Type":"NodeParagraph","Properties":{"id":"20240510225451-nfovkrx","updated":"20240510230156"},"Children":[{"Type":"NodeText","Data":"给定纹理坐标位置"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{p}"},{"Type":"NodeText","Data":"，调整后的高度场高度"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"h"},{"Type":"NodeText","Data":"，以及归一化的观察向量"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{v}"},{"Type":"NodeText","Data":"，并且高度值为"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"v_z"},{"Type":"NodeText","Data":"，水平分量为"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{v}_{xy}"},{"Type":"NodeText","Data":"，那么经视差调整后的新纹理坐标"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{p}_{adj}"},{"Type":"NodeText","Data":"为："}]},{"ID":"20240510225521-ywlvnif","Type":"NodeMathBlock","Properties":{"id":"20240510225521-ywlvnif","updated":"20240510230156"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\mathbf{p}_{\\mathrm{adj}}=\\mathbf{p}+\\frac{h \\cdot \\mathbf{v}_{x y}}{v_{z}}\n\\tag{6.17}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240510225534-ualgk2t","Type":"NodeParagraph","Properties":{"id":"20240510225534-ualgk2t","updated":"20240510230156"},"Children":[{"Type":"NodeText","Data":"请注意，与大多数着色方程不同，这里"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"执行计算的空间坐标系是很重要的，因为观察向量需要位于切线空间中"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240510225635-57b7ldv","Type":"NodeParagraph","Properties":{"id":"20240510225635-57b7ldv","updated":"20240510230156"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"这种方法在掠射视角下会失效"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"，因为当观察向量近乎平行于表面时，一个很小的高度变化，可能就会导致一个相当大的纹理坐标偏移，此时的近似会失效，因为检索到的新位置与原始表面位置的高度相关性很小，或者是根本没有高度相关性。"}]},{"ID":"20240510225704-zs5t6og","Type":"NodeParagraph","Properties":{"id":"20240510225704-zs5t6og","updated":"20240510230156"},"Children":[{"Type":"NodeText","Data":"为了改善这个问题，引入偏移限制："}]},{"ID":"20240510225716-fjfaub8","Type":"NodeMathBlock","Properties":{"id":"20240510225716-fjfaub8","updated":"20240510230156"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\mathbf{p}_{\\text {adj }}^{\\prime}=\\mathbf{p}+h \\cdot \\mathbf{v}_{x y}\n\\tag{6.18}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240510225802-6vfd9av","Type":"NodeParagraph","Properties":{"id":"20240510225802-6vfd9av","updated":"20240510230156"},"Children":[{"Type":"NodeText","Data":"请注意，这个方程的计算速度要比原来的快。"}]},{"ID":"20240510225803-ojkq6uz","Type":"NodeParagraph","Properties":{"id":"20240510225803-ojkq6uz","updated":"20240510230156"},"Children":[{"Type":"NodeText","Data":"这种方法的几何解释是：该位置的高度定义了一个半径，超过这个半径位置就无法进行移动，如图6.38所示。"}]},{"ID":"20240510225814-8fheq7i","Type":"NodeParagraph","Properties":{"id":"20240510225814-8fheq7i","updated":"20240510230156"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240510225814-uugyw8e.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"在视差偏移限制中，偏移量的最大值就是原始位置的高度，例如左图中的虚线圆弧。左图中的灰色偏移代表了原始的偏移结果，而黑色偏移代表了限制偏移后的结果。右图则是使用这种技术渲染出来的砖墙。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240510225821-eiucc92","Type":"NodeParagraph","Properties":{"id":"20240510225821-eiucc92","updated":"20240510230156"},"Children":[{"Type":"NodeText","Data":"对于立体渲染而言，观察者会同时感知两个视点，这要求必须提供一致的深度。"}]},{"ID":"20240510230110-kz2jv01","Type":"NodeParagraph","Properties":{"id":"20240510230110-kz2jv01","updated":"20240510230156"},"Children":[{"Type":"NodeText","Data":"即使有着这些缺点，但是具有偏移限制的视差映射，只需要花费一些额外的像素着色器指令即可实现，并且相较于基本的法线映射而言，它可以大幅改善图像的质量。"}]},{"ID":"20240510230122-4ojj1zw","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240510230122-4ojj1zw","updated":"20240510230156"},"Children":[{"Type":"NodeText","Data":"6.8.1 视差遮挡映射"}]},{"ID":"20240510230129-ptee9il","Type":"NodeParagraph","Properties":{"id":"20240510230129-ptee9il","updated":"20240510230218"},"Children":[{"Type":"NodeText","Data":"视差映射提供了一个简单的近似高度场效果，它假设一个像素的高度与其邻居的高度大致相同，但是这个假设很快就会被打破。"}]},{"ID":"20240510230230-yh3hujh","Type":"NodeParagraph","Properties":{"id":"20240510230230-yh3hujh","updated":"20240510230237"},"Children":[{"Type":"NodeText","Data":"视差映射所产生的凸起并不会相互遮挡，也不会产生阴影。我们真正想要的是在像素处可见的内容，即观察向量第一次与高度场相交的地方。"}]},{"ID":"20240510230238-jjl1pea","Type":"NodeParagraph","Properties":{"id":"20240510230238-jjl1pea","updated":"20240510230318"},"Children":[{"Type":"NodeText","Data":"可以使用光线步进（Ray Marching）方法解决这个问题。这项工作可以在像素着色器中完成，可以通过访问纹理来检索到所需的高度数据。我们将这些方法的研究归类为视差映射技术的一个子集，这些技术以这样或者那样的方式，来利用光线步进解决问题。"}]},{"ID":"20240510230322-pzkjp6s","Type":"NodeParagraph","Properties":{"id":"20240510230322-pzkjp6s","updated":"20240510230336"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240510230322-ju0a1hq.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"绿色的观察射线被投影到表面上，并以一定的间隔进行采样（紫色点），在每个采样点上，会检索对应位置的高度值。该算法的目标是，找到观察射线与近似弯曲高度场（黑色线段）的第一个交点。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240510230336-s75k2zx","Type":"NodeParagraph","Properties":{"id":"20240510230336-s75k2zx","updated":"20240510230400"},"Children":[{"Type":"NodeText","Data":"这类算法被称为"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"视差遮挡映射"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"（parallax occlusion mapping，POM）或者浮雕映射（relief mapping）等。"}]},{"ID":"20240510230400-bd04qt5","Type":"NodeParagraph","Properties":{"id":"20240510230400-bd04qt5","updated":"20240510230504"},"Children":[{"Type":"NodeText","Data":"其关键思想是："},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"首先沿着观察方向的投影向量，对固定数量的高度场纹理样本进行测试。在掠射观察角度下，通常会生成数量更多的样本，以便不会遗漏这个最近交点。会对沿着光线方向的每个三维样本位置进行检索，并将其转换到纹理空间中进行处理，从而确定该位置是高于该点的高度场，还是低于该点的高度场。一旦找到了一个低于高度场的样本，就使用这个低于高度场的样本，与前一个高于高度差的样本，来找到一个交点位置"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"，如图上图。"}]},{"ID":"20240510230420-omgsjt3","Type":"NodeParagraph","Properties":{"id":"20240510230420-omgsjt3","updated":"20240510230657"},"Children":[{"Type":"NodeText","Data":"这种视差错觉会在物体的轮廓边缘处消失，转而会显示出原始表面的平滑轮廓，如图6.41所示。"}]},{"ID":"20240510230703-w7tmfci","Type":"NodeParagraph","Properties":{"id":"20240510230703-w7tmfci","updated":"20240510230714"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240510230703-hg1drc6.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"法线映射和浮雕映射。法线映射不会产生自遮挡现象；浮雕映射在具有重复纹理的轮廓边缘上会出现问题，因为纹素矩形更像是高度场的视图，而不是真正的边界定义。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240510230731-g1rr0mu","Type":"NodeParagraph","Properties":{"id":"20240510230731-g1rr0mu","updated":"20240510230737"},"Children":[{"Type":"NodeText","Data":"这个问题的关键在于，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"被渲染的三角形仅仅定义了哪些像素应当由像素着色器进行计算，而不是表面上的实际位置"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"，因此位于三角形之外的像素都不会受到视差映射的影响。此外，对于曲面而言，视察映射的轮廓问题将会变得更加复杂。"}]},{"ID":"20240510230738-btg61pt","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240510230738-btg61pt","updated":"20240510230802"},"Children":[{"Type":"NodeText","Data":"6.9 纹理光源"}]},{"ID":"20240510230802-l8410sn","Type":"NodeParagraph","Properties":{"id":"20240510230802-l8410sn","updated":"20240510230817"},"Children":[{"Type":"NodeText","Data":"纹理还可以用于为光源添加更加丰富的视觉表现，并且允许光源具有非常复杂的强度分布函数或者聚光灯函数。"}]},{"ID":"20240510230823-skjllo6","Type":"NodeParagraph","Properties":{"id":"20240510230823-skjllo6","updated":"20240510230835"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240510230823-gwic63l.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"投影纹理光源。纹理被投影到茶壶和地面上，并用于控制投影截锥体内的光线分布（位于截锥体外的光线，其强度为0)。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240510230836-6dff0hx","Type":"NodeParagraph","Properties":{"id":"20240510230836-6dff0hx","updated":"20240510230843"},"Children":[{"Type":"NodeText","Data":"任何类型的光源都可以添加纹理，从而实现额外的视觉效果。纹理光源允许艺术家们，通过对纹理进行编辑和修改，从而很轻松地控制照明效果。"}]}]}