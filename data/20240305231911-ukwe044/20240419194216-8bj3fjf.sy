{"ID":"20240419194216-8bj3fjf","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240419194216-8bj3fjf","title":"Chapter5 着色基础 Shading Basics","type":"doc","updated":"20240429200936"},"Children":[{"ID":"20240419194216-15c6b0w","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240419194216-15c6b0w","updated":"20240419202527"},"Children":[{"Type":"NodeText","Data":"5.1 着色模型"}]},{"ID":"20240419202527-4rm9jl1","Type":"NodeParagraph","Properties":{"id":"20240419202527-4rm9jl1","updated":"20240419202544"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);"},"TextMarkType":"text","TextMarkTextContent":"着色模型用于描述物体的颜色是如何随着表面朝向、观察方向和光照等因素的变化而变化的。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);\"}"}]},{"ID":"20240419202545-d8kyepl","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240419202545-d8kyepl","updated":"20240419203425"},"Children":[{"Type":"NodeText","Data":"5.2 光源"}]},{"ID":"20240419203425-0w2tvaq","Type":"NodeParagraph","Properties":{"id":"20240419203425-0w2tvaq","updated":"20240419203943"},"Children":[{"Type":"NodeText","Data":"首先使用一个连续变化的光照强度，来替代有光还是无光的二元条件。这可以通过对完全有光和完全无光之间进行插值获得，但是这也意味着，我们能够设定的光照强度是有限的，即从0到1；或者使用一个没有范围限制的光照强度，并使用其他一些方式来对着色过程产生影响。后者的一个常见做法是将着色模型分为lit（受到光照）和unlit（没有受到光照）两部分，并使用光强系数"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"k_{\\mathrm{light}}"},{"Type":"NodeText","Data":"来对有光部分进行缩放，具体形式如下："}]},{"ID":"20240419203943-t7omrmx","Type":"NodeMathBlock","Properties":{"id":"20240419203943-t7omrmx","updated":"20240419203953"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\mathbf{c}_{\\text {shaded }}=f_{\\text {unlit }}(\\mathbf{n}, \\mathbf{v})+k_{\\text {light }} f_{\\text {lit }}(\\mathbf{l}, \\mathbf{n}, \\mathbf{v})\n\\tag{5.3}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240419203953-ibuy8ir","Type":"NodeParagraph","Properties":{"id":"20240419203953-ibuy8ir","updated":"20240419204048"},"Children":[{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"k_{light}"},{"Type":"NodeText","Data":"只是代表光照的强度系数，如果还想表示光源的RGB颜色"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"c_{light}"},{"Type":"NodeText","Data":"话，可以使用："}]},{"ID":"20240419204048-n790wmj","Type":"NodeMathBlock","Properties":{"id":"20240419204048-n790wmj","updated":"20240419204056"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\mathbf{c}_{\\text {shaded }}=f_{\\text {unlit }}(\\mathbf{n}, \\mathbf{v})+\\mathbf{c}_{\\text {light }} f_{\\text {lit }}(\\mathbf{l}, \\mathbf{n}, \\mathbf{v}),\n\\tag{5.4}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240419204056-efz15y0","Type":"NodeParagraph","Properties":{"id":"20240419204056-efz15y0","updated":"20240419204108"},"Children":[{"Type":"NodeText","Data":"假如场景中有多个光照，则"}]},{"ID":"20240419204109-luxwq3h","Type":"NodeMathBlock","Properties":{"id":"20240419204109-luxwq3h","updated":"20240419204745"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\mathbf{c}_{\\text {shaded }}=f_{\\text {unlit }}(\\mathbf{n}, \\mathbf{v})+ \\sum_{i=1}^{n}\\mathbf{c}_{\\text {light }_i} f_{\\text {lit }}(\\mathbf{l}_i, \\mathbf{n}, \\mathbf{v}).\n\\tag{5.5}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240419204115-p8fgtbu","Type":"NodeParagraph","Properties":{"id":"20240419204115-p8fgtbu","updated":"20240419204145"},"Children":[{"Type":"NodeText","Data":"其中unlit部分"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"f_{\\text {unlit }}(\\mathbf{n}, \\mathbf{v})"},{"Type":"NodeText","Data":"对应“完全不受光照影响时的外观”，此时着色模型会将光照信息二元化，即分为完全有光条件和完全无光条件。"}]},{"ID":"20240419204135-4c8nbtu","Type":"NodeParagraph","Properties":{"id":"20240419204135-4c8nbtu","updated":"20240419204320"},"Children":[{"Type":"NodeText","Data":"unlit部分既可以"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"f=(0,0,0)"},{"Type":"NodeText","Data":"使物体表面不接受光照时显示为黑色，也可以表现出一些风格化的外观。通常来说，着色模型中的这部分会表现出间接光照或者叫做环境光照的效果（即不是直接由光源直接照射到物体表面上所产生的光照效果），例如来自天空盒的光照，或者是光线在周围物体之间进行弹射而形成的光照。"}]},{"ID":"20240419204357-5zqg0gf","Type":"NodeParagraph","Properties":{"id":"20240419204357-5zqg0gf","updated":"20240419204403"},"Children":[{"Type":"NodeText","Data":"为了对表面进行着色，我们可以将光照对表面的影响可视化为一组平行的射线（ray），照射到表面上的射线密度代表了光照的强度。如图"}]},{"ID":"20240419204412-apqm9n4","Type":"NodeParagraph","Properties":{"id":"20240419204412-apqm9n4","updated":"20240419204423"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240419204411-98rolrv.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"上面一行的图展示了光线照射到一个表面上的横截面示意图。其中左图是光线垂直照射在表面上，中图是光线以一个倾斜角度照射在表面上，右图中使用向量点乘来计算了夹角的余弦值。下面一行的图展示了这个横截面（包含光线方向和表面法线）与整个表面的相对位置。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240419204425-db9d2ei","Type":"NodeParagraph","Properties":{"id":"20240419204425-db9d2ei","updated":"20240419204512"},"Children":[{"Type":"NodeText","Data":"光线（射线）之间的间距"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"d"},{"Type":"NodeText","Data":"，与表面法线"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{n}"},{"Type":"NodeText","Data":"和光照方向"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{l}"},{"Type":"NodeText","Data":"之间夹角的余弦值成反比。也就是说，照射到表面上的光线总强度（总能量），与表面法线"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{n}"},{"Type":"NodeText","Data":"和光照方向"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{l}"},{"Type":"NodeText","Data":"之间夹角的余弦值成反比"}]},{"ID":"20240419204512-nh9bzgw","Type":"NodeParagraph","Properties":{"id":"20240419204512-nh9bzgw","updated":"20240419205010"},"Children":[{"Type":"NodeText","Data":"按图中定义的"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"l"},{"Type":"NodeText","Data":"的方向(从表面碰撞点指向光源)，当"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{n} \\cdot\\mathbf{l}\u003e0"},{"Type":"NodeText","Data":"时光照强度与点乘结果成正比，小于0时光线对表面着色没有影响。所以在将光线的着色结果与点乘结果相乘之前，我们需要将点乘结果限制到0，考虑光线方向和表明发现方向之间的关系对着色结果的影响可获得下面的方程："}]},{"ID":"20240419205011-c29em7i","Type":"NodeMathBlock","Properties":{"id":"20240419205011-c29em7i","updated":"20240419205027"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\mathbf{c}_{\\text {shaded }}=f_{\\text {unlit }}(\\mathbf{n}, \\mathbf{v})+\\sum_{i=1}^{n}\\left(\\mathbf{l}_{i} \\cdot \\mathbf{n}\\right)^{+} \\mathbf{c}_{\\mathrm{light}_{i}} f_{\\mathrm{lit}}\\left(\\mathbf{l}_{i}, \\mathbf{n}, \\mathbf{v}\\right)\n\\tag{5.6}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240419205017-ci6con1","Type":"NodeParagraph","Properties":{"id":"20240419205017-ci6con1","updated":"20240419205058"},"Children":[{"Type":"NodeText","Data":"其中，符号x^+来表示限制到0的操作。"}]},{"ID":"20240419205100-8y4vn4l","Type":"NodeParagraph","Properties":{"id":"20240419205100-8y4vn4l","updated":"20240419205115"},"Children":[{"Type":"NodeText","Data":"对于lit部分，最简单的是设定一个恒定颜色，即："}]},{"ID":"20240419205116-f29jr1w","Type":"NodeMathBlock","Properties":{"id":"20240419205116-f29jr1w","updated":"20240419205123"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"f_{\\text {lit }}()=\\mathbf{c}_{\\text {surface }}\n\\tag{5.7}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240419205120-wbql8ys","Type":"NodeParagraph","Properties":{"id":"20240419205120-wbql8ys","updated":"20240419205129"},"Children":[{"Type":"NodeText","Data":"代入5.6有"}]},{"ID":"20240419205129-116ocal","Type":"NodeMathBlock","Properties":{"id":"20240419205129-116ocal","updated":"20240419205133"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\mathbf{c}_{\\text {shaded }}=f_{\\text {unlit }}(\\mathbf{n}, \\mathbf{v})+\\sum_{i=1}^{n}\\left(\\mathbf{l}_{i} \\cdot \\mathbf{n}\\right)^{+} \\mathbf{c}_{\\text {light }_{i}} \\mathbf{c}_{\\text {surface }}\n\\tag{5.8}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240419205133-52rk4mt","Type":"NodeParagraph","Properties":{"id":"20240419205133-52rk4mt","updated":"20240419205214"},"Children":[{"Type":"NodeText","Data":"上述方程的lit部分，就是Lambertian(兰伯特)着色模型。其本身可以用于生成简单的着色，同时它也是许多着色模型中所用到的关键构件。"}]},{"ID":"20240419205220-5x5ykpd","Type":"NodeParagraph","Properties":{"id":"20240419205220-5x5ykpd","updated":"20240419205315"},"Children":[{"Type":"NodeText","Data":"从上述讨论中可以看到一个光源可以通过两个关键参数来与着色模型相互作用："},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"指向光源的光线方向"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{l}"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"，以及光线的颜色"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{c}_{\\text {light }}"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"。不同类型的光源主要区别在于这两个参数在场景中的变化方式。"}]},{"ID":"20240419205316-whozdrk","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240419205316-whozdrk","updated":"20240419205320"},"Children":[{"Type":"NodeText","Data":"5.2.1 方向光"}]},{"ID":"20240419205321-25jzzpr","Type":"NodeParagraph","Properties":{"id":"20240419205321-25jzzpr","updated":"20240419205627"},"Children":[{"Type":"NodeText","Data":"方向光（Directional light）是光源模型中最简单的一个。对于场景中的方向光，其光线方向"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{l}"},{"Type":"NodeText","Data":"和颜色"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{c}_{\\text {light }}"},{"Type":"NodeText","Data":"都是恒定的，除了光线的颜色"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{c}_{\\text {light }}"},{"Type":"NodeText","Data":"可能会被场景中的阴影所减弱。真实世界中的光源都是具有确切位置的，但是在渲染中，"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);"},"TextMarkType":"text","TextMarkTextContent":"方向光是没有位置这个概念的。方向光是一个抽象的概念，当场景到光源的距离相对于场景尺寸而言很大的时候，方向光的效果会很好。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);\"}"}]},{"ID":"20240419205347-tpcv1az","Type":"NodeBlockquote","Properties":{"id":"20240419205347-tpcv1az","updated":"20240419205402"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240419205351-4zzwsl2","Type":"NodeParagraph","Properties":{"id":"20240419205351-4zzwsl2","updated":"20240419205402"},"Children":[{"Type":"NodeText","Data":"一个20英尺外的泛光灯对桌面上的一个立体模型进行照明，我们便可以把这个泛光灯看作是一个方向光。方向光的另一个例子就是地球上被太阳所照亮的场景，但是如果我们讨论的是太阳系内的行星是如何被太阳照亮的话，那么就不太能将太阳看成一个方向光了。"}]}]},{"ID":"20240419205403-6jsz6u8","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240419205403-6jsz6u8","updated":"20240419205435"},"Children":[{"Type":"NodeText","Data":"5.2.2 精确光源"}]},{"ID":"20240419205435-thswwwg","Type":"NodeParagraph","Properties":{"id":"20240419205435-thswwwg","updated":"20240419210051"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);"},"TextMarkType":"text","TextMarkTextContent":"精确光源是具有一个确定位置的光源，也可以叫做定点光源"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);\"}"},{"Type":"NodeText","Data":"，它没有面积、形状和尺寸的概念。"}]},{"ID":"20240419205557-qj40gkh","Type":"NodeParagraph","Properties":{"id":"20240419205557-qj40gkh","updated":"20240419205706"},"Children":[{"Type":"NodeText","Data":"我们使用"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);"},"TextMarkType":"text","TextMarkTextContent":"点光源来描述那些向各个方向均匀发射光线的光源。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);\"}"}]},{"ID":"20240419205706-57nxmqy","Type":"NodeParagraph","Properties":{"id":"20240419205706-57nxmqy","updated":"20240419205835"},"Children":[{"Type":"NodeText","Data":"对于表面是的着色点"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{p_0}"},{"Type":"NodeText","Data":"以及位于点"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{P_{light}}"},{"Type":"NodeText","Data":"的精确光源，其方向"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{l}"},{"Type":"NodeText","Data":"为点"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{p}_0"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"指向点"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{p}_{\\text {light }}"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"的向量，可以这样计算："}]},{"ID":"20240419205835-01h18i5","Type":"NodeMathBlock","Properties":{"id":"20240419205835-01h18i5","updated":"20240419205840"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\mathbf{l}=\\frac{\\mathbf{p}_{\\text {light }}-\\mathbf{p}_{0}}{\\left\\|\\mathbf{p}_{\\text {light }}-\\mathbf{p}_{0}\\right\\|}.\n\\tag{5.9}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240419205840-fv6aqlw","Type":"NodeParagraph","Properties":{"id":"20240419205840-fv6aqlw","updated":"20240419205852"},"Children":[{"Type":"NodeText","Data":"注意这里进行了归一化。"}]},{"ID":"20240419205853-mqff2xf","Type":"NodeParagraph","Properties":{"id":"20240419205853-mqff2xf","updated":"20240419205912"},"Children":[{"Type":"NodeText","Data":"对于精确光源，其光线方向的分步计算过程如下："}]},{"ID":"20240419205912-xraw17a","Type":"NodeMathBlock","Properties":{"id":"20240419205912-xraw17a","updated":"20240419205955"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\begin{aligned} \\mathbf{d} \u0026=\\mathbf{p}_{\\text {light }}-\\mathbf{p}_{0}, \\\\ r \u0026=\\sqrt{\\mathbf{d} \\cdot \\mathbf{d}}, \\\\ \\mathbf{l} \u0026=\\frac{\\mathbf{d}}{r} . \\end{aligned}\n\\tag{5.10}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240419205919-m3t7nop","Type":"NodeParagraph","Properties":{"id":"20240419205919-m3t7nop","updated":"20240419205958"},"Children":[{"Type":"NodeText","Data":"通常我们所需要的中间数据是"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":" r "},{"Type":"NodeText","Data":" ，即精确光源和当前着色点之间的距离。其除了使用"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"r"},{"Type":"NodeText","Data":"来对光线方向进行归一化之外，还可以用于计算光线颜色随着距离的衰减。"}]},{"ID":"20240419205959-9oemwsi","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240419205959-9oemwsi","updated":"20240419210031"},"Children":[{"Type":"NodeText","Data":"5.2.2.1 点光源/泛光灯"}]},{"ID":"20240419210031-o8t22fn","Type":"NodeParagraph","Properties":{"id":"20240419210031-o8t22fn","updated":"20240419210038"},"Children":[{"Type":"NodeText","Data":"向所有方向都均匀发射光线的精确光源被叫做点光源（point light）或者泛光灯（omni light）。"}]},{"ID":"20240419210052-wxew1i5","Type":"NodeParagraph","Properties":{"id":"20240419210052-wxew1i5","updated":"20240419210125"},"Children":[{"Type":"NodeText","Data":"光线的强度"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{c}_{\\text {light }}"},{"Type":"NodeText","Data":"会随着距离r的变化而变化，其中唯一的变化源就是上文提到的距离衰减。如图"}]},{"ID":"20240419210131-c1666tq","Type":"NodeParagraph","Properties":{"id":"20240419210131-c1666tq","updated":"20240419210139"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240419210131-6bytpuu.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"从点光源发出的光线，其间距随着距离 r 的增大而增大，由于这个间距会在两个维度上同时增长，因此光线的强度（即光线的颜色）与 1 / r^2 成正比。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240419210217-5ditpxw","Type":"NodeParagraph","Properties":{"id":"20240419210217-5ditpxw","updated":"20240419210221"},"Children":[{"Type":"NodeText","Data":"光线的强度（即光线的颜色"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{c}_{\\text {light }}"},{"Type":"NodeText","Data":"）与平方距离的倒数成正比，即与"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"1/r^2"},{"Type":"NodeText","Data":"成正比。这个特性使得我们可以使用一个单一的光线参数，来指定"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{c}_{\\text {light }}"},{"Type":"NodeText","Data":"在空间中发生的变化，这个参数记为"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{c}_{\\text {light}_0}"},{"Type":"NodeText","Data":"，即"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{c}_{\\text {light }}"},{"Type":"NodeText","Data":"在固定参考距离"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"r_0"},{"Type":"NodeText","Data":"处的值："}]},{"ID":"20240419210217-4p5zm24","Type":"NodeMathBlock","Properties":{"id":"20240419210217-4p5zm24","updated":"20240419210217"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\mathbf{c}_{\\text {light }}(r)=\\mathbf{c}_{\\text {light }_{0}}\\left(\\frac{r_{0}}{r}\\right)^{2}\n\\tag{5.11}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240419210224-gaqhfoe","Type":"NodeParagraph","Properties":{"id":"20240419210224-gaqhfoe","updated":"20240419210300"},"Children":[{"Type":"NodeText","Data":"式5.11被称为光线的平方反比衰减。虽然这个方程在从技术上来说，的确正确描述了一个点光源的距离衰减，但是它仍然存在一些问题，会使得它在实际着色计算的使用中并不理想。"}]},{"ID":"20240419210302-390o9vt","Type":"NodeList","ListData":{},"Properties":{"id":"20240419210302-390o9vt","updated":"20240419210500"},"Children":[{"ID":"20240419210303-mtyluw3","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240419210303-mtyluw3","updated":"20240419210500"},"Children":[{"ID":"20240419210303-to27eet","Type":"NodeParagraph","Properties":{"id":"20240419210303-to27eet","updated":"20240419210406"},"Children":[{"Type":"NodeText","Data":"当距离较小时（趋近于0）光颜色"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"c_{light}"},{"Type":"NodeText","Data":"会迅速无界增长，当"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"r=0"},{"Type":"NodeText","Data":"时就出现了除灵现象，针对这一问题一个常见的优化方式是给分母加上一个较小的数值："}]},{"ID":"20240419210438-letuepc","Type":"NodeMathBlock","Properties":{"id":"20240419210438-letuepc","updated":"20240419210452"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\mathbf{c}_{\\text {light }}(r)=\\mathbf{c}_{\\text {light }_{0}} \\frac{r_{0}^{2}}{r^{2}+\\epsilon}.\n\\tag{5.12}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240419210440-5g9nodd","Type":"NodeParagraph","Properties":{"id":"20240419210440-5g9nodd","updated":"20240419210500"},"Children":[{"Type":"NodeText","Data":"数值"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\epsilon"},{"Type":"NodeText","Data":"的取值取决于应用程序本身的设定，例如，虚幻引擎中的设定为"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\epsilon = 1 \\text cm^2"},{"Type":"NodeText","Data":"[861]。"}]}]}]},{"ID":"20240419210437-0gwauha","Type":"NodeList","ListData":{},"Properties":{"id":"20240419210437-0gwauha","updated":"20240419210919"},"Children":[{"ID":"20240419210522-d769y81","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240419210522-d769y81","updated":"20240419210919"},"Children":[{"ID":"20240419210522-otxaf55","Type":"NodeParagraph","Properties":{"id":"20240419210522-otxaf55","updated":"20240419210702"},"Children":[{"Type":"NodeText","Data":"当距离较大时，性能会有所降低。因为光照强度随距离增大而不断减小，但用于也不会变为0.为了提高效率，我们希望光线强度会在某个有限的距离处衰减为0."}]},{"ID":"20240419210709-uppstpz","Type":"NodeParagraph","Properties":{"id":"20240419210709-uppstpz","updated":"20240419210735"},"Children":[{"Type":"NodeText","Data":"一种解决方案是将平方反比方程乘以具有所需属性的窗函数："}]},{"ID":"20240419210738-6mqbaid","Type":"NodeMathBlock","Properties":{"id":"20240419210738-6mqbaid","updated":"20240419210751"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"f_{\\text {win }}(r)=\\left(1-\\left(\\frac{r}{r_{\\max }}\\right)^{4}\\right)^{+2}\n\\tag{5.14}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240419210740-llsz54r","Type":"NodeParagraph","Properties":{"id":"20240419210740-llsz54r","updated":"20240419210823"},"Children":[{"Type":"NodeText","Data":"上式是虚幻引擎和寒霜引擎使用的窗函数，方程中的+2意味着，在进行平方操作之前，需要对值进行限制，如果值为负数的话，则将其设置为0。"}]},{"ID":"20240419210833-qusw2eo","Type":"NodeParagraph","Properties":{"id":"20240419210833-qusw2eo","updated":"20240419210852"},"Children":[{"Type":"NodeText","Data":"下图展示了三天曲线，分别是平方反比、窗函数以及两者相乘的结果"}]},{"ID":"20240419210906-xtcsf8r","Type":"NodeParagraph","Properties":{"id":"20240419210906-xtcsf8r","updated":"20240419210919"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240419210906-fs7wnav.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"图中展示了三条曲线，其中蓝色曲线是平方反比曲线（使用了 \\epsilon  来避免分母为0 ，其中 \\epsilon = 1 ），绿色曲线是 方程5.14 中描述的窗函数（其中 r_{max} = 3 ），红色曲线是蓝色曲线和绿色曲线相乘后的结果。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]}]}]},{"ID":"20240419210410-et0pu25","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240419210410-et0pu25","updated":"20240419211121"},"Children":[{"Type":"NodeText","Data":"5.2.2.2 聚光灯"}]},{"ID":"20240419211121-sxnpt3o","Type":"NodeParagraph","Properties":{"id":"20240419211121-sxnpt3o","updated":"20240419211654"},"Children":[{"Type":"NodeText","Data":"与点光源不同的是，"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);"},"TextMarkType":"text","TextMarkTextContent":"现实世界中几乎所有光源的光照，不仅会随着距离的改变而发生变化，同样也会随着方向的改变而发生变化，"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);\"}"},{"Type":"NodeText","Data":"这种变化可以表示为一个方向性的衰减函数"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"f_{\\text {dir }}(\\mathbf{l})"},{"Type":"NodeText","Data":"，它与距离衰减函数组合在一起，便完整定义了光照强度在空间中的变化："}]},{"ID":"20240419211645-7qu9j0v","Type":"NodeMathBlock","Properties":{"id":"20240419211645-7qu9j0v","updated":"20240419211700"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\mathbf{c}_{\\text {light }}=\\mathbf{c}_{\\text {light }_{0}} f_{\\text {dist }}(r) f_{\\text {dir }}(\\mathbf{l})\n\\tag{5.17}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240419211700-l9fcyq8","Type":"NodeParagraph","Properties":{"id":"20240419211700-l9fcyq8","updated":"20240419211721"},"Children":[{"Type":"NodeText","Data":"选择不同的"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"f_{\\text {dir }}(\\mathbf{l})"},{"Type":"NodeText","Data":"可以生成不同的光照效果，其中一种很重要的效果是聚光灯（spotlight）。"}]},{"ID":"20240419211724-avqmldh","Type":"NodeParagraph","Properties":{"id":"20240419211724-avqmldh","updated":"20240419211840"},"Children":[{"Type":"NodeText","Data":"聚光灯将光线投射在一个圆锥体内部。聚光灯方向衰减函数围绕其方向向量"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"s"},{"Type":"NodeText","Data":"具有旋转对称性，因此这个衰减可以表示为向量"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{s}"},{"Type":"NodeText","Data":"，与到达表面的反向光线向量"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{-l}"},{"Type":"NodeText","Data":"之间夹角"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\theta_{s}"},{"Type":"NodeText","Data":"的函数。"}]},{"ID":"20240419212044-qfv4zen","Type":"NodeBlockquote","Properties":{"id":"20240419212044-qfv4zen","updated":"20240419212050"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240419212045-3fzbabe","Type":"NodeParagraph","Properties":{"id":"20240419212045-3fzbabe","updated":"20240419212050"},"Children":[{"Type":"NodeText","Data":"这里的光线向量需要进行取反，这是因为我们是在着色表面上定义光线向量"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{l}"},{"Type":"NodeText","Data":"的，该向量会指向光源，而这里我们需要这个向量指向远离光源的方向。"}]}]},{"ID":"20240419211815-j9o91a2","Type":"NodeParagraph","Properties":{"id":"20240419211815-j9o91a2","updated":"20240419212223"},"Children":[{"Type":"NodeText","Data":"大多数聚光灯函数都会使用包含夹角"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\theta_{s}"},{"Type":"NodeText","Data":"的余弦表达式，这是着色计算中表达角度最常用的方式（正如我们之前所看到的一些着色方程）。通常聚光灯都会有一个"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);"},"TextMarkType":"text","TextMarkTextContent":"本影角"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);\"}"},{"Type":"NodeText","Data":"（umbra angle）"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\theta_{u}"},{"Type":"NodeText","Data":"，对于"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\theta_{s} \\ge \\theta_{u}"},{"Type":"NodeText","Data":"的所有光线，会将其距离衰减函数限制为"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"f_{\\text {dir }}(\\mathbf{l})=0"},{"Type":"NodeText","Data":"。这个角度可以用于剔除，其原理类似于我们之前在点光源所提到的最大衰减距离"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"r_{\\text {max }}"},{"Type":"NodeText","Data":"。聚光灯通常还具有一个"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);"},"TextMarkType":"text","TextMarkTextContent":"半影角"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);\"}"},{"Type":"NodeText","Data":"（penumbra angle）"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\theta_{p}"},{"Type":"NodeText","Data":"，它定义了一个位于内部的小圆锥体，位于这个小圆锥体内部的光线，具有最大的光线强度。如图"}]},{"ID":"20240419212213-pppywh9","Type":"NodeParagraph","Properties":{"id":"20240419212213-pppywh9","updated":"20240419212357"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240419212213-w6q9pkw.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240419212318-n0osg0i","Type":"NodeParagraph","Properties":{"id":"20240419212318-n0osg0i","updated":"20240419212508"},"Children":[{"Type":"NodeText","Data":"有各种方向函数可以用于聚光灯，例如寒霜引擎使用"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"f_{\\text {dir}_{F}}(\\mathbf{l})"},{"Type":"NodeText","Data":"而three.js使用"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"f_{\\text {dir}_{T}}(\\mathbf{l})"}]},{"ID":"20240419212509-m6hvw0d","Type":"NodeMathBlock","Properties":{"id":"20240419212509-m6hvw0d","updated":"20240419212517"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\begin{aligned} t \u0026 =\\left(\\frac{\\cos \\theta_{s}-\\cos \\theta_{u}}{\\cos \\theta_{p}-\\cos \\theta_{u}}\\right)^{\\mp}, \\\\ f_{\\operatorname{dir}_{\\mathrm{F}}}(\\mathbf{1}) \u0026 =t^{2}, \\\\ f_{\\operatorname{dir}_{\\mathrm{T}}}(\\mathbf{l}) \u0026 =\\text { smoothstep }(t)=t^{2}(3-2 t) .\\end{aligned}\n\\tag{5.18}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240419212515-lnscqgw","Type":"NodeParagraph","Properties":{"id":"20240419212515-lnscqgw","updated":"20240419212617"},"Children":[{"Type":"NodeText","Data":"符号"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"x^{\\mp}"},{"Type":"NodeText","Data":"代表了会将x的值限制到0-1之间。其中的smoothstep函数是一个三次多项式，通常用于着色计算中的平滑插值。"}]},{"ID":"20240419212618-fvzn40i","Type":"NodeParagraph","Properties":{"id":"20240419212618-fvzn40i","updated":"20240419212733"},"Children":[{"Type":"NodeText","Data":"下图展示了目前讨论过的光照模型："}]},{"ID":"20240419212745-4ipxeky","Type":"NodeParagraph","Properties":{"id":"20240419212745-4ipxeky","updated":"20240419212757"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240419212745-fxy0xvy.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"上图展示了三种不同的光照类型，从左到右分别是：方向光；没有距离衰减的点光源；有平滑过渡的聚光灯。请注意在第二幅表示点光源的图中，由于光线和表面之间夹角的变化，因此会在边缘的地方变暗。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240419212802-1qmrnpd","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240419212802-1qmrnpd","updated":"20240419212809"},"Children":[{"Type":"NodeText","Data":"5.2.2.3 其他精确光源"}]},{"ID":"20240419212826-k66n3y9","Type":"NodeParagraph","Properties":{"id":"20240419212826-k66n3y9","updated":"20240419212836"},"Children":[{"Type":"NodeText","Data":"参见6.9 /* TODO HERE */"}]},{"ID":"20240419212854-26lusu6","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240419212854-26lusu6","updated":"20240422214007"},"Children":[{"Type":"NodeText","Data":"5.3 实现着色模型"}]},{"ID":"20240422214008-xjpkca7","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240422214008-xjpkca7","updated":"20240422214017"},"Children":[{"Type":"NodeText","Data":"5.3.1 计算频率"}]},{"ID":"20240422214017-d9yp8jj","Type":"NodeParagraph","Properties":{"id":"20240422214017-d9yp8jj","updated":"20240422214038"},"Children":[{"Type":"NodeText","Data":"设计一个着色实现时需要评估它的"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);"},"TextMarkType":"text","TextMarkTextContent":"计算频率"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240422214042-rn7gv93","Type":"NodeList","ListData":{},"Properties":{"id":"20240422214042-rn7gv93","updated":"20240422214442"},"Children":[{"ID":"20240422214043-lx5918x","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240422214043-lx5918x","updated":"20240422214442"},"Children":[{"ID":"20240422214043-idaxjdy","Type":"NodeParagraph","Properties":{"id":"20240422214043-idaxjdy","updated":"20240422214043"},"Children":[{"Type":"NodeText","Data":"首先，需要确定一个给定的计算结果在整个draw call中是否总为常数。"}]},{"ID":"20240422214136-zq5wvk3","Type":"NodeBlockquote","Properties":{"id":"20240422214136-zq5wvk3","updated":"20240422214142"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240422214142-c6hkqbm","Type":"NodeParagraph","Properties":{"id":"20240422214142-c6hkqbm","updated":"20240422214142"},"Children":[{"Type":"NodeText","Data":"尽管GPU的计算着色器可以用于一些开销很大的计算，但是如果这个计算结果是常数的话，那么可以让应用程序来完成（即在CPU上完成），然后通过统一的着色器输入传递给图形API，这样可以大大减少重复计算量。"}]}]},{"ID":"20240422214138-zaob3sd","Type":"NodeList","ListData":{},"Properties":{"id":"20240422214138-zaob3sd","updated":"20240422214442"},"Children":[{"ID":"20240422214145-px1oexx","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240422214145-px1oexx","updated":"20240422214145"},"Children":[{"ID":"20240422214145-7pn0b1g","Type":"NodeParagraph","Properties":{"id":"20240422214145-7pn0b1g","updated":"20240422214214"},"Children":[{"Type":"NodeText","Data":"一种是常数计算。最简单的是着色方程中的常数子表达式。"}]}]},{"ID":"20240422214214-yn4ul6o","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240422214214-yn4ul6o"},"Children":[{"ID":"20240422214214-1k0r7zz","Type":"NodeParagraph","Properties":{"id":"20240422214214-1k0r7zz","updated":"20240422214249"},"Children":[{"Type":"NodeText","Data":"另一种情况是着色结果会变化，但变化频率很慢不需要没帧更新。"}]}]},{"ID":"20240422214305-j8ipzlj","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240422214305-j8ipzlj"},"Children":[{"ID":"20240422214305-vdc2nn2","Type":"NodeParagraph","Properties":{"id":"20240422214305-vdc2nn2","updated":"20240422214415"},"Children":[{"Type":"NodeText","Data":"还有诸如每帧执行一次（链接MVP的计算）的计算，每个模型计算一次（依赖与模型位置信息的光照参数进行更新）或每个draw call计算一次（更新模型上的材质参数）。"}]}]},{"ID":"20240422214415-37vr0m5","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240422214415-37vr0m5"},"Children":[{"ID":"20240422214415-paiht4u","Type":"NodeParagraph","Properties":{"id":"20240422214415-paiht4u","updated":"20240422214430"},"Children":[{"Type":"NodeText","Data":"根据计算频率对着色器输入分组可以大大提高应用程序效率"}]}]},{"ID":"20240422214431-owpni1e","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240422214431-owpni1e","updated":"20240422214442"},"Children":[{"ID":"20240422214431-4p1pjh6","Type":"NodeParagraph","Properties":{"id":"20240422214431-4p1pjh6","updated":"20240422214442"},"Children":[{"Type":"NodeText","Data":"还可以通过最小化常量更新来提升GPU性能。"}]}]}]}]}]},{"ID":"20240422214623-pasv22o","Type":"NodeParagraph","Properties":{"id":"20240422214623-pasv22o","updated":"20240422214700"},"Children":[{"Type":"NodeText","Data":"理论上来说着色计算可以在任一个可编程阶段执行，每个阶段对应不同的计算频率："}]},{"ID":"20240422214704-34kmh2h","Type":"NodeList","ListData":{},"Properties":{"id":"20240422214704-34kmh2h","updated":"20240422214704"},"Children":[{"ID":"20240422214704-keipi8o","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240422214704-keipi8o","updated":"20240422214704"},"Children":[{"ID":"20240422214704-yvw9ik9","Type":"NodeParagraph","Properties":{"id":"20240422214704-yvw9ik9","updated":"20240422214704"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"顶点着色器（Vertex Shader）——在每个曲面细分前的顶点上进行计算。"}]}]},{"ID":"20240422214704-hritbho","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240422214704-hritbho","updated":"20240422214704"},"Children":[{"ID":"20240422214704-2o672zk","Type":"NodeParagraph","Properties":{"id":"20240422214704-2o672zk","updated":"20240422214704"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"壳着色器（Hull Shader）——在每个表面面片上进行计算。"}]}]},{"ID":"20240422214704-cxbtdnz","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240422214704-cxbtdnz","updated":"20240422214704"},"Children":[{"ID":"20240422214704-jzne3b8","Type":"NodeParagraph","Properties":{"id":"20240422214704-jzne3b8","updated":"20240422214704"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"域着色器（Domain shader）——在每个曲面细分后的顶点上进行计算。"}]}]},{"ID":"20240422214704-sol8csf","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240422214704-sol8csf","updated":"20240422214704"},"Children":[{"ID":"20240422214704-c4zxwsy","Type":"NodeParagraph","Properties":{"id":"20240422214704-c4zxwsy","updated":"20240422214704"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"几何着色器（Geometry shader）——在每个图元上进行计算。"}]}]},{"ID":"20240422214704-zyw6cz9","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240422214704-zyw6cz9","updated":"20240422214704"},"Children":[{"ID":"20240422214704-5jxcn3t","Type":"NodeParagraph","Properties":{"id":"20240422214704-5jxcn3t","updated":"20240422214704"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"像素着色器（Pixel shader）——在每个像素上进行计算。"}]}]}]},{"ID":"20240422214705-abdbxq5","Type":"NodeParagraph","Properties":{"id":"20240422214705-abdbxq5","updated":"20240422214940"},"Children":[{"Type":"NodeText","Data":"实际实现中，大部分着色计算逐像素执行，而其他几个阶段主要用于几何操作，为什么要这么做？下面是对逐顶点着色和逐像素着色的对比："}]},{"ID":"20240422214946-fwmvoxp","Type":"NodeParagraph","Properties":{"id":"20240422214946-fwmvoxp","updated":"20240422215034"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"20230111193845"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/20230111193845-20240422214946-00ulmk8.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"使用 方程5.19 中所描述的着色模型，来对比逐顶点着色和逐像素着色之间的区别，其结果分别显示在了三个不同顶点密度的模型上。最左侧的一列图片展示的是逐像素计算的结果；中间一列图片展示的是逐顶点计算的结果；最右侧一列图片展示了模型的线框渲染结果，用于显示顶点密度。 "},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240422215034-se88ksd","Type":"NodeParagraph","Properties":{"id":"20240422215034-se88ksd","updated":"20240422215136"},"Children":[{"Type":"NodeText","Data":"在密度高的网格上，差别很小，但是在密度较小的网格上，顶点着色会导致可见的着色错误。这是因为着色方程的一部分（尤其是高光部分）在网格表面具有非线性变化。这使得它们并不适合在顶点着色器中进行实现，因为顶点着色器的计算结果，会在光栅化阶段被线性插值，然后再输入到像素着色器中。"}]},{"ID":"20240422215302-fisuqji","Type":"NodeParagraph","Properties":{"id":"20240422215302-fisuqji","updated":"20240422215354"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);"},"TextMarkType":"text","TextMarkTextContent":"在大多数实现中，顶点着色器负责的操作都是非着色的，例如几何变换和变形操作。几何表面上的属性在被转换为合适的坐标空间后，最终会被顶点着色器输出，并在三角形上进行线性插值，然后作为可变着色器输入，被传递到像素着色器中，这些属性通常包含了表面位置、表面法线、以及可选的表面切向量（如果需要进行法线映射的话）等。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);\"}"}]},{"ID":"20240422215350-36f1fsq","Type":"NodeParagraph","Properties":{"id":"20240422215350-36f1fsq","updated":"20240422215634"},"Children":[{"Type":"NodeText","Data":"需要注意的是，"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);"},"TextMarkType":"text","TextMarkTextContent":"即使顶点着色器总是会输出单位长度的的表面法线，但是光栅化插值也可能会改变它们的长度"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);\"}"},{"Type":"NodeText","Data":"，如下图。因此需要"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);"},"TextMarkType":"text","TextMarkTextContent":"在像素着色器中重新将法线进行归一化"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);\"}"}]},{"ID":"20240422215704-02lyd75","Type":"NodeParagraph","Properties":{"id":"20240422215704-02lyd75","updated":"20240422215711"},"Children":[{"Type":"NodeText","Data":"虽然如此，在顶点着色器中输出单位长度的法线仍然十分重要，如果顶点之间的法线长度变化很大的话（例如顶点混合的副作用），这将会使得法线插值的结果发生倾斜，如下图的右侧所示。"}]},{"ID":"20240422215713-7y0v4wl","Type":"NodeParagraph","Properties":{"id":"20240422215713-7y0v4wl","updated":"20240422215719"},"Children":[{"Type":"NodeText","Data":"因此在实际的实现中，通常会对插值前和插值后的向量都进行归一化，即在顶点着色器和像素着色器中进行归一化。"}]},{"ID":"20240422215436-9oaqcnk","Type":"NodeParagraph","Properties":{"id":"20240422215436-9oaqcnk","updated":"20240422215527"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240422215436-zscf7ho.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"左图中的两个顶点法线n0 和 n1 都是单位向量，我们可以看到，表面上插值而来的中间向量，其长度均小于单位长度。右图中法线 n0 的长度明显小于 n1 ，这会导致插值结果偏向于两个法线中长度较长的那个。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240422215527-ov8m2pu","Type":"NodeParagraph","Properties":{"id":"20240422215527-ov8m2pu","updated":"20240422215852"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);"},"TextMarkType":"text","TextMarkTextContent":"与表面法线不同，指向特定位置的向量（例如观察向量和光线向量），通常并不会进行插值。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);\"}"},{"Type":"NodeText","Data":"相反，在像素着色器中， 会使用插值而来的表面位置来计算这些向量。除了对向量进行归一化之外（正如我们所看到的，在任何情况下，像素着色器中的向量在使用之前，都需要进行归一化），这些向量都会使用向量减法来进行计算，这样做的速度很快。如果"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);"},"TextMarkType":"text","TextMarkTextContent":"出于某种原因，我们需要对这些向量进行插值的话，那么在插值之前，一定不要对它们进行归一化，因为这样会得到错误的结果"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);\"}"},{"Type":"NodeText","Data":"，如下图所示。"}]},{"ID":"20240422215857-4y6ct26","Type":"NodeParagraph","Properties":{"id":"20240422215857-4y6ct26","updated":"20240422215910"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240422215857-7c3u5xt.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"上图展示的是对两个光线向量进行插值。左图中，在进行插值操作之前，对光线向量进行了归一化，这会导致插值出来的光线方向是错误的；右图中，对两个没有进行归一化的光线向量进行插值，会得到正确的插值向量。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240422215910-xejbpux","Type":"NodeParagraph","Properties":{"id":"20240422215910-xejbpux","updated":"20240422220131"},"Children":[{"Type":"NodeText","Data":"顶点着色器会将表面的几何属性转换到“合适的坐标系”中，最后再输入到像素着色器中。而相机位置和光源位置，通常也需要由应用程序来将其转换到相同的坐标系中，然后再通过统一变量传递给像素着色器。这样做可以最小化像素着色器的重复计算，那么如何选择坐标系呢？"}]},{"ID":"20240422220132-dwlxxds","Type":"NodeParagraph","Properties":{"id":"20240422220132-dwlxxds","updated":"20240422220152"},"Children":[{"Type":"NodeText","Data":"可能的坐标系包括全局事件坐标、当前模型的局部坐标等。应视情况而定。"}]},{"ID":"20240422220153-cxyhjxi","Type":"NodeBlockquote","Properties":{"id":"20240422220153-cxyhjxi","updated":"20240422220201"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240422220154-w170t8s","Type":"NodeParagraph","Properties":{"id":"20240422220154-w170t8s","updated":"20240422220201"},"Children":[{"Type":"NodeText","Data":"如果渲染场景中包含大量的光源，那么可以选择全局的世界空间来避免改变光源的位置；或者最好是选择相机空间，这样可以优化与观察方向相关的像素着色器操作，并提高渲染精度（详见章节16.6）。"}]}]},{"ID":"20240422220206-pjtp33r","Type":"NodeParagraph","Properties":{"id":"20240422220206-pjtp33r","updated":"20240422220323"},"Children":[{"Type":"NodeText","Data":"这里也有一些例外情况，例如平面着色的风格渲染，选择了基于逐图元的着色计算并禁用了顶点插值，这会使第一个顶点的属性被应用到该图元的每个像素上。"}]},{"ID":"20240422220328-e3xdvr7","Type":"NodeParagraph","Properties":{"id":"20240422220328-e3xdvr7","updated":"20240422220346"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240422220327-gd1af0g.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"两个使用平面着色作为画面风格的游戏：上图来自《肯塔基零号公路》，下图来自《癌症似龙》。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240422220346-at7jczv","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240422220346-at7jczv","updated":"20240422220354"},"Children":[{"Type":"NodeText","Data":"5.3.2 实现示例"}]},{"ID":"20240422220358-8qdz0z2","Type":"NodeParagraph","Properties":{"id":"20240422220358-8qdz0z2","updated":"20240422221151"},"Children":[{"Type":"NodeText","Data":"这里实现类似 "},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20240422220907-clap6wp","TextMarkBlockRefSubtype":"d","TextMarkTextContent":"非真实感渲染（NPR） - Gooch着色模型"},{"Type":"NodeText","Data":" 的着色模型，只是这个模型支持多光源，此模型数学描述如下："}]},{"ID":"20240422220444-r3a1nu9","Type":"NodeMathBlock","Properties":{"id":"20240422220444-r3a1nu9","updated":"20240422220453"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\mathbf{c}_{\\text {shaded }}=\\frac{1}{2} \\mathbf{c}_{\\text {cool }}+\\sum_{i=1}^{n}\\left(\\mathbf{l}_{i} \\cdot \\mathbf{n}\\right)^{+} \\mathbf{c}_{\\text {light }_{i}}\\left(s_{i} \\mathbf{c}_{\\text {highlight }}+\\left(1-s_{i}\\right) \\mathbf{c}_{\\text {warm }}\\right),\n\\tag{5.19}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240422220506-i7g3seu","Type":"NodeParagraph","Properties":{"id":"20240422220506-i7g3seu","updated":"20240422220516"},"Children":[{"Type":"NodeText","Data":"其中："}]},{"ID":"20240422220519-1gt7n6d","Type":"NodeMathBlock","Properties":{"id":"20240422220519-1gt7n6d","updated":"20240422221152"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\begin{aligned} \\mathbf{c}_{\\mathrm{cool}} \u0026 =(0,0,0.55)+0.25 \\mathbf{c}_{\\mathrm{surface}}, \\\\ \\mathbf{c}_{\\mathrm{warm}} \u0026 =(0.3,0.3,0)+0.25 \\mathbf{c}_{\\mathrm{surface}}, \\\\ \\mathbf{c}_{\\text {highlight }} \u0026 =(2,2,2), \\\\ \\mathbf{r}_{i} \u0026 =2\\left(\\mathbf{n} \\cdot \\mathbf{l}_{i}\\right) \\mathbf{n}-\\mathbf{l}_{i}, \\\\ s_{i} \u0026 =\\left(100\\left(\\mathbf{r}_{i} \\cdot \\mathbf{v}\\right)-97\\right)^{\\mp} .\\end{aligned}\n\\tag{5.20}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240422220522-3vf67ky","Type":"NodeParagraph","Properties":{"id":"20240422220522-3vf67ky","updated":"20240422220640"},"Children":[{"Type":"NodeText","Data":"此方程长得lit像和unlit项分别为："}]},{"ID":"20240422220641-vda5nt7","Type":"NodeMathBlock","Properties":{"id":"20240422220641-vda5nt7","updated":"20240422220645"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\begin{aligned} f_{\\text {unlit }}(\\mathbf{n}, \\mathbf{v}) \u0026 =\\frac{1}{2} \\mathbf{c}_{\\mathrm{cool}}, \\\\ f_{\\mathrm{lit}}\\left(\\mathbf{l}_{i}, \\mathbf{n}, \\mathbf{v}\\right) \u0026 =s_{i} \\mathbf{c}_{\\text {highlight }}+\\left(1-s_{i}\\right) \\mathbf{c}_{\\text {warm }},\\end{aligned}\n\\tag{5.21}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240422220645-ybx1s97","Type":"NodeParagraph","Properties":{"id":"20240422220645-ybx1s97","updated":"20240422220721"},"Children":[{"Type":"NodeText","Data":"在大多数典型的渲染应用程序中，诸如"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{c}_{\\mathrm{surface}}"},{"Type":"NodeText","Data":"之类的可变材质属性都会存储在顶点数据中，或者更加常见的做法是存储在一张纹理中（第6章）。这里假设"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{c}_{\\mathrm{surface}}"},{"Type":"NodeText","Data":"恒定。"}]},{"ID":"20240422220703-1lbujv4","Type":"NodeParagraph","Properties":{"id":"20240422220703-1lbujv4","updated":"20240422221232"},"Children":[{"Type":"NodeText","Data":"这个着色模型的实现将会使用"},{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);"},"TextMarkType":"text","TextMarkTextContent":"着色器的动态分支功能"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);\"}"},{"Type":"NodeText","Data":"，来对所有的光源进行遍历；这是一种很简单直接的方法，它在一些比较简单的场景中可以正常工作，但是对于一些拥有很多光源的大型复杂场景而言，它的效率就很低了。"}]},{"ID":"20240422221331-275abvn","Type":"NodeParagraph","Properties":{"id":"20240422221331-275abvn","updated":"20240422221348"},"Children":[{"Type":"NodeText","Data":"我们将从“由内而外”的顺序来讲解整个实现过程，首先是从像素着色器开始，然后是顶点着色器，最后是应用程序端的图形API调用(JavaScrpit WebGL + GLSL)。"}]},{"ID":"20240422221349-vrlvhj2","Type":"NodeParagraph","Properties":{"id":"20240422221349-vrlvhj2","updated":"20240422221402"},"Children":[{"Type":"NodeText","Data":"着色器源文件中应当包含对着色器输出的定义，这样的着色器代码才是正确完整的。即着色器输入会分为两类："}]},{"ID":"20240422221403-160izjm","Type":"NodeList","ListData":{},"Properties":{"id":"20240422221403-160izjm","updated":"20240422221616"},"Children":[{"ID":"20240422221404-e0eomgi","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240422221404-e0eomgi","updated":"20240422221616"},"Children":[{"ID":"20240422221404-t86vano","Type":"NodeParagraph","Properties":{"id":"20240422221404-t86vano","updated":"20240422221616"},"Children":[{"Type":"NodeText","Data":"第一类是一组统一(Uniform)输入，这些值是由应用程序进行设置的，并且在一次draw call的过程中会保持不变；"}]}]},{"ID":"20240422221410-a6mupws","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240422221410-a6mupws","updated":"20240422221419"},"Children":[{"ID":"20240422221410-l500eh0","Type":"NodeParagraph","Properties":{"id":"20240422221410-l500eh0","updated":"20240422221419"},"Children":[{"Type":"NodeText","Data":"第二类会包含一系列的可变输入，这些值可以在着色器调用（像素着色器或者顶点着色器）之间发生变化。"}]}]}]},{"ID":"20240422221421-n9hrh8j","Type":"NodeParagraph","Properties":{"id":"20240422221421-n9hrh8j","updated":"20240422221447"},"Children":[{"Type":"NodeText","Data":"下面是一些像素着色器可变输入以及像素着色器输出值："}]},{"ID":"20240422221448-d7vlcfd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240422221448-d7vlcfd","updated":"20240422221455"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"R0xTTA=="},{"Type":"NodeCodeBlockCode","Data":"in vec3 vPos ;\nin vec3 vNormal ;\nout vec4 outColor ;\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240422221456-hux2obj","Type":"NodeParagraph","Properties":{"id":"20240422221456-hux2obj","updated":"20240422221519"},"Children":[{"Type":"NodeText","Data":"这个像素着色器只有一个输出，即最终的着色颜色。而像素着色器的输入与顶点着色器的输出是相匹配的，这些参数在输入像素着色器之前，会在三角形上进行插值。这个像素着色器有两个可变输入：表面位置和表面法线，二者均位于应用程序的世界空间坐标系中。"}]},{"ID":"20240422221523-n0fbj5h","Type":"NodeParagraph","Properties":{"id":"20240422221523-n0fbj5h","updated":"20240422221603"},"Children":[{"Type":"NodeText","Data":"统一输入数量要大得多，简单起见这里只展示两个与光源有关的定义："}]},{"ID":"20240422221605-tkmpt3i","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240422221605-tkmpt3i","updated":"20240422221609"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"R0xTTA=="},{"Type":"NodeCodeBlockCode","Data":"struct Light {\n    vec4 position ;\n    vec4 color ;\n};\nuniform LightUBlock {\n    Light uLights [ MAXLIGHTS ];\n};\nuniform uint uLightCount ;\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240422221611-ztq9ykc","Type":"NodeParagraph","Properties":{"id":"20240422221611-ztq9ykc","updated":"20240422221723"},"Children":[{"Type":"NodeText","Data":"由于这些光源都是点光源，因此每个光源定义中都只包含一个位置和一个颜色。这两个数据都被定义成了"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathsf{vec4}"},{"Type":"NodeText","Data":"类型而不是"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathsf{vec3}"},{"Type":"NodeText","Data":"类型，以符合GLSL "},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathsf{std140}"},{"Type":"NodeText","Data":"数据布局标准的限制。虽然在这个例子中，"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathsf{std140}"},{"Type":"NodeText","Data":"布局会浪费一些空间，但是这简化了确保CPU和GPU之间数据布局一致性的任务。"}]},{"ID":"20240422221725-25dr1o8","Type":"NodeParagraph","Properties":{"id":"20240422221725-25dr1o8","updated":"20240422221739"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong inline-math","TextMarkInlineMathContent":"\\mathsf{Light}"},{"Type":"NodeText","Data":"数组是在一个被标记为"},{"Type":"NodeTextMark","TextMarkType":"strong inline-math","TextMarkInlineMathContent":"\\mathsf{uniform}"},{"Type":"NodeText","Data":"的代码块内部定义的，这是GLSL的一个特性，用于将一组统一变量绑定到一个缓冲区对象中，从而加快数据传输的速度。"}]},{"ID":"20240422221746-z94y22q","Type":"NodeParagraph","Properties":{"id":"20240422221746-z94y22q","updated":"20240422221754"},"Children":[{"Type":"NodeText","Data":"下面是像素着色器的具体代码："}]},{"ID":"20240422221755-2lkkxfm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240422221755-2lkkxfm","updated":"20240422221807"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"R0xTTA=="},{"Type":"NodeCodeBlockCode","Data":"vec3 lit ( vec3 l, vec3 n, vec3 v) {\n    vec3 r_l = reflect (-l, n) ;\n    float s = clamp (100.0 * dot (r_l , v) - 97.0 , 0.0 , 1.0) ;\n    vec3 highlightColor = vec3 (2 ,2 ,2) ;\n    return mix ( uWarmColor , highlightColor , s);\n}\n\nvoid main () {\n    vec3 n = normalize ( vNormal );\n    vec3 v = normalize ( uEyePosition .xyz - vPos );\n    outColor = vec4 ( uFUnlit , 1.0) ;\n  \n    for ( uint i = 0u; i \u003c uLightCount ; i ++) {\n        vec3 l = normalize ( uLights [i]. position . xyz - vPos );\n        float NdL = clamp ( dot (n, l) , 0.0 , 1.0) ;\n        outColor . rgb += NdL * uLights [i]. color . rgb * lit (l,n,v);\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240422221835-1o7xzms","Type":"NodeParagraph","Properties":{"id":"20240422221835-1o7xzms","updated":"20240422221844"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong inline-math","TextMarkInlineMathContent":"f_{unlit}()"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"和"},{"Type":"NodeTextMark","TextMarkType":"strong inline-math","TextMarkInlineMathContent":"c_{warm}"},{"Type":"NodeText","Data":"的值是通过统一变量输出的，由于这些变量的值在一次draw call中都是常数，因此可以由应用程序来计算这些值。"}]},{"ID":"20240422221917-vke7hlh","Type":"NodeParagraph","Properties":{"id":"20240422221917-vke7hlh","updated":"20240422221941"},"Children":[{"Type":"NodeText","Data":"顶点着色器的可变输入和输出定义如下："}]},{"ID":"20240422221941-uwvdw4t","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240422221941-uwvdw4t","updated":"20240422221947"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"R0xTTA=="},{"Type":"NodeCodeBlockCode","Data":"layout ( location = 0) in vec4 position ;\nlayout ( location = 1) in vec4 normal ;\nout vec3 vPos ;\nout vec3 vNormal ;\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240422222002-dolubh4","Type":"NodeParagraph","Properties":{"id":"20240422222002-dolubh4","updated":"20240422222003"},"Children":[{"Type":"NodeText","Data":"顶点着色器的输出项是与像素着色器的输入项匹配的。这些输入参数还包括指定如何在顶点数组中排列数据的指令。顶点着色器的代码如下:"}]},{"ID":"20240422222006-cwd33l5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240422222006-cwd33l5","updated":"20240422222011"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Z2xzbA=="},{"Type":"NodeCodeBlockCode","Data":"void main () {\n    vec4 worldPosition = uModel * position ;\n    vPos = worldPosition.xyz ;\n    vNormal = (uModel * normal ).xyz ;\n    gl_Position = viewProj * worldPosition ;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240422222012-gv7jry1","Type":"NodeParagraph","Properties":{"id":"20240422222012-gv7jry1","updated":"20240422222130"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);"},"TextMarkType":"text","TextMarkTextContent":"需要注意的是，法线向量并没有在顶点着色器中进行归一化，这是因为原始网格数据中的法线长度就已经为1了，并且应用程序没有执行任何可能会改变法线长度的操作，例如顶点混合或者非均匀缩放等。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);\"}"}]},{"ID":"20240422222130-mtw04rj","Type":"NodeParagraph","Properties":{"id":"20240422222130-mtw04rj","updated":"20240422222149"},"Children":[{"Type":"NodeText","Data":"接下来是js代码，略。"}]},{"ID":"20240422222556-3fegf6f","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240422222556-3fegf6f","updated":"20240422222601"},"Children":[{"Type":"NodeText","Data":"5.3.3 材质系统"}]},{"ID":"20240422222601-v1jt05b","Type":"NodeParagraph","Properties":{"id":"20240422222601-v1jt05b","updated":"20240422222624"},"Children":[{"Type":"NodeText","Data":"着色器是一个底层（low-level）的图形API资源，而不是艺术家可以直接进行交互的东西；相比之下，材质（material）对表面的视觉外观进行了封装，它才是直接面向艺术家的资源。"}]},{"ID":"20240422222626-f7bt9zd","Type":"NodeParagraph","Properties":{"id":"20240422222626-f7bt9zd","updated":"20240422222642"},"Children":[{"Type":"NodeText","Data":"此外材质还可描述一些非视觉内容，例如物理材质，不在这里讨论。"}]},{"ID":"20240422222705-sdnqc96","Type":"NodeParagraph","Properties":{"id":"20240422222705-sdnqc96","updated":"20240422222718"},"Children":[{"Type":"NodeText","Data":"材质与着色器不是简单的一对一关系，有时候相同的材质可能也会使用不同的着色器，一个着色器也可能会被多种材质所共享。"}]},{"ID":"20240422222722-18w9y4u","Type":"NodeParagraph","Properties":{"id":"20240422222722-18w9y4u","updated":"20240422224816"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color2);"},"TextMarkType":"text","TextMarkTextContent":"最常见的情况就是参数化材质，在最简单形式中，材质参数化需要两种材质实体：材质模板（material template）和材质实例（material instance）。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color2);\"}"}]},{"ID":"20240422222728-w64gxua","Type":"NodeParagraph","Properties":{"id":"20240422222728-w64gxua","updated":"20240422222742"},"Children":[{"Type":"NodeText","Data":"每个材质模板都描述了一类材质，并且包含了一组参数，根据参数类型的不同，可以为其指定具体的数值、颜色或者纹理贴图等。每个材质实例对应了一个材质模板，以及一组包含所有参数的特定值。"}]},{"ID":"20240422222809-0slfstw","Type":"NodeParagraph","Properties":{"id":"20240422222809-0slfstw","updated":"20240422222810"},"Children":[{"Type":"NodeText","Data":"这些参数可以在运行时，通过统一输入来传递给着色器程序；或者是在着色器编译阶段，通过替换着色器中的一些值来完成。"}]},{"ID":"20240422222811-gfdamsw","Type":"NodeBlockquote","Properties":{"id":"20240422222811-gfdamsw","updated":"20240422222815"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240422222811-j5vnbc5","Type":"NodeParagraph","Properties":{"id":"20240422222811-j5vnbc5","updated":"20240422222815"},"Children":[{"Type":"NodeText","Data":"最常见的编译时参数类型就是一个布尔开关，使用这个布尔值来控制一个给定的材质特性是否会被激活。这样的开关可以由艺术家通过材质GUI中的一个勾选框来进行设置；也可以通过材质系统在程序上进行设置，例如：材质系统可以自动对渲染质量进行调整，来降低远处物体的着色成本，而这个修改在视觉效果上则可以忽略不记。"}]}]},{"ID":"20240422222815-9jsw3wh","Type":"NodeParagraph","Properties":{"id":"20240422222815-9jsw3wh","updated":"20240422222903"},"Children":[{"Type":"NodeText","Data":"材质可以对给定的着色模型参数进行修改，又或者，可能会将多个材质参数，以及顶点插值结果和纹理值作为输入，通过一系列复杂的操作，来计算着色模型中的某一个参数。"}]},{"ID":"20240422222909-o8rd372","Type":"NodeBlockquote","Properties":{"id":"20240422222909-o8rd372","updated":"20240422222914"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240422222909-06nxt53","Type":"NodeParagraph","Properties":{"id":"20240422222909-06nxt53","updated":"20240422222914"},"Children":[{"Type":"NodeText","Data":"在某些情况下，诸如表面位置、表面朝向甚至是时间等参数，都会对计算产生影响。基于表面位置和表面朝向的着色，在地形材质中尤其常见，例如：可以使用高度和表面法线来控制积雪的效果，具体实现方式是在高海拔的水平表面以及近乎水平的表面上，混合叠加一个白色。基于时间的着色在动画材质中十分常见，例如闪烁的霓虹灯标志。"}]}]},{"ID":"20240422222917-3ovstck","Type":"NodeParagraph","Properties":{"id":"20240422222917-3ovstck","updated":"20240422222944"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);"},"TextMarkType":"text","TextMarkTextContent":"材质系统最重要的任务之一，就是将各种着色器功能划分为独立的元素，并控制这些元素的组合方式。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);\"}"},{"Type":"NodeText","Data":"这种组合是十分有用的，例如以下几种情况："}]},{"ID":"20240422223012-dbcthst","Type":"NodeList","ListData":{},"Properties":{"id":"20240422223012-dbcthst","updated":"20240422223215"},"Children":[{"ID":"20240422223012-skh19bt","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240422223012-skh19bt","updated":"20240422223012"},"Children":[{"ID":"20240422223012-d7ctnir","Type":"NodeParagraph","Properties":{"id":"20240422223012-d7ctnir","updated":"20240422223024"},"Children":[{"Type":"NodeText","Data":"将表面着色和几何处理结合在一起。"}]},{"ID":"20240422223024-u3b5t4d","Type":"NodeBlockquote","Properties":{"id":"20240422223024-u3b5t4d","updated":"20240422223039"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240422223039-qt5q0sz","Type":"NodeParagraph","Properties":{"id":"20240422223039-qt5q0sz","updated":"20240422223039"},"Children":[{"Type":"NodeText","Data":"例如刚体变换、顶点混合、曲面细分、实例化以及裁剪等。"}]}]},{"ID":"20240422223036-1q9x949","Type":"NodeParagraph","Properties":{"id":"20240422223036-1q9x949","updated":"20240422223036"},"Children":[{"Type":"NodeText","Data":"这些功能是独立变化的：表面着色依赖于材质，而几何处理则依赖于模型网格。因此，将这些功能分开编写，并使用材质系统对它们进行按需组合是十分方便的。"}]}]},{"ID":"20240422223012-rak7f6e","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240422223012-rak7f6e","updated":"20240422223012"},"Children":[{"ID":"20240422223012-fsw70l5","Type":"NodeParagraph","Properties":{"id":"20240422223012-fsw70l5","updated":"20240422223100"},"Children":[{"Type":"NodeText","Data":"将表面着色和一些合并操作组合在一起"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"，"}]}]},{"ID":"20240422223103-t12q89f","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240422223103-t12q89f"},"Children":[{"ID":"20240422223103-52iof3c","Type":"NodeBlockquote","Properties":{"id":"20240422223103-52iof3c","updated":"20240422223103"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240422223103-t9hvrin","Type":"NodeParagraph","Properties":{"id":"20240422223103-t9hvrin","updated":"20240422223103"},"Children":[{"Type":"NodeText","Data":"例如像素丢弃（discard）和像素混合（blending），这与移动端的GPU尤其相关，因为其中的混合通常是在像素着色器中执行的。通常我们都希望独立于着色材质来选择这些特殊操作"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"。"}]}]}]},{"ID":"20240422223012-9p5k5ny","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240422223012-9p5k5ny","updated":"20240422223012"},"Children":[{"ID":"20240422223012-wypqxzq","Type":"NodeParagraph","Properties":{"id":"20240422223012-wypqxzq","updated":"20240422223115"},"Children":[{"Type":"NodeText","Data":"将计算着色模型参数的操作，与计算着色模型本身的操作组合在一起。这样做可以在计算其他着色模型的时候，复用之前已经实现过的操作和函数。"}]}]},{"ID":"20240422223012-n4mg0hb","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240422223012-n4mg0hb","updated":"20240422223012"},"Children":[{"ID":"20240422223012-mlx4vx0","Type":"NodeParagraph","Properties":{"id":"20240422223012-mlx4vx0","updated":"20240422223120"},"Children":[{"Type":"NodeText","Data":"将独立可选的材质特性相互组合，并与逻辑选择、着色器的剩余部分组合在一起。这种方式允许独立编写每个材质特性的实现。"}]}]},{"ID":"20240422223012-vorzlrq","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240422223012-vorzlrq","updated":"20240422223215"},"Children":[{"ID":"20240422223012-xon1z1e","Type":"NodeParagraph","Properties":{"id":"20240422223012-xon1z1e","updated":"20240422223141"},"Children":[{"Type":"NodeText","Data":"将着色模型及其参数计算，与光源计算组合在一起：即计算每个光源在着色点上的颜色"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{c}_{light}"},{"Type":"NodeText","Data":"和方向"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{l}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240422223201-fuamjpa","Type":"NodeBlockquote","Properties":{"id":"20240422223201-fuamjpa","updated":"20240422223215"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240422223202-z3nje7n","Type":"NodeParagraph","Properties":{"id":"20240422223202-z3nje7n","updated":"20240422223215"},"Children":[{"Type":"NodeText","Data":"例如延迟渲染等技术（TODO: Ref: Chapter20）可以改变这种组合的结构。在支持多种此类技术的渲染框架中，这增加了额外的复杂性。"}]}]}]}]},{"ID":"20240422223224-v5jh2vq","Type":"NodeParagraph","Properties":{"id":"20240422223224-v5jh2vq","updated":"20240422223526"},"Children":[{"Type":"NodeText","Data":"与CPU代码不同，GPU着色器并不允许在编译后再去链接代码片段，即每个着色器阶段的程序都会被编译成一个独立的单元。材质系统能够实现上述这些组合类型的唯一方法，就是在源代码级别进行组合。这主要涉及字符串操作（例如连接和替换），这通常是通过类似于C语言风格的预处理指令来完成，例如"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"#include"},{"Type":"NodeText","Data":"​ "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"#if"},{"Type":"NodeText","Data":"​和"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"#define"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20240422223345-5a9g3kd","Type":"NodeParagraph","Properties":{"id":"20240422223345-5a9g3kd","updated":"20240422223519"},"Children":[{"Type":"NodeText","Data":"当设计一个用于处理着色器变体的系统时，需要解决的第一个问题就是：不同选项之间的选择，是在运行时使用动态分支来完成的，还是在编译时通过条件预处理来完成。"}]},{"ID":"20240422223526-ws2v8jh","Type":"NodeBlockquote","Properties":{"id":"20240422223526-ws2v8jh","updated":"20240422223610"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240422223551-3542tx2","Type":"NodeParagraph","Properties":{"id":"20240422223551-3542tx2","updated":"20240422223610"},"Children":[{"Type":"NodeText","Data":"当前的GPU硬件可以很好的支持动态分支，尤其是当该分支在一次draw call中对所有的像素做相同处理的时候。如今很多功能变体，例如光源数量，都是在运行时处理的。但是，向着色器中添加大量功能变体会带来另一种不同的开销：寄存器计数的增加，以及占用率的降低，从而导致性能下降（TODO: Ref 18.4.5）。因此在编译阶段处理变体仍然是很有价值的，它能够避免包含那些从不被执行的复杂逻辑。"}]}]},{"ID":"20240422223655-znm8pwb","Type":"NodeParagraph","Properties":{"id":"20240422223655-znm8pwb","updated":"20240422223655"},"Children":[{"Type":"NodeText","Data":"现代的材质系统会同时使用运行时着色器变体和编译时着色器变体。尽管现在我们并不只在编译阶段进行处理，但是总体的复杂性和变体数量仍在不断增加，因此仍然有大量的着色器变体需要进行编译。"}]},{"ID":"20240422223826-t06om6j","Type":"NodeBlockquote","Properties":{"id":"20240422223826-t06om6j","updated":"20240422223858"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240422223854-p6262la","Type":"NodeParagraph","Properties":{"id":"20240422223854-p6262la","updated":"20240422223858"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Unity 渲染系统中有着接近 1000 亿个可能的着色器变体。虽然只有那些实际用到的变体才会进行编译，但是必须要对着色器编译系统进行重新设计，才能处理数量如此巨大的潜在变体"},{"Type":"NodeText","Data":"["},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"1439]。"}]}]},{"ID":"20240422223859-95kcrct","Type":"NodeParagraph","Properties":{"id":"20240422223859-95kcrct","updated":"20240422223909"},"Children":[{"Type":"NodeText","Data":"有不同的策略来解决这些设计目标："}]},{"ID":"20240422223910-vkh69ke","Type":"NodeList","ListData":{},"Properties":{"id":"20240422223910-vkh69ke","updated":"20240422224603"},"Children":[{"ID":"20240422223911-zq8nsdy","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240422223911-zq8nsdy","updated":"20240422223911"},"Children":[{"ID":"20240422223911-oyk1n5n","Type":"NodeParagraph","Properties":{"id":"20240422223911-oyk1n5n","updated":"20240422223932"},"Children":[{"Type":"NodeText","Data":"代码复用——在共享文件中实现可复用的函数，使用预处理指令"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"#include"},{"Type":"NodeText","Data":"​，可以在任何需要的着色器中访问这些函数。"}]}]},{"ID":"20240422223950-588jhyr","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240422223950-588jhyr"},"Children":[{"ID":"20240422223950-5j963om","Type":"NodeParagraph","Properties":{"id":"20240422223950-5j963om","updated":"20240422223958"},"Children":[{"Type":"NodeText","Data":"做减法——如果一个着色器中聚合了大量的功能特性，它通常会被称作为“超级着色器（uber shader or super shader）”[1170, 1784]，灵活使用编译时的预处理指令与动态分支的组合，来移除那些无用的部分，并在互斥的备选方案中进行切换。"}]}]},{"ID":"20240422224012-6vejt7e","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240422224012-6vejt7e"},"Children":[{"ID":"20240422224012-o1rppox","Type":"NodeParagraph","Properties":{"id":"20240422224012-o1rppox","updated":"20240422224013"},"Children":[{"Type":"NodeText","Data":"做加法——将各种单位功能定义成具有输入输出连接器的节点，这些功能节点可以被组合在一起。"}]},{"ID":"20240422224023-ewq05ex","Type":"NodeBlockquote","Properties":{"id":"20240422224023-ewq05ex","updated":"20240422224127"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240422224127-051s8cq","Type":"NodeParagraph","Properties":{"id":"20240422224127-051s8cq","updated":"20240422224127"},"Children":[{"Type":"NodeText","Data":"这有点类似于代码复用策略，但是更加结构化。这些节点的组合可以通过使用文本[342]或者一个可视化编辑器来完成，后者旨在让非工程师的成员（例如技术美术）更易于编写新的材质模板[1750, 1802]。但是这种可视化方案也存在一些缺陷，即只能访问部分的着色器，例如：虚幻引擎中的材质图形编辑器，只能作用于着色模型输入参数的相关计算[1802]，如下图所示。"}]}]},{"ID":"20240422224101-at7s4kp","Type":"NodeParagraph","Properties":{"id":"20240422224101-at7s4kp","updated":"20240422224118"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240422224101-7mmsbiv.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"虚幻引擎的材质编辑器。请注意右侧最长的那个节点，该节点的输入连接器对应了渲染引擎所使用的各种着色输入，包括着色模型所需的所有参数。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20240422224131-nh4aia2","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240422224131-nh4aia2","updated":"20240422224603"},"Children":[{"ID":"20240422224131-hemc4px","Type":"NodeParagraph","Properties":{"id":"20240422224131-hemc4px","updated":"20240422224211"},"Children":[{"Type":"NodeText","Data":"基于模板——现在有一个定义好了的接口，只要符合这个接口的定义，那么就可以接入不同的实现。这要比加法策略更加正式一点，通常会用于更大的模块中。"}]},{"ID":"20240422224212-h3pfm57","Type":"NodeBlockquote","Properties":{"id":"20240422224212-h3pfm57","updated":"20240422224603"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240422224212-gee53y5","Type":"NodeParagraph","Properties":{"id":"20240422224212-gee53y5","updated":"20240422224359"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"这种接口的一个常见例子是，将着色模型参数的计算与着色模型本身的计算分离开来，例如："}]},{"ID":"20240422224409-482uqgu","Type":"NodeParagraph","Properties":{"id":"20240422224409-482uqgu","updated":"20240422224603"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"虚幻引擎"},{"Type":"NodeText","Data":"["},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"1802]中有着不同的“材质域（material domain）”，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color4);"},"TextMarkType":"text","TextMarkTextContent":"它包含了用于计算着色模型参数的表面域（Surface domain），以及用于计算缩放系数（这个系数用于对一个给定光源的"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color4);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color4);"},"TextMarkType":"inline-math text","TextMarkInlineMathContent":"c_{light}"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color4);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color4);"},"TextMarkType":"text","TextMarkTextContent":"进行调整）的光照函数域（Light Function domain）。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color4);\"}"}]},{"ID":"20240422224408-24xf698","Type":"NodeParagraph","Properties":{"id":"20240422224408-24xf698","updated":"20240422224408"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"在Unity引擎"},{"Type":"NodeText","Data":"["},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"1437]中也存在一个类似的“表面着色器（surface shader）”结构。值得注意的是，延迟渲染技术会使用G-buffer来作为接口，强制要求执行一个类似的着色器结构（即统一的着色模型），TODO: Ref Chapter20"}]}]}]}]},{"ID":"20240422223930-fgcrg23","Type":"NodeParagraph","Properties":{"id":"20240422223930-fgcrg23","updated":"20240422224623"},"Children":[{"Type":"NodeText","Data":"现代的材质系统还有几个重要的设计考虑事项，例如：如何以最小的着色器代码重复来支持多个平台。这会产生一些额外的着色器变体，以解决平台、着色器语言以及API之间的性能差异和功能差异。"}]},{"ID":"20240422224624-1ae3uf6","Type":"NodeBlockquote","Properties":{"id":"20240422224624-1ae3uf6","updated":"20240422224630"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240422224625-qkph445","Type":"NodeParagraph","Properties":{"id":"20240422224625-qkph445","updated":"20240422224630"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"《命运》的着色器系统"},{"Type":"NodeText","Data":"["},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"1750]是这类问题的一个代表性解决方案，它使用了一个专门的预处理层，能够使用自定义的着色器语言来进行着色器编写。这允许开发人员编写与平台无关的材质，并将其自动转换为不同的着色语言和着色实现。虚幻引擎"},{"Type":"NodeText","Data":"["},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"1802]和Unity引擎"},{"Type":"NodeText","Data":"["},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"1436]也都具有类似的系统。"}]}]},{"ID":"20240422224630-z5e3yg4","Type":"NodeParagraph","Properties":{"id":"20240422224630-z5e3yg4","updated":"20240422224637"},"Children":[{"Type":"NodeText","Data":"材质系统还需要保证良好的性能，除了专门的着色器变体编译之外，材质系统还可以执行一些常见的其他优化。"}]},{"ID":"20240422224639-e95u0y3","Type":"NodeBlockquote","Properties":{"id":"20240422224639-e95u0y3","updated":"20240422224645"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240422224639-wdfcgmq","Type":"NodeParagraph","Properties":{"id":"20240422224639-wdfcgmq","updated":"20240422224645"},"Children":[{"Type":"NodeText","Data":"《命运》和虚幻引擎的着色器系统，会自动检测在一次draw call中结果为常数的计算（例如章节5.3.2示例程序中的暖色和冷色计算），并将其移动到着色器之外进行。另外一个例子是《命运》中所使用的作用域系统（scope system），它用来区分不同更新频率的常量（例如：每帧更新一次，每个光源更新一次，每个物体更新一次），并在适当的时候对每一组常量进行更新，从而减少API的开销。"}]}]},{"ID":"20240422224646-b36zzuc","Type":"NodeParagraph","Properties":{"id":"20240422224646-b36zzuc","updated":"20240422224657"},"Children":[{"Type":"NodeText","Data":"正如我们所看到的，实现一个着色方程是很简单的，重要的是决定哪些部分是能够简化的，如何计算各种表达式的出现频率，以及用户如何能够对材质外观进行修改和控制。"}]},{"ID":"20240422224700-aeklurk","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240422224700-aeklurk","updated":"20240422224706"},"Children":[{"Type":"NodeText","Data":"5.4 锯齿和抗锯齿"}]},{"ID":"20240423161625-uyw50cd","Type":"NodeParagraph","Properties":{"id":"20240423161625-uyw50cd","updated":"20240423161642"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240423161625-ovzok6c.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"第一行图像展示了三个具有不同抗锯齿级别的三角形、线和点。第二行图像是上面图像放大数倍之后的结果。最左边一列图像在每个像素中仅使用了一个样本，即没有使用抗锯齿技术；中间一列图像在每个像素上使用了4个样本（网格模式）；最右边一列图像在每个像素上使用了8个样本（ 4 X 4 棋盘格模式，采样了正方形区域中的一半）。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240423161643-p9ccy0f","Type":"NodeParagraph","Properties":{"id":"20240423161643-p9ccy0f","updated":"20240423161740"},"Children":[{"Type":"NodeText","Data":"三角形会以像素的形式显示出来，一个网格像素要么被覆盖，要么不被覆盖，绘制出来的线也有类似的问题。由于这个原因，因此三角形和线段的边界会呈现出锯齿状，这个视觉瑕疵被称作为“"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"锯齿（the jaggies）"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"”。更正式地说，这个问题被称作为"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"“走样（aliasing）”"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"，避免这个问题地技术被称作"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"“反走样（antialiasing）”"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240423161737-uustqvb","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240423161737-uustqvb","updated":"20240423161801"},"Children":[{"Type":"NodeText","Data":"5.4.1 采样和滤波理论"}]},{"ID":"20240423161833-45gckgl","Type":"NodeParagraph","Properties":{"id":"20240423161833-45gckgl","updated":"20240423161843"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"渲染图像的过程本质上是一个采样任务。这是因为图像的生成实际上就是对三维场景进行采样的过程，从而获得图像（离散像素数组）中每个像素的颜色值。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"}]},{"ID":"20240423161844-nk6nwdg","Type":"NodeParagraph","Properties":{"id":"20240423161844-nk6nwdg","updated":"20240423161923"},"Children":[{"Type":"NodeText","Data":"下图展示了一段连续信号如何均匀间隔采样的过程，此过程也被成为离散化。"}]},{"ID":"20240423161926-ooqdixa","Type":"NodeParagraph","Properties":{"id":"20240423161926-ooqdixa","updated":"20240423161934"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240423161926-kzn984c.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"对一个连续信号（左图）进行采样（中图），然后通过重建方法来将其恢复成原始信号（右图）。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240423161935-8cx6t3c","Type":"NodeParagraph","Properties":{"id":"20240423161935-8cx6t3c","updated":"20240423161953"},"Children":[{"Type":"NodeText","Data":"每当进行采样的时候，都可能会发生走样现象。"}]},{"ID":"20240423162013-cctey80","Type":"NodeParagraph","Properties":{"id":"20240423162013-cctey80","updated":"20240423162035"},"Children":[{"Type":"NodeText","Data":"在老西部片中有一个经典的走样案例，就是使用电影摄像机来拍摄旋转的马车轮子。由于车轮辐条的旋转速度要比相机记录图像的速度快得多，因此车轮可能会看起来旋转得很慢（向前旋转或者向后旋转），甚至可能会看起来根本没有发生旋转，如图5.16所示。之所以会出现这种现象，是因为车轮图像是在一系列时间步长内进行拍摄的，这种现象被称作"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"时域走样（temporal aliasing）"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240423162039-tueq6qj","Type":"NodeParagraph","Properties":{"id":"20240423162039-tueq6qj","updated":"20240423162047"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240423162039-2o9azo7.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"第一行展示了一个旋转的车轮（原始信号）。第二行对信号进行了采样，但是采样并不充分，使得车轮看起来向着相反的方向旋转，这是由于采样率（sample rate）过低而导致走样的一个例子。第三行的采样率正好是每旋转一周采样两次，因此我们无法确定车轮的旋转方向，这就是Nyquist极限。在第四行中，采样率大于第三行的采样率，我们可以看到车轮向着正确的方向旋转。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240423162047-vcatgez","Type":"NodeParagraph","Properties":{"id":"20240423162047-vcatgez","updated":"20240423162207"},"Children":[{"Type":"NodeText","Data":"计算机图形学中常见的走样例子，是光栅化线段或者三角形边界上出现“锯齿（jaggies）”；以及当一个具有格子图案的纹理被缩小显示时，会出现被称为“萤火虫（firefly）”的高亮闪烁（摩尔纹）（TODO: Ref 6.2.2）。"}]},{"ID":"20240423162237-fuw6u9m","Type":"NodeParagraph","Properties":{"id":"20240423162237-fuw6u9m","updated":"20240423162315"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"当一个信号的采样率过低时，就会出现走样现象（在光栅化游戏中，屏幕的分辨率大体决定了采样率，因此屏幕分辨率越高，走样和锯齿现象就越少）"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。此时采样信号的频率会比原始信号低，如图所示。为了对一个信号进行正确的采样（即可以从采样出来的样本中，重建原始信号），采样率必须要在采样信号最大频率的两倍以上。这通常被称作采样定理（sampling theorem），对应的采样率叫做Nyquist率[1447]或者Nyquist极限，它由瑞典科学家Harry Nyquist （1889–1976）在1928发现的。"}]},{"ID":"20240423162304-97my229","Type":"NodeParagraph","Properties":{"id":"20240423162304-97my229","updated":"20240423162450"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240423162304-8twtrjw.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"图中的蓝色实线代表了原始信号，红点代表了均匀间隔的采样点，绿色虚线代表了重建后的信号。第一行展示了采样率过低时的情况，重建后的信号看起来频率较低，即原始信号出现了走样。第二行的采样率是原始信号频率的两倍，重建后的信号是一条水平线。这可以证明，如果采样率稍微增加一点点，可能就可以对原始信号进行完美重建。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240423162313-l9fzi6g","Type":"NodeParagraph","Properties":{"id":"20240423162313-l9fzi6g","updated":"20240423162651"},"Children":[{"Type":"NodeText","Data":"当使用点样本（像素点渲染）对三维场景进行采样的时候，正常情况下是不会有频宽限制的，这是因为三角形的边界，阴影的边界以及其他会产生不连续信号的现象，会导致三维场景中的频率是没有上限的[252]。此外，无论采样样本排列的有多么紧密，场景中的物体都可以被继续缩小，使得它们根本无法被采样。"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"因此，在使用点样本来渲染场景的时候，我们是无法完全避免走样现象的，而且我们通常都会使用点采样进行采样。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"}]},{"ID":"20240423162611-bfr07xd","Type":"NodeParagraph","Properties":{"id":"20240423162611-bfr07xd","updated":"20240423162743"},"Children":[{"Type":"NodeText","Data":"但是有时候，我们也可以知道一个信号是有限频宽的，其中"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"一个例子就是在将纹理应用到曲面上的时候。因为我们此时知道了像素的采样率，同时也可以计算出纹理采样的频率，如果这二者之比小于Nyquist极限的话，那么我们就不需要采取什么特殊手段，直接就可以进行正确的纹理采样"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"；但是如果这个比例太高的话，我们就需要利用各种算法，来对纹理采样进行频宽限制（TODO: Ref: 6.2.2）。"}]},{"ID":"20240423162735-24azb7x","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240423162735-24azb7x","updated":"20240423162753"},"Children":[{"Type":"NodeText","Data":"5.4.1.1 重建"}]},{"ID":"20240423162754-mwra2h5","Type":"NodeParagraph","Properties":{"id":"20240423162754-mwra2h5","updated":"20240423163001"},"Children":[{"Type":"NodeText","Data":"从采样信号中重建原始信号，必须使用一个滤波器，下图是三种常见滤波器：（滤波积分面积应当始终为1，否则重建后的信号会被放大或缩小）"}]},{"ID":"20240423162922-gs5e6ge","Type":"NodeParagraph","Properties":{"id":"20240423162922-gs5e6ge","updated":"20240423162931"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240423162922-d2iuays.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"左上角为box滤波器，右上角是tent滤波器，下方是sinc滤波器"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240423162931-64ep09o","Type":"NodeParagraph","Properties":{"id":"20240423162931-64ep09o","updated":"20240423163155"},"Children":[{"Type":"NodeText","Data":"下图是使用Box滤波器进行的重建。"}]},{"ID":"20240423163159-8fwzr8y","Type":"NodeParagraph","Properties":{"id":"20240423163159-8fwzr8y","updated":"20240423163211"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240423163159-yuknfe7.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"使用box滤波器对采样信号（左）进行重建。这是通过将box滤波器放置在每个采样点上得到的，并在 y 轴方向上对其进行缩放，使得滤波器的高度与采样点相一致。对这些变换后的box函数求和，即可获得重建后的信号（右）。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240423163211-mvsnpcv","Type":"NodeParagraph","Properties":{"id":"20240423163211-mvsnpcv","updated":"20240423163312"},"Children":[{"Type":"NodeText","Data":"下图使用了tent滤波器（也称三角滤波器）"}]},{"ID":"20240423163342-lro11g3","Type":"NodeParagraph","Properties":{"id":"20240423163342-lro11g3","updated":"20240423163353"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240423163341-lqmdyrt.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"使用tent滤波器来对采样信号（左）进行重建。右图展示了重建后的连续信号。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240423163353-kchsi8j","Type":"NodeParagraph","Properties":{"id":"20240423163353-kchsi8j","updated":"20240423163423"},"Children":[{"Type":"NodeText","Data":"此滤波器重建后的平滑性较差，信号会在采样点位置发生冲突。"}]},{"ID":"20240423163437-h0qzu4f","Type":"NodeParagraph","Properties":{"id":"20240423163437-h0qzu4f","updated":"20240423163514"},"Children":[{"Type":"NodeText","Data":"为了获得较为完美的重建信号，我们必须使用一个理想的低通滤波器（low-pass filter）。将一个信号进行分解，最终可以表示为若干正弦波（"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\sin (2\\pi f)"},{"Type":"NodeText","Data":"）的组合，其中"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"f"},{"Type":"NodeText","Data":"是该分量的频率。低通滤波器有一个特点，它会移除所有高于某个特定频率的分量，这个特定频率是由低通滤波器本身所决定的。"}]},{"ID":"20240423163511-i9xlq5n","Type":"NodeParagraph","Properties":{"id":"20240423163511-i9xlq5n","updated":"20240423163550"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"从直观上看低通滤波器消除了信号的尖锐特征，即对信号进行了模糊处理。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"}]},{"ID":"20240423163642-whacl9c","Type":"NodeParagraph","Properties":{"id":"20240423163642-whacl9c","updated":"20240423163716"},"Children":[{"Type":"NodeText","Data":"sinc滤波器是一个理想的低通滤波器。其数学表达式为："}]},{"ID":"20240423163717-swx61d8","Type":"NodeMathBlock","Properties":{"id":"20240423163717-swx61d8","updated":"20240423163735"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\operatorname{sinc}(x)=\\frac{\\sin (\\pi x)}{\\pi x}\n\\tag{5.22}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240423163735-ulx23a9","Type":"NodeParagraph","Properties":{"id":"20240423163735-ulx23a9","updated":"20240423164454"},"Children":[{"Type":"NodeText","Data":"理想低通滤波器是频域的Box滤波器，当它与信号相乘的时候，会移除所有超出滤波器宽度的频率。将这个box滤波器从频域转换到空间域（spatial domain），便可以得到一个sinc滤波器。同时频域相乘会转换为时域卷积。"}]},{"ID":"20240423164726-shcf4ak","Type":"NodeParagraph","Properties":{"id":"20240423164726-shcf4ak","updated":"20240423165146"},"Children":[{"Type":"NodeText","Data":"用sinc滤波器进行信号重建，可以获得更加平滑的结果，如图："}]},{"ID":"20240423165150-rwy9n80","Type":"NodeParagraph","Properties":{"id":"20240423165150-rwy9n80","updated":"20240423165159"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240423165150-b2fqkmo.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"这里我们使用了sinc滤波器来重建采样信号，sinc滤波器是一个理想的低通滤波器。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240423165159-2t9d9lm","Type":"NodeParagraph","Properties":{"id":"20240423165159-2t9d9lm","updated":"20240423165237"},"Children":[{"Type":"NodeText","Data":"采样过程中会在信号引入高频分量（体现在函数图像中即突变点）。低通滤波器的任务就是移除这些高频分量。"}]},{"ID":"20240423165300-bpn1uiu","Type":"NodeBlockquote","Properties":{"id":"20240423165300-bpn1uiu","updated":"20240423165329"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240423165301-d5l7oqx","Type":"NodeParagraph","Properties":{"id":"20240423165301-d5l7oqx","updated":"20240423165329"},"Children":[{"Type":"NodeText","Data":"事实上，sinc滤波器消除了所有频率高于采样率1/2的正弦波。当采样率为1的时候（即采样信号的最大频率必须小于"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"1/2"},{"Type":"NodeText","Data":"），方程5.22所描述的sinc滤波器便是一个完美的重建滤波器。更加一般的描述是，假设采样率为"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"f_s /2"},{"Type":"NodeText","Data":"（即意味着相邻样本之间的间距为"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"1 / f_s"},{"Type":"NodeText","Data":"），对于这种情况，完美的重建滤波器就是"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"sinc(f_s x)"},{"Type":"NodeText","Data":"，它会消除所有高于"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"f_s /2"},{"Type":"NodeText","Data":"的频率，这对于信号的重采样十分有用（下一小节的内容）。但是由于sinc滤波器的宽度是无限的，而且在某些区域为负，因此在实际中很少会进行使用。"}]}]},{"ID":"20240423165305-4nzntui","Type":"NodeParagraph","Properties":{"id":"20240423165305-4nzntui","updated":"20240423165525"},"Children":[{"Type":"NodeText","Data":"在使用任意符合要求的滤波器之后，我们便可以得到一个连续的信号；然而，在计算机图形学中，我们并不能直接显示这样的连续信号，因为最终显示在屏幕上的都是离散的点。但是我们可以使用这些重建后的连续信号，即对连续信号进行重采样，将其离散化，即放大或者缩小信号（重采样）。"}]},{"ID":"20240423165514-ubgwvpt","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240423165514-ubgwvpt","updated":"20240423165542"},"Children":[{"Type":"NodeText","Data":"5.4.1.2 重采样"}]},{"ID":"20240423165542-uu8kzrw","Type":"NodeParagraph","Properties":{"id":"20240423165542-uu8kzrw","updated":"20240423165623"},"Children":[{"Type":"NodeText","Data":"重采样（resampling）用于放大或者缩小采样信号。假设原始的采样点位于整数坐标上（0，1，2……），即样本之间具有相同的单位间隔。此外，假设在重采样之后，我们希望新的样本点能够以"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"a"},{"Type":"NodeText","Data":"为间隔均匀分布。当"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"a \u003e 1"},{"Type":"NodeText","Data":"时，则缩小（minification）了采样信号（"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"降采样"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"，dowmsampling），即增大采样间隔，使用了更少的采样点；当"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"a \u003c 1"},{"Type":"NodeText","Data":"时，则放大（magnification）了采样信号（"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"上采样"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"，upsampling），即减小采样间隔，使用了更多的采样点。"}]},{"ID":"20240423165606-kdp0ut1","Type":"NodeParagraph","Properties":{"id":"20240423165606-kdp0ut1","updated":"20240423165636"},"Children":[{"Type":"NodeText","Data":"信号放大（上采样）是这两种情况中较为简单的一种。"}]},{"ID":"20240423165649-f9uja7y","Type":"NodeParagraph","Properties":{"id":"20240423165649-f9uja7y","updated":"20240423165652"},"Children":[{"Type":"NodeText","Data":"假设采样信号按照上一小节的方式进行重建，从直观上来看，现在的信号已经被完美重建，并且是平滑连续的。我们现在所要做的就是，以期望的间隔对重建后的信号进行重新采样，如图"}]},{"ID":"20240423165657-vc28dtx","Type":"NodeParagraph","Properties":{"id":"20240423165657-vc28dtx","updated":"20240423165705"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240423165657-de6wzj6.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"左图展示的是采样信号（红点）以及重建后的 连续 信号（绿色曲线）。右图中，重建后的信号会以两倍的采样率进行重采样，即进行了放大（上采样）。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240423165706-2vairds","Type":"NodeParagraph","Properties":{"id":"20240423165706-2vairds","updated":"20240423165758"},"Children":[{"Type":"NodeText","Data":"但是当发生信号缩小（下采样）的时候，这种技术就不起作用了，因为原始信号的采样率过高，直接降低采样率导致无法避免走样。相反，应当使用一个"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"sinc(x/a)"},{"Type":"NodeText","Data":"滤波器，来从被采样的信号中创建一个连续信号，然后再按照所需的间隔进行重采样，这个过程如下图所示。"}]},{"ID":"20240423165800-gj7hl17","Type":"NodeParagraph","Properties":{"id":"20240423165800-gj7hl17","updated":"20240423165809"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240423165800-ssk9nb6.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"左图展示的是采样信号（红点）以及重建后的连续信号（绿色曲线）。右图中的采样率减半，sinc滤波器被水平缩放为原来的两倍。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240423165809-6exfrrd","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240423165809-6exfrrd","updated":"20240423165836"},"Children":[{"Type":"NodeText","Data":"5.4.2 基于屏幕的抗锯齿"}]},{"ID":"20240423165836-olkb68f","Type":"NodeParagraph","Properties":{"id":"20240423165836-olkb68f","updated":"20240423165914"},"Children":[{"Type":"NodeText","Data":"这一节讨论的算法都是基于屏幕的（screen based）。即这些算法只会对渲染管线输出的样本进行操作处理。"}]},{"ID":"20240423165922-cg1z7rg","Type":"NodeParagraph","Properties":{"id":"20240423165922-cg1z7rg","updated":"20240423165937"},"Children":[{"Type":"NodeText","Data":"有一点需要注意，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"不存在最好的抗锯齿算法，每种算法在质量，捕捉尖锐细节（或者其他现象），处理运动物体，内存开销，GPU开销以及速度等方面，都具有不同的优势。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"}]},{"ID":"20240423165937-osbwrlt","Type":"NodeParagraph","Properties":{"id":"20240423165937-osbwrlt","updated":"20240423170044"},"Children":[{"Type":"NodeText","Data":"下图的例子中存在的问题是采样率较低，因此我们可以在每个屏幕像素网格中使用更多样本并以某种方式混合。"}]},{"ID":"20240423170047-zsrrdqp","Type":"NodeParagraph","Properties":{"id":"20240423170047-zsrrdqp","updated":"20240423170055"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240423170047-bk9udpu.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"左图中渲染了一个红色的三角形，在像素的中心有一个样本。虽然这个像素的很大一部分都被三角形所覆盖，但是由于这个三角形并没有覆盖到像素中心的样本，因此像素最终的颜色值是还是白色的。右图中，每个像素内有四个采样点，其中有两个被三角形所覆盖，在对样本进行混合之后，最终输出了一个粉色的像素值。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240423170055-oncshg3","Type":"NodeParagraph","Properties":{"id":"20240423170055-oncshg3","updated":"20240423170156"},"Children":[{"Type":"NodeText","Data":"基于屏幕的抗锯齿算法，其通用策略是"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"使用一个针对屏幕的采样模式（即多个采样点），然后对这些样本进行加权求和，最终生成像素的颜色"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"inline-math text","TextMarkInlineMathContent":"\\mathbf{p}\\mathbf{p}"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"，其数学表达如下所示："}]},{"ID":"20240423170135-kcjnde7","Type":"NodeMathBlock","Properties":{"id":"20240423170135-kcjnde7","updated":"20240423170153"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\mathbf{p}(x, y)=\\sum_{i=1}^{n} w_{i} \\mathbf{c}(i, x, y)\n\\tag{5.23}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240423170157-9a4lif5","Type":"NodeParagraph","Properties":{"id":"20240423170157-9a4lif5","updated":"20240423170226"},"Children":[{"Type":"NodeText","Data":"其中n是一个像素内的样本数量；"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{c}(i, x, y)"},{"Type":"NodeText","Data":"是一个采样颜色；"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"w_{i}"},{"Type":"NodeText","Data":"是一个权重，代表了该样本对像素整体颜色的贡献值，范围是"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"[0,1]"},{"Type":"NodeText","Data":"。样本点的位置可以通过该样本在样本序列"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"1,……,n"},{"Type":"NodeText","Data":"中的序号获得，也可以使用整数标注的亚像素位置"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"(x,y)"},{"Type":"NodeText","Data":"来进行表示。"}]},{"ID":"20240423170227-c249pm9","Type":"NodeBlockquote","Properties":{"id":"20240423170227-c249pm9","updated":"20240423170327"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240423170327-yerjd29","Type":"NodeParagraph","Properties":{"id":"20240423170327-yerjd29","updated":"20240423170327"},"Children":[{"Type":"NodeText","Data":"实时渲染系统（以及其他大部分的渲染系统）中的样本通常都是点样本，因此函数"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{c}"},{"Type":"NodeText","Data":"可以看作是两个函数的组合：首先是用一个函数"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{f}(i,n)"},{"Type":"NodeText","Data":"用于检索屏幕上需要采样的位置"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"(x_f,y_f)"},{"Type":"NodeText","Data":"；然后再对屏幕上的这个位置进行采样，即精确检索这个样本点所对应的颜色值。"}]}]},{"ID":"20240423170326-vfwhzmg","Type":"NodeParagraph","Properties":{"id":"20240423170326-vfwhzmg","updated":"20240423170336"},"Children":[{"Type":"NodeText","Data":"为了计算在特定亚像素位置上的样本，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"需要事先选择采样方案，并对渲染管线进行配置，这通常是在逐帧（或者是逐程序）进行设置的。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"}]},{"ID":"20240423170330-wh857hj","Type":"NodeParagraph","Properties":{"id":"20240423170330-wh857hj","updated":"20240423170530"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"对每个像素计算多个完整样本的抗锯齿方法被称为“超采样（supersampling）”方法。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"}]},{"ID":"20240423170531-r4qbu2e","Type":"NodeParagraph","Properties":{"id":"20240423170531-r4qbu2e","updated":"20240423170535"},"Children":[{"Type":"NodeText","Data":"在概念上最简单的超采样方法是"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"全屏抗锯齿（full-scene antialiasing，FSAA)"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"，通常也被称为"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"超采样抗锯齿（supersampling antialiasing ，SSAA)"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。这个方法会"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"以更高的屏幕分辨率来渲染整个场景，然后再通过对相邻像素样本进行滤波（卷积），从而生成一个图像。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"}]},{"ID":"20240423170516-41zs7rx","Type":"NodeParagraph","Properties":{"id":"20240423170516-41zs7rx","updated":"20240423170634"},"Children":[{"Type":"NodeText","Data":"这个方法的开销很大，因为每个子样本都有一个z-buffer深度，它们都需要进行完整的着色和填充，FSAA最大的优点就是实现起来很简单。"}]},{"ID":"20240423170804-519cjcv","Type":"NodeParagraph","Properties":{"id":"20240423170804-519cjcv","updated":"20240423173603"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"多重采样抗锯齿（Multisampling antialiasing，MSAA）"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color12);"},"TextMarkType":"block-ref text","TextMarkBlockRefID":"20240423173311-1xfto07","TextMarkBlockRefSubtype":"d","TextMarkTextContent":"MSAA基础"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color12);\"}"},{"Type":"NodeText","Data":" 通过只进行一次逐像素的表面着色计算，并在多个样本之间共享结果，从而大大降低了计算成本。"}]},{"ID":"20240423170809-wuyo6ah","Type":"NodeParagraph","Properties":{"id":"20240423170809-wuyo6ah","updated":"20240423171306"},"Children":[{"Type":"NodeText","Data":"假设每个屏幕像素的每个片元（fragment）上有四个"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"(x,y)"},{"Type":"NodeText","Data":"子样本位置，每个样本都具有独立的颜色信息和深度信息（z-depth），但是对于该像素的每个片元，像素着色器只会进行一次计算。如果所有的样本位置都被这个片元所覆盖，那么则在像素的中心位置来计算这个着色样本；而如果这个片元只覆盖了部分样本，那么着色样本的选择可以进行移动，从而更好地表示所覆盖的位置。这样做有一些好处，例如可以"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"避免对纹理边缘的着色采样"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。这个位置调整被叫做"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"质心采样（centroid sampling）或者质心插值（centroid interpolation）"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。如果MSAA的功能被启用的话，那么GPU会自动对样本的位置进行调整。"}]},{"ID":"20240423171030-e8fi5i9","Type":"NodeParagraph","Properties":{"id":"20240423171030-e8fi5i9","updated":"20240423171320"},"Children":[{"Type":"NodeText","Data":"质心采样避免了非三角形的问题，但是可能会导致梯度计算返回不正确的结果[530, 1041]。如下图。"}]},{"ID":"20240423171324-61yuogd","Type":"NodeParagraph","Properties":{"id":"20240423171324-61yuogd","updated":"20240423171339"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240423171324-0k0p4w3.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"中间的图展示了一个像素被两个物体重叠的情况，其中红色物体覆盖了三个样本，蓝色物体覆盖了一个样本。图中的绿色点代表了像素着色器计算的位置，由于红色三角形覆盖了像素的中心，因此这个位置被用于着色器计算；而蓝色物体的像素着色器将在1号样本的位置上进行计算。对于MSAA而言，所有的四个样本位置都存储了单独的颜色信息和深度信息，右图展示了EQAA的2f4x模式，四个样本对应了四个ID值，这个ID值用于在另一个只包含颜色信息和深度信息的表格中进行检索。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240423171340-jcox0ql","Type":"NodeParagraph","Properties":{"id":"20240423171340-jcox0ql","updated":"20240423171453"},"Children":[{"Type":"NodeText","Data":"MSAA的速度要比纯超采样的方案快，因为每个片元只会进行一次着色计算，它专注于以更高的速率来对片元覆盖的像素范围进行采样，并共享计算出的着色结果。"}]},{"ID":"20240423171509-fkf8tju","Type":"NodeBlockquote","Properties":{"id":"20240423171509-fkf8tju","updated":"20240423171543"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240423171512-j0fxv24","Type":"NodeParagraph","Properties":{"id":"20240423171512-j0fxv24","updated":"20240423171543"},"Children":[{"Type":"NodeText","Data":"NVIDIA在2006年引入了覆盖采样抗锯齿（coverage sampling antialiasing ，CSAA），AMD随后也提出了增强质量抗锯齿（enhanced quality antialiasing ，EQAA）。这些技术以更高的采样率，同时只存储片元所覆盖的范围来进行实现，例如：EQAA的“2f4x”模式只存储了两组颜色和深度信息，这些信息会在四个样本位置之间进行共享。并且这些信息也不再和具体的样本位置相绑定，而是存储在一张额外的表格中，四个样本仅需要各自使用一个bit，来指定哪组颜色深度信息与该位置相关联即可，如上图所示。"}]}]},{"ID":"20240423173531-rooilvt","Type":"NodeParagraph","Properties":{"id":"20240423173531-rooilvt","updated":"20240423173655"},"Children":[{"Type":"NodeText","Data":"片元所覆盖的样本数量最终决定了该片元对像素颜色的贡献权重。如果此时存储的颜色数量超出了存储上限（两组），那么就会丢弃一个已存储的颜色信息，并将其所关联的样本标记为未知，这些被标记为未知的样本最终不会对像素颜色产生贡献[382, 383]。"}]},{"ID":"20240423173655-t38qzye","Type":"NodeParagraph","Properties":{"id":"20240423173655-t38qzye","updated":"20240423173708"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"对于大多数场景而言，一个像素同时被三个不透明的片元所覆盖，并且这些片元还是以完全不同的方式进行着色的，这种情况发生的概率非常低，因此这个方案在实际应用中表现良好"},{"Type":"NodeText","Data":"["},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"1405]。"}]},{"ID":"20240423173712-ymqwycr","Type":"NodeParagraph","Properties":{"id":"20240423173712-ymqwycr","updated":"20240423173732"},"Children":[{"Type":"NodeText","Data":"当场景中所有的几何体都被渲染到一个多样本缓冲区（multiple-sample buffer）之后，会进行一个"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"解析（resolve）操作"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"在这个过程中，会对样本的颜色进行平均化，并最终决定像素的颜色。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"}]},{"ID":"20240423173728-e67bsoj","Type":"NodeBlockquote","Properties":{"id":"20240423173728-e67bsoj","updated":"20240423173808"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240423173808-3ncr2pr","Type":"NodeParagraph","Properties":{"id":"20240423173808-3ncr2pr","updated":"20240423173808"},"Children":[{"Type":"NodeText","Data":"在现代的GPU上，像素着色器或者计算着色器可以访问MSAA的样本，并使用任何我们所需要的滤波器来进行重建，甚至可以访问周围像素的样本。一个范围更大的滤波器可以减少锯齿和走样，但是它也会失去尖锐的细节。"}]}]},{"ID":"20240423174014-wyg7qn1","Type":"NodeParagraph","Properties":{"id":"20240423174014-wyg7qn1","updated":"20240423174044"},"Children":[{"Type":"NodeText","Data":"TXAA和比较新的MFAA（多帧采样抗锯齿multi-frame antialiasing）都是使用了时域抗锯齿（temporal antialiasing ，TAA），TAA是一种通过之前几帧的结果来对当前帧进行优化的抗锯齿技术。"}]},{"ID":"20240423174052-8heugq3","Type":"NodeBlockquote","Properties":{"id":"20240423174052-8heugq3","updated":"20240423174053"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240423174053-i003n0n","Type":"NodeParagraph","Properties":{"id":"20240423174053-i003n0n","updated":"20240423174053"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"从某种程度上来看，这种技术之所以成为可能，是因为它允许程序员设置每帧的MSAA采样模式"},{"Type":"NodeText","Data":"["},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"1406]。这种基于时域的抗锯齿技术，可以用于解决旋转车轮的走样问题，也可以提高边缘的渲染质量。"}]}]},{"ID":"20240423174054-gyvqy4a","Type":"NodeParagraph","Properties":{"id":"20240423174054-gyvqy4a","updated":"20240423174418"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"一般越老的图像被赋予的权重就越少，如果当前的相机和场景没有发生移动的话，这种方法可能会导致闪烁的现象，因此通常只对当前帧和前一帧赋予相同的权重。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"由于每一帧中的样本都位于不同的像素子位置，因此这些样本的加权和，相较于比单帧加权而言，可以获得更好的边缘覆盖估计。因为上述原因，在一个渲染系统中，使用最新生成的两帧在一起进行平均，可以获得更好的结果，而且最吸引人的是，我们不需要对每一帧进行额外的处理。甚至我们可以使用时域采样来生成一个较低分辨率的图像，然后再将其放大到显示器的分辨率。除此之外，一些光照方法或者其他技术往往需要许多样本才能获得一个较好的结果，可以通过将当前结果和之前几帧进行混合，从而在一帧中降低样本的使用数量。"}]},{"ID":"20240423174359-84gqe2p","Type":"NodeBlockquote","Properties":{"id":"20240423174359-84gqe2p","updated":"20240423174439"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240423174434-5t7xibc","Type":"NodeParagraph","Properties":{"id":"20240423174434-5t7xibc","updated":"20240423174439"},"Children":[{"Type":"NodeText","Data":"虽然基于时域的抗锯齿技术可以在没有增加额外采样成本的情况下，为静态场景提供抗锯齿，但是这类算法也会存在一些问题。例如：如果每一帧的权重不同的话，那么会导致静态场景中的物体出现闪烁现象（shimmer）；场景中快速移动的物体，或者是相机的快速移动，会导致画面出现鬼影（ghosting），即由于之前帧的贡献，会导致物体后面出现拖曳的痕迹。"}]}]},{"ID":"20240423174505-yx1lp2x","Type":"NodeParagraph","Properties":{"id":"20240423174505-yx1lp2x","updated":"20240423174509"},"Children":[{"Type":"NodeText","Data":"如何解决鬼影？"}]},{"ID":"20240423174440-jle4773","Type":"NodeList","ListData":{},"Properties":{"id":"20240423174440-jle4773","updated":"20240423174544"},"Children":[{"ID":"20240423174511-hi235hu","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240423174511-hi235hu","updated":"20240423174511"},"Children":[{"ID":"20240423174511-9ac4vyp","Type":"NodeParagraph","Properties":{"id":"20240423174511-9ac4vyp","updated":"20240423174513"},"Children":[{"Type":"NodeText","Data":"一种解决鬼影的方法是只对缓慢移动的物体使用TAA。"}]}]},{"ID":"20240423174516-9irhw9n","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240423174516-9irhw9n","updated":"20240423174544"},"Children":[{"ID":"20240423174516-fsp89lb","Type":"NodeParagraph","Properties":{"id":"20240423174516-fsp89lb","updated":"20240423174544"},"Children":[{"Type":"NodeText","Data":"另一种是使用重投影(TODO: Ref 12.2) 来更好地将前一帧物体与当前物体关联起来。"}]}]}]},{"ID":"20240423174613-66tyiec","Type":"NodeParagraph","Properties":{"id":"20240423174613-66tyiec","updated":"20240423174642"},"Children":[{"Type":"NodeText","Data":"由于这类基于时域的抗锯齿算法，并不会引入额外的样本，并且开销相对较小，因此近年来人们对这类算法产生了强烈的兴趣和广泛的使用。其中一部分的人关注时域抗锯齿的原因，是因为延迟渲染技术（TODO: Ref 20.1）并不兼容MSAA和其他的多重采样抗锯齿技术。"}]},{"ID":"20240423174637-v9677j0","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240423174637-v9677j0","updated":"20240423174720"},"Children":[{"Type":"NodeText","Data":"5.4.2.1 采样模式"}]},{"ID":"20240423174724-0vvhi0l","Type":"NodeParagraph","Properties":{"id":"20240423174724-0vvhi0l","updated":"20240423174728"},"Children":[{"Type":"NodeText","Data":"高效的采样模式（sampling pattern）是减少瑕疵和时间开销等方面的关键因素。"}]},{"ID":"20240423174729-gc9wcm9","Type":"NodeBlockquote","Properties":{"id":"20240423174729-gc9wcm9","updated":"20240423174743"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240423174743-52x7hof","Type":"NodeParagraph","Properties":{"id":"20240423174743-52x7hof","updated":"20240423174743"},"Children":[{"Type":"NodeText","Data":"Naiman指出[1257]，在水平边缘与垂直边缘的附近的锯齿，对人类的视觉影响最大，其次便是倾角接近45度的边缘。"}]}]},{"ID":"20240423174744-r9ri9z4","Type":"NodeParagraph","Properties":{"id":"20240423174744-r9ri9z4","updated":"20240423174752"},"Children":[{"Type":"NodeText","Data":"旋转网格超采样（rotated grid supersampling ，RGSS）使用了一个旋转后的正方形采样模式来进行采样，可以在像素内提供更多的水平分辨率和垂直分辨率，图5.25展示了这个采样模式的一个例子。"}]},{"ID":"20240423174812-fdgxwiz","Type":"NodeParagraph","Properties":{"id":"20240423174812-fdgxwiz","updated":"20240423174814"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240423174812-n74bx1m.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240423174819-rf63mg8","Type":"NodeParagraph","Properties":{"id":"20240423174819-rf63mg8","updated":"20240423174920"},"Children":[{"Type":"NodeText","Data":"在RGSS采样模式中，有四个采样点，这四个采样点分别位于 "},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"4 \\times 4 "},{"Type":"NodeText","Data":"  子像素网格的单独行和单独列中。与常规的"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":" 2 \\times 2  "},{"Type":"NodeText","Data":" 采样模式相比，这种旋转采样的方式尤其适合捕获接近水平或者接近垂直的边缘。"}]},{"ID":"20240423174915-zl9ahgu","Type":"NodeParagraph","Properties":{"id":"20240423174915-zl9ahgu","updated":"20240423175018"},"Children":[{"Type":"NodeText","Data":"N-rooks采样模式只是创建良好采样模式的基础，其本身还不够好。当N-rooks的采样点集中在亚像素网格的对角线上时，如果此时覆盖像素的边缘几乎平行于对角线，那么N-rooks会给出一个很差的采样结果，如图"}]},{"ID":"20240423174953-mrhn8ds","Type":"NodeParagraph","Properties":{"id":"20240423174953-mrhn8ds","updated":"20240423175002"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240423174953-507orj3.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"N-rooks采样。左侧是一个合法的N-rooks采样模式，但是对于平行于对角线的三角形边界，它的捕获效果会很差，因为当这个三角形稍微移动一点， 那么所有的样本位置就会全部位于三角形内部或者全部位于三角形之外。右图也是一个合法的N-rooks采样模式，它可以更加有效地捕获这种边缘以及其他类型的边缘。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240423175003-bxq358l","Type":"NodeParagraph","Properties":{"id":"20240423175003-bxq358l","updated":"20240423175209"},"Children":[{"Type":"NodeText","Data":"实际中可以将例如拉丁超立方体采样的分层抽样技术与其他方法相结合，例如抖动采样"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"，"},{"Type":"NodeText","Data":"Halton序列以及泊松圆盘采样（Poisson disk sampling）[1413, 1758]。下图是一些实践中使用的MSAA采样模式："}]},{"ID":"20240423175209-fqgtrev","Type":"NodeParagraph","Properties":{"id":"20240423175209-fqgtrev","updated":"20240423175209"}},{"ID":"20240423175212-n9tzr2u","Type":"NodeParagraph","Properties":{"id":"20240423175212-n9tzr2u","updated":"20240423175239"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240423175212-34i0327.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"AMD和NVIDIA图形硬件加速器（显卡）所采用的MSAA采样模式，其中绿色的点代表了着色样本的位置，红色的点计算并保存了采样点的位置。从左到右分别是 2x ， 4x ， 6x （AMD）和 8x （NVIDIA）MSAA的采样模式。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240423175239-ypwt5vq","Type":"NodeParagraph","Properties":{"id":"20240423175239-ypwt5vq","updated":"20240423175414"},"Children":[{"Type":"NodeText","Data":"亚像素网格模式采样肯呢个会产生"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"摩尔纹"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"，这是因为一个场景可以由屏幕上任意小的物体组成，如果这些微小的物体或者特征形成了某种图案，那么此时以恒定的间隔对其进行采样，就会产生摩尔纹（Moire fringes）和其他的干涉图案。"}]},{"ID":"20240423175414-xgiz76n","Type":"NodeList","ListData":{},"Properties":{"id":"20240423175414-xgiz76n","updated":"20240423175822"},"Children":[{"ID":"20240423175414-xurcgps","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240423175414-xurcgps","updated":"20240423175414"},"Children":[{"ID":"20240423175414-217ptbc","Type":"NodeParagraph","Properties":{"id":"20240423175414-217ptbc","updated":"20240423175457"},"Children":[{"Type":"NodeText","Data":"一种解决方案是使用随机采样（stochastic sampling），这种方法可以生成一个更加随机的采样模式。但是这种方式也会引入图像噪声问题，但是人眼对噪声更加宽容。"}]}]},{"ID":"20240423175506-90jqzsn","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240423175506-90jqzsn"},"Children":[{"ID":"20240423175506-79o5qbc","Type":"NodeParagraph","Properties":{"id":"20240423175506-79o5qbc","updated":"20240423175535"},"Children":[{"Type":"NodeText","Data":"一种解决方案你是每个平面像素上使用完全不同的采样方案，或者随着时间推移对每个采样模式修改"}]}]},{"ID":"20240423175613-qho9rr9","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240423175613-qho9rr9","updated":"20240423175822"},"Children":[{"ID":"20240423175613-vypedgg","Type":"NodeParagraph","Properties":{"id":"20240423175613-vypedgg","updated":"20240423175822"},"Children":[{"Type":"NodeText","Data":"此外还有一些有GPU支持的算法例如五点型采样（Quincunx），FLIPQUAD方法等（参见原文）。"}]}]}]},{"ID":"20240423175915-fpc1qvb","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20240423175915-fpc1qvb","updated":"20240423175929"},"Children":[{"Type":"NodeText","Data":"5.4.2.2 形态学方法（Morphological Methods）"}]},{"ID":"20240423175937-z7e5g3b","Type":"NodeParagraph","Properties":{"id":"20240423175937-z7e5g3b","updated":"20240426001652"},"Children":[{"Type":"NodeText","Data":"形态学抗锯齿（morphological antialiasing ，MLAA）。其中“形态（morphological ）”意味着它与物体的结构或者形状有关。"}]},{"ID":"20240426001709-d2r7129","Type":"NodeParagraph","Properties":{"id":"20240426001709-d2r7129","updated":"20240426001709"},"Children":[{"Type":"NodeText","Data":"这种形式的抗锯齿是作为一个后处理（post-process）来执行的。也就是说，以通常的方式来渲染一张图像，然后将这个渲染结果输入到一个专门进行抗锯齿处理的过程中。"}]},{"ID":"20240426001732-lnst8c8","Type":"NodeParagraph","Properties":{"id":"20240426001732-lnst8c8","updated":"20240426001735"},"Children":[{"Type":"NodeText","Data":"最普通的方法只需要使用颜色缓冲，这意味还可以使用阴影，高亮，以及各种之前应用于后处理阶段的技术（例如描边渲染 ，silhouette edge rendering，详见章节15.2.3），来对边缘效果进行改善。"}]},{"ID":"20240426001956-ms8r7sl","Type":"NodeParagraph","Properties":{"id":"20240426001956-ms8r7sl","updated":"20240426002012"},"Children":[{"Type":"NodeText","Data":"在某几种情况下，基于图像的算法可能会导致错误的结果。"}]},{"ID":"20240426002013-rlca5ja","Type":"NodeList","ListData":{},"Properties":{"id":"20240426002013-rlca5ja","updated":"20240426002053"},"Children":[{"ID":"20240426002014-ckr0c45","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240426002014-ckr0c45","updated":"20240426002014"},"Children":[{"ID":"20240426002014-mk29n8c","Type":"NodeParagraph","Properties":{"id":"20240426002014-mk29n8c","updated":"20240426002017"},"Children":[{"Type":"NodeText","Data":"如果两个物体之间的颜色差异低于该算法的阈值，则可能无法有效检测到这个边缘。"}]}]},{"ID":"20240426002018-fgei10b","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240426002018-fgei10b"},"Children":[{"ID":"20240426002018-njt5200","Type":"NodeParagraph","Properties":{"id":"20240426002018-njt5200","updated":"20240426002023"},"Children":[{"Type":"NodeText","Data":"如果某个像素被三个或者三个以上的表面所覆盖，那么就很难对这种情况进行边缘预测。"}]}]},{"ID":"20240426002023-tjqusip","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240426002023-tjqusip"},"Children":[{"ID":"20240426002023-tsir0bn","Type":"NodeParagraph","Properties":{"id":"20240426002023-tsir0bn","updated":"20240426002029"},"Children":[{"Type":"NodeText","Data":"具有高对比度或者高频元素的表面，其颜色可能会在像素之间快速变化，从而导致算法遗漏一些边缘。"}]}]},{"ID":"20240426002030-ie7usae","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240426002030-ie7usae"},"Children":[{"ID":"20240426002030-h33fvn8","Type":"NodeParagraph","Properties":{"id":"20240426002030-h33fvn8","updated":"20240426002034"},"Children":[{"Type":"NodeText","Data":"当使用了形态学抗锯齿算法时，画面上的文字质量通常会受到影响。"}]}]},{"ID":"20240426002035-zr8ptsd","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240426002035-zr8ptsd"},"Children":[{"ID":"20240426002035-0myrya7","Type":"NodeParagraph","Properties":{"id":"20240426002035-0myrya7","updated":"20240426002040"},"Children":[{"Type":"NodeText","Data":"物体的拐角处对于这种算法来说是一个挑战，使用一些算法后，可能会导致这些拐角变成圆角。"}]}]},{"ID":"20240426002041-bol1txq","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240426002041-bol1txq"},"Children":[{"ID":"20240426002041-24mu9eo","Type":"NodeParagraph","Properties":{"id":"20240426002041-24mu9eo","updated":"20240426002046"},"Children":[{"Type":"NodeText","Data":"因为我们一般假设边缘都是直线的，因此弯曲的线段可能会被错误处理。"}]}]},{"ID":"20240426002047-7k5iuz7","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240426002047-7k5iuz7","updated":"20240426002053"},"Children":[{"ID":"20240426002047-xum4cpe","Type":"NodeParagraph","Properties":{"id":"20240426002047-xum4cpe","updated":"20240426002053"},"Children":[{"Type":"NodeText","Data":"单独一个像素上的变化，就可能会导致边缘重建的方式发生巨大变化，从而在帧与帧之间产生鬼影和瑕疵"}]}]}]},{"ID":"20240426002125-gkzc3ua","Type":"NodeParagraph","Properties":{"id":"20240426002125-gkzc3ua","updated":"20240426002125"},"Children":[{"Type":"NodeText","Data":"综上所述，基于图像的方法能够以较小的内存使用和处理开销，来提高抗锯齿效果，因此这类算法被很多应用程序所使用。仅仅使用纯颜色缓冲的算法可以很好地与渲染管线相解耦，使得它们易于修改和禁用，甚至可以暴露为GPU驱动中的选项。"}]},{"ID":"20240426002127-atuqffl","Type":"NodeBlockquote","Properties":{"id":"20240426002127-atuqffl","updated":"20240426002141"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240426002129-i2ue69b","Type":"NodeParagraph","Properties":{"id":"20240426002129-i2ue69b","updated":"20240426002141"},"Children":[{"Type":"NodeText","Data":"其中两种最流行算法分别是快速近似抗锯齿（fast approximate antialiasing ，FXAA）[1079, 1080, 1084]和亚像素形态学抗锯齿（subpixel morphological antialiasing ，SMAA）[828, 830, 834]"}]}]},{"ID":"20240426002141-k47ki7r","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240426002141-k47ki7r","updated":"20240426002436"},"Children":[{"Type":"NodeText","Data":"5.5 透明度、Alpha与合成"}]},{"ID":"20240426002442-trk0361","Type":"NodeParagraph","Properties":{"id":"20240426002442-trk0361","updated":"20240426003637"},"Children":[{"Type":"NodeText","Data":"光线通过半透明（semitransparent）物体的方式有很多种，对于半透明渲染算法而言，这些效果可以大致分为基于光线（light-based）的半透明效果与基于视图（view-based）的半透明效果。可见"},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20240426003219-km3wq1o","TextMarkBlockRefSubtype":"d","TextMarkTextContent":"Unity Shader 点阵像素剔除半透（Stipple Transparency ）"}]},{"ID":"20240426002448-ze4ka9y","Type":"NodeList","ListData":{},"Properties":{"id":"20240426002448-ze4ka9y","updated":"20240426002505"},"Children":[{"ID":"20240426002449-nmcdkgf","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240426002449-nmcdkgf","updated":"20240426002449"},"Children":[{"ID":"20240426002449-tqr06a8","Type":"NodeParagraph","Properties":{"id":"20240426002449-tqr06a8","updated":"20240426002500"},"Children":[{"Type":"NodeText","Data":"基于光线的半透明效果是指，半透明物体会导致光线发生衰减和偏移，从而使得场景中的其他物体会被照亮，或者呈现出不同的渲染效果。"}]}]},{"ID":"20240426002501-ta7y1ly","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240426002501-ta7y1ly","updated":"20240426002505"},"Children":[{"ID":"20240426002501-78k1978","Type":"NodeParagraph","Properties":{"id":"20240426002501-78k1978","updated":"20240426002505"},"Children":[{"Type":"NodeText","Data":"基于视图的半透明效果是指透明物体自身的渲染效果。"}]}]}]},{"ID":"20240426002506-yv2weo0","Type":"NodeParagraph","Properties":{"id":"20240426002506-yv2weo0","updated":"20240426002527"},"Children":[{"Type":"NodeText","Data":"本小节中，我们会讨论最简单形式的基于视图的半透明效果，即半透明物体本身会作为背后物体颜色的衰减器（attenuator）。"}]},{"ID":"20240426002530-opghasz","Type":"NodeBlockquote","Properties":{"id":"20240426002530-opghasz","updated":"20240426002537"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240426002531-q632zhh","Type":"NodeParagraph","Properties":{"id":"20240426002531-q632zhh","updated":"20240426002537"},"Children":[{"Type":"NodeText","Data":" 在后面的章节中，我们会更加详细的讨论基于视图和基于光线的半透明效果，例如毛玻璃（frosted glass）、光线折射、由于透明物体的厚度而导致的光线衰减、以及因视角变化而带来的反射率（reflectivity）变化和透射率（transmission）的变化。"}]}]},{"ID":"20240426002538-a3napbo","Type":"NodeParagraph","Properties":{"id":"20240426002538-a3napbo","updated":"20240426003813"},"Children":[{"Type":"NodeText","Data":"一种产生透明错觉的方法被称作"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"点阵剔除半透明（screen-door transparency）"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。该方法的思路是使用一个像素对齐的棋盘格来对图案进行填充，从而渲染透明效果的三角形。也就是说，每个三角形像素都会被选择性地渲染，从而使得后面得物体变得部分可见。"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"如果像素比较密集，那么棋盘格本身图案不可见"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240426002649-pxz27p6","Type":"NodeParagraph","Properties":{"id":"20240426002649-pxz27p6","updated":"20240426003039"},"Children":[{"Type":"NodeText","Data":"这种点阵剔除的方法，其优点就是十分简单，透明物体可以在任意时间，以任意的顺序出现，并且不需要特殊的硬件支持。"}]},{"ID":"20240426003820-cnkiozc","Type":"NodeParagraph","Properties":{"id":"20240426003820-cnkiozc","updated":"20240426003829"},"Children":[{"Type":"NodeText","Data":"缺点是在屏幕上的一个区域内，通常只有一个物体的半透明效果比较令人信服；如果有多个半透明物体重叠在一起的话，这种方法就非常失真了。"}]},{"ID":"20240426003639-8f2lmgr","Type":"NodeParagraph","Properties":{"id":"20240426003639-8f2lmgr","updated":"20240426003925"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"随机透明度（stochastic transparency），将亚像素级别的遮罩和随机采样的方法相结合，通过使用随机点状图案来表示一个片元的alpha覆盖率，可以生成一个合理，但是有噪声的图像"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"，如图："}]},{"ID":"20240426003958-dyshlgb","Type":"NodeParagraph","Properties":{"id":"20240426003958-dyshlgb","updated":"20240426004011"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"20230114231421"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/20230114231421-20240426003958-tisf3tz.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"随机透明度。图中放大区域内展示了该算法产生的噪声。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240426004011-kev07rd","Type":"NodeParagraph","Properties":{"id":"20240426004011-kev07rd","updated":"20240426004020"},"Children":[{"Type":"NodeText","Data":"大部分透明度算法都需要将透明物体的颜色，与其背后物体的颜色混合在一起，为此，需要使用alpha混合（alpha blending）的概念。"}]},{"ID":"20240426004021-bvp1rlq","Type":"NodeParagraph","Properties":{"id":"20240426004021-bvp1rlq","updated":"20240426004120"},"Children":[{"Type":"NodeText","Data":"当一个物体渲染到屏幕上时，每个像素都关联了一个RGB颜色和一个z-buffer深度值，我们还会为每个被物体所覆盖的像素，定义一个额外的分量，这个分量被叫做alpha"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"(\\alpha)"},{"Type":"NodeText","Data":"。"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"alpha描述了一个给定像素上，片元的透明度和像素覆盖率：当alpha为1.0的时候，意味着这个物体是不透明的，并且完全占据了这个像素内的所有区域；当alpha为0.0的时候，意味着这个像素完全没有被掩盖（obscured），即这个片元是完全透明的。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"}]},{"ID":"20240426004108-nw4w4up","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240426004108-nw4w4up","updated":"20240426004156"},"Children":[{"Type":"NodeText","Data":"5.5.1 混合顺序"}]},{"ID":"20240426004157-4qbya8f","Type":"NodeParagraph","Properties":{"id":"20240426004157-4qbya8f","updated":"20240426004322"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"为了使得一个物体看起来更加透明，我们需要将alpha小于1的物体渲染在场景的最前面。被这个物体所覆盖的每个像素，都会从像素着色器中接收到一个"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\rm RGB\\alpha"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"值（也叫做RGBA）。通过使用"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{over}"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"运算符，来将这个片元的值和像素的原始颜色进行混合，其数学形式如下所示："}]},{"ID":"20240426004318-lhyi1jq","Type":"NodeMathBlock","Properties":{"id":"20240426004318-lhyi1jq","updated":"20240426004330"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\mathbf{c}_{o}=\\alpha_{s} \\mathbf{c}_{s}+\\left(1-\\alpha_{s}\\right) \\mathbf{c}_{d} \\quad [\\mathbf{over} \\quad \\rm{operator}]\n\\tag{5.24}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240426004330-qhswezm","Type":"NodeParagraph","Properties":{"id":"20240426004330-qhswezm","updated":"20240426004430"},"Children":[{"Type":"NodeText","Data":"其中的"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{c}_{s}"},{"Type":"NodeText","Data":"代表透明物体的颜色（被称作源颜色source），"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{\\alpha}_{s}"},{"Type":"NodeText","Data":"代表了这个物体的alpha值，"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{c}_{d}"},{"Type":"NodeText","Data":"代表该像素在混合之前的颜色（被称作目标颜色destination），"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{c}_{o}"},{"Type":"NodeText","Data":"代表了将这个透明物体放置在现有场景前（"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{over}"},{"Type":"NodeText","Data":"操作）而生成的结果颜色。"}]},{"ID":"20240426004431-0fmepvr","Type":"NodeBlockquote","Properties":{"id":"20240426004431-0fmepvr","updated":"20240426004523"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240426004501-yzhxhfh","Type":"NodeParagraph","Properties":{"id":"20240426004501-yzhxhfh","updated":"20240426004522"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"现在有一个红色的半透明物体被渲染到一个蓝色的背景上，假设物体上某个像素的"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\rm RGB"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"值为"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"(0.9,0.2,0.1)"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"，背景的"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\rm RGB"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"值为"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"(0.1,0.1,0.9)"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"，同时这个物体的不透明度为0.6。那么这两个颜色的混合计算表达式为："}]},{"ID":"20240426004501-ll5fdnf","Type":"NodeMathBlock","Properties":{"id":"20240426004501-ll5fdnf","updated":"20240426004523"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"0.6(0.9,0.2,0.1)+(1-0.6)(0.1,0.1,0.9)"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240426004501-6u2ozrv","Type":"NodeParagraph","Properties":{"id":"20240426004501-6u2ozrv","updated":"20240426004501"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"最后生成的结果颜色值为"},{"Type":"NodeText","Data":"(0.58,0.16,0.42)"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"。"}]}]},{"ID":"20240426004524-vv9e44h","Type":"NodeParagraph","Properties":{"id":"20240426004524-vv9e44h","updated":"20240426004610"},"Children":[{"Type":"NodeText","Data":"这种方式实现的透明效果是可行的，因为从某种意义上来说，只要能透过这个物体看到其背后物体的样子，我们就会认为这个东西是透明的。"}]},{"ID":"20240426004615-a7pgmhv","Type":"NodeBlockquote","Properties":{"id":"20240426004615-a7pgmhv","updated":"20240426004709"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240426004616-gouxg3c","Type":"NodeParagraph","Properties":{"id":"20240426004616-gouxg3c","updated":"20240426004709"},"Children":[{"Type":"NodeText","Data":"例如我们可以使用"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{over}"},{"Type":"NodeText","Data":"运算符来模拟现实世界中轻薄布料（gauzy fabric）的效果，由于布料上的丝线（thread）是不透明的，因此布料背后的物体会被部分模糊。在实际实现中，松散布料的alpha覆盖率会随着视角的变化而变化[386]。也就是说，这里我们认为alpha值模拟了材质对像素的覆盖程度。"}]},{"ID":"20240426004652-pgqh5ih","Type":"NodeParagraph","Properties":{"id":"20240426004652-pgqh5ih","updated":"20240426004659"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240426004652-zv9pqxi.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"左侧是一个红色的方形布料，右侧是一个红色的塑料滤镜，二者的透明效果是完全不同的。请注意观察二者阴影效果的不同。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]}]},{"ID":"20240426004700-9r13na6","Type":"NodeParagraph","Properties":{"id":"20240426004700-9r13na6","updated":"20240426004823"},"Children":[{"Type":"NodeText","Data":"在模拟其他透明效果的时候，尤其是通过彩色玻璃或者彩色塑料来进行观察的情况下，"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{over}"},{"Type":"NodeText","Data":"运算符模拟的效果就不那么令人信服了。这部分可见[TODO Ref: 14.5.1 14.5.2]"}]},{"ID":"20240426004823-xju464w","Type":"NodeParagraph","Properties":{"id":"20240426004823-xju464w","updated":"20240426004904"},"Children":[{"Type":"NodeText","Data":"另一个有一定用途的操作符是叠加混合（additive blending），在这个运算符中，参与混合的两个像素值只是简单的相加，其数学表达式为："}]},{"ID":"20240426004902-lvq6exu","Type":"NodeMathBlock","Properties":{"id":"20240426004902-lvq6exu","updated":"20240426005020"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\mathbf{c}_{o}=\\alpha_{s} \\mathbf{c}_{s}+\\mathbf{c}_{d}\n\\tag{5.25}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240426004910-ijrjpos","Type":"NodeBlockquote","Properties":{"id":"20240426004910-ijrjpos","updated":"20240426004926"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240426004915-0zqdtk2","Type":"NodeParagraph","Properties":{"id":"20240426004915-0zqdtk2","updated":"20240426004926"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"这种混合模式适用于模拟各种发光效果，例如闪电或者火花，这些效果并不会对背后的像素产生影响，而只是使像素本身变得更亮"},{"Type":"NodeText","Data":"["},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"1813]。"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"但是这种模式的生产的透明度效果看起来并不正确，因为不透明表面看起来并没有被过滤[1192]"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"。对于一些层状的半透明表面，例如烟雾或者火焰，这种叠加混合的模式具有饱和现象颜色的效果"},{"Type":"NodeText","Data":"["},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"1273]。"}]}]},{"ID":"20240426004927-9mqf1kz","Type":"NodeParagraph","Properties":{"id":"20240426004927-9mqf1kz","updated":"20240426005001"},"Children":[{"Type":"NodeText","Data":"为了能够正确的渲染透明物体，我们需要在不透明物体绘制完成之后，再去绘制透明物体。具体的实现方式是"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"先关闭混合操作，渲染所有的不透明物体；然后再启用"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"inline-math text","TextMarkInlineMathContent":"\\mathbf{over}"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"运算符，渲染所有的透明物体"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240426004956-uuu476g","Type":"NodeParagraph","Properties":{"id":"20240426004956-uuu476g","updated":"20240426005055"},"Children":[{"Type":"NodeText","Data":"在任意给定像素上叠加透明表面时，通常需要严格按照从后往前的顺序进行渲染，因为z-buffer每个像素位置上只会存距离相机最近的那个深度值。"}]},{"ID":"20240426005101-hmas6dd","Type":"NodeParagraph","Properties":{"id":"20240426005101-hmas6dd","updated":"20240426005127"},"Children":[{"Type":"NodeText","Data":"一种实现这种排序的方法是，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"将透明物体沿着观察方向，按照各自质心到相机的距离大小进行排序"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。这种排序的方法存在一些问题："}]},{"ID":"20240426005127-ve319zv","Type":"NodeList","ListData":{},"Properties":{"id":"20240426005127-ve319zv","updated":"20240426005215"},"Children":[{"ID":"20240426005128-li1v3sc","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240426005128-li1v3sc","updated":"20240426005128"},"Children":[{"ID":"20240426005128-74t0wdk","Type":"NodeParagraph","Properties":{"id":"20240426005128-74t0wdk","updated":"20240426005139"},"Children":[{"Type":"NodeText","Data":"首先，这样的排序仅仅是一个近似，位于远处的物体也可能会错误地出现在较近物体的前面"}]}]},{"ID":"20240426005140-c5dbwyf","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240426005140-c5dbwyf","updated":"20240426005215"},"Children":[{"ID":"20240426005140-3xauw58","Type":"NodeParagraph","Properties":{"id":"20240426005140-3xauw58","updated":"20240426005152"},"Children":[{"Type":"NodeText","Data":"并且相互贯通重叠的物体，无法针对所有视角都进行正确显示，除非将每个网格都划分成单独的块，如图"}]},{"ID":"20240426005200-87hg2aq","Type":"NodeParagraph","Properties":{"id":"20240426005200-87hg2aq","updated":"20240426005215"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240426005157-jv2t5iy.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"左图中的模型使用了z-buffer来进行透明渲染，以任何一个顺序来渲染网格，都会出现严重的错误。右图中，使用深度剥离可以提供一个正确的渲染结果，但是代价是需要使用一个额外的pass。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]}]}]},{"ID":"20240426005137-6asrhl9","Type":"NodeBlockquote","Properties":{"id":"20240426005137-6asrhl9","updated":"20240426005306"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240426005306-57hhxo5","Type":"NodeParagraph","Properties":{"id":"20240426005306-57hhxo5","updated":"20240426005306"},"Children":[{"Type":"NodeText","Data":"如果使用了这种方法，那么最好是在渲染透明物体的时候，关闭深度缓冲的写入替换功能。也就是说，z-buffer仍然可以用于正常的深度测试，但是通过测试的表面并不会改变已有的z-buffer内容，即最近的不透明表面深度仍然会保持不变。通过使用这种方法，所有后来出现的半透明物体，至少都位于不透明表面前面（深度测试），这样就不会因为旋转相机而导致物体排序出现变化时，造成透明物体突然出现或者突然消失。"}]}]},{"ID":"20240426005308-yem0dnj","Type":"NodeParagraph","Properties":{"id":"20240426005308-yem0dnj","updated":"20240426005352"},"Children":[{"Type":"NodeText","Data":"我们可以对"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{over}"},{"Type":"NodeText","Data":"运算符的方程进行一些修改，使得从前向后的混合也可以得到相同的结果，这种混合模式被称作为"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{under}"},{"Type":"NodeText","Data":"运算符。"}]},{"ID":"20240426005348-evrdm70","Type":"NodeMathBlock","Properties":{"id":"20240426005348-evrdm70","updated":"20240426115333"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\mathbf{c}{o}=\\dfrac{\\alpha{d} \\mathbf{c}{d}+\\left(1-\\alpha{d}\\right) \\alpha_{s} \\mathbf{c}{s}}{\\mathbf{a}{o}} \\quad [\\mathbf{under} \\quad {\\rm operator}]\\\\\\mathbf{a}{o}=\\alpha{s}\\left(1-\\alpha_{d}\\right)+\\alpha_{d}=\\alpha_{s}-\\alpha_{s} \\alpha_{d}+\\alpha_{d} \\tag{5.26}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240426005359-46oplyq","Type":"NodeParagraph","Properties":{"id":"20240426005359-46oplyq","updated":"20240426005710"},"Children":[{"Type":"NodeText","Data":"请注意，"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{under}"},{"Type":"NodeText","Data":"运算符要求目标颜色维护一个alpha值，而"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{over}"},{"Type":"NodeText","Data":"运算符则不需要。换而言之，目标物体（更靠近相机的透明表面）并不是一个不透明物体，因此需要有一个alpha值。"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{under}"},{"Type":"NodeText","Data":"的数学公式与"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{over}"},{"Type":"NodeText","Data":"很像，只是将源（"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"s"},{"Type":"NodeText","Data":"）和目标（"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"d"},{"Type":"NodeText","Data":"）进行了交换。另外需要注意的是，alpha的计算公式是与顺序无关的，因为在我们交换了方程中的源alpha和目标alpha之后，仍然可以得到相同的alpha结果。"}]},{"ID":"20240426005717-imosu87","Type":"NodeParagraph","Properties":{"id":"20240426005717-imosu87","updated":"20240426005717"},"Children":[{"Type":"NodeText","Data":"计算alpha的方程来自于将片元的alpha值，看作为该片元对像素的覆盖率。"}]},{"ID":"20240426005719-9lndhmp","Type":"NodeBlockquote","Properties":{"id":"20240426005719-9lndhmp","updated":"20240426005807"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240426005720-ieohjm8","Type":"NodeParagraph","Properties":{"id":"20240426005720-ieohjm8","updated":"20240426005736"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"例如：如果"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\alpha_{s} =0.7"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"，即意味着这个像素会以某种方式被划分成两个区域，其中有70%的部分被源片元所覆盖，另外30%则没有被覆盖；这里假设目标片元的覆盖率为"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\alpha_{d} =0.6"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"，在没有其他条件的情况下，目标片元将会按照覆盖率与源片元进行重叠。几何解释如下："}]},{"ID":"20240426005739-9mfjim8","Type":"NodeParagraph","Properties":{"id":"20240426005739-9mfjim8","updated":"20240426005807"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240426005739-qix662i.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]}]},{"ID":"20240426114325-vrvem98","Type":"NodeParagraph","Properties":{"id":"20240426114325-vrvem98","updated":"20240426115104"},"Children":[{"Type":"NodeText","Data":"在公式5.26中对于"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{c}_{o}"},{"Type":"NodeText","Data":"的计算为什么是除？参见论文"},{"Type":"NodeTextMark","TextMarkType":"a","TextMarkAHref":"assets/wallace-merging-sig81-20240426114718-bqevjk7.pdf","TextMarkATitle":"MERGING AND TRANSFORMATION OF RASTER IMAGES FOR CARTOON ANIMATION ","TextMarkTextContent":"MERGING AND TRANSFORMATION OF RASTER IMAGES FOR CARTOON ANIMATION .pdf"},{"Type":"NodeText","Data":" 第256-257页"}]},{"ID":"20240426005810-bjtzz2b","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240426005810-bjtzz2b","updated":"20240426011854"},"Children":[{"Type":"NodeText","Data":"5.5.2 顺序无关的透明度算法"}]},{"ID":"20240426114709-y0bvicm","Type":"NodeParagraph","Properties":{"id":"20240426114709-y0bvicm","updated":"20240429191015"},"Children":[{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{under}"},{"Type":"NodeText","Data":"运算符用于将所有透明物体都绘制到一个单独的颜色缓冲中，然后再使用"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{over}"},{"Type":"NodeText","Data":"运算符将这个颜色缓冲合并到场景的不透明视图上。"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{under}"},{"Type":"NodeText","Data":"运算符的另一个用途是执行被称为深度剥离（depth peeling）的算法[449, 1115]，该算法是一种"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"顺序无关的透明度算法（order-independent transparency，OIT），这里的顺序无关意味着：应用程序不需要对透明物体进行排序"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240429185819-bg9jr5s","Type":"NodeParagraph","Properties":{"id":"20240429185819-bg9jr5s","updated":"20240429185839"},"Children":[{"Type":"NodeText","Data":"深度剥离算法的核心思想是使用两个Z-Buffer和多个Pass"}]},{"ID":"20240429185840-4k9nm1x","Type":"NodeList","ListData":{},"Properties":{"id":"20240429185840-4k9nm1x","updated":"20240429191111"},"Children":[{"ID":"20240429185840-pfl0neu","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429185840-pfl0neu","updated":"20240429185840"},"Children":[{"ID":"20240429185840-bowjbqq","Type":"NodeParagraph","Properties":{"id":"20240429185840-bowjbqq","updated":"20240429185901"},"Children":[{"Type":"NodeText","Data":"首先第一个pass会将所有表面信息记录在第一个z-buffer中，包括透明表面"}]}]},{"ID":"20240429190719-kx6z5n0","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429190719-kx6z5n0"},"Children":[{"ID":"20240429190719-ra88ld6","Type":"NodeParagraph","Properties":{"id":"20240429190719-ra88ld6","updated":"20240429190818"},"Children":[{"Type":"NodeText","Data":"第二个Pass只渲染透明物体，假如一个透明物体的z-depth与第一个z-buffer中的深度值匹配，那么这个透明物体是离摄像机最近的，我们将其RGBA值保存在一个单独颜色缓冲中。"}]}]},{"ID":"20240429190819-8mw7jco","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429190819-8mw7jco"},"Children":[{"ID":"20240429190819-gf6hlfw","Type":"NodeParagraph","Properties":{"id":"20240429190819-gf6hlfw","updated":"20240429190936"},"Children":[{"Type":"NodeText","Data":"同时进行“剥离”操作：使用距离相机第二近的透明物体（如果存在）的z-depth来更新第一个z-buffer中的对应位置，此时最靠近相机的透明物品便被剥离了出去，代替的是第二近的透明物体。"}]}]},{"ID":"20240429190952-ymts9cq","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429190952-ymts9cq"},"Children":[{"ID":"20240429190952-asb0017","Type":"NodeParagraph","Properties":{"id":"20240429190952-asb0017","updated":"20240429191041"},"Children":[{"Type":"NodeText","Data":"接下来的pass会继续按照这种方式剥离透明物体并在透明物体的颜色缓冲区上使用"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{under}"},{"Type":"NodeText","Data":"来混合。"}]}]},{"ID":"20240429191042-jxb100p","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429191042-jxb100p","updated":"20240429191111"},"Children":[{"ID":"20240429191042-c2depsl","Type":"NodeParagraph","Properties":{"id":"20240429191042-c2depsl","updated":"20240429191100"},"Children":[{"Type":"NodeText","Data":"在一定数量的Pass后停止算法，将透明图像混合到不透明物体上，如下图"}]},{"ID":"20240429191104-zqk6et3","Type":"NodeParagraph","Properties":{"id":"20240429191104-zqk6et3","updated":"20240429191111"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240429191104-lyizbuy.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"每个深度剥离的pass都会绘制其中一层的透明物体。左图是第一个pass的渲染结果，它代表的是相机直接可见的透明图层（位于最前面）。中间展示了第二个pass的渲染结果，每个像素上都是距离相机第二近的透明表面，在这个例子中代表了透明物体的背面。右图展示了第三个pass的渲染结果，每个像素上都是距离相机第三近的透明表面。 图14.33 展示了最终的渲染结果。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]}]}]},{"ID":"20240429185809-qh6fbkv","Type":"NodeParagraph","Properties":{"id":"20240429185809-qh6fbkv","updated":"20240429192130"},"Children":[{"Type":"NodeText","Data":"使用"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{under}"},{"Type":"NodeText","Data":"运算符的优点在于，最重要的那一个透明层（眼睛最先看到的）是最先被渲染的。每个透明表面总是会增加所覆盖像素的alpha值，如果一个像素的alpha值接近1.0的话，意味着这个像素已经接近不透明了，而对于后续需要进行混合的颜色（位于更远处的透明表面的颜色），其影响可以忽略不计[394]。"}]},{"ID":"20240429192135-9qjrjdg","Type":"NodeParagraph","Properties":{"id":"20240429192135-9qjrjdg","updated":"20240429192238"},"Children":[{"Type":"NodeText","Data":"尽管深度剥离算法可以有效渲染透明物体，但是这个算法的效率并不高，因为每次剥离的过程，都是对所有透明物体的一次独立渲染pass。因此有："}]},{"ID":"20240429192238-39k2bzg","Type":"NodeList","ListData":{},"Properties":{"id":"20240429192238-39k2bzg","updated":"20240429192327"},"Children":[{"ID":"20240429192239-jrgfkwm","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429192239-jrgfkwm","updated":"20240429192239"},"Children":[{"ID":"20240429192239-pbydl8k","Type":"NodeParagraph","Properties":{"id":"20240429192239-pbydl8k","updated":"20240429192300"},"Children":[{"Type":"NodeText","Data":"双重深度剥离：每个Pass中剥离当前最近和最远的两层透明表面"}]}]},{"ID":"20240429192300-sn2wf40","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429192300-sn2wf40","updated":"20240429192327"},"Children":[{"ID":"20240429192300-9wf5l8g","Type":"NodeParagraph","Properties":{"id":"20240429192300-9wf5l8g","updated":"20240429192327"},"Children":[{"Type":"NodeText","Data":"桶排序方法：一个Pass可以捕获32层透明表面，但是需要一个相当大的内存空间。"}]}]}]},{"ID":"20240429192329-0eoxfar","Type":"NodeParagraph","Properties":{"id":"20240429192329-0eoxfar","updated":"20240429192359"},"Children":[{"Type":"NodeText","Data":"为了高校在GPU上实现，提出"}]},{"ID":"20240429192443-f5xg3kc","Type":"NodeList","ListData":{},"Properties":{"id":"20240429192443-f5xg3kc","updated":"20240429192553"},"Children":[{"ID":"20240429192445-eazsbrv","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429192445-eazsbrv","updated":"20240429192445"},"Children":[{"ID":"20240429192445-f4as9u6","Type":"NodeParagraph","Properties":{"id":"20240429192445-f4as9u6","updated":"20240429192504"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"A-Buffer"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":": 在A-buffer中，每个被渲染的三角形（片元），都会为其所覆盖地每个屏幕单元格创建一个覆盖掩码（coverage mask），每个像素上都会存储与其相关的所有片元。不透明片元会剔除位于它们后面的片元，就像z-buffer一样；而所有透明表面的片元都会被存储下来。当所有的信息都被构建完成之后，会通过遍历片元和解析样本的方式，来生成最终的结果。"}]}]},{"ID":"20240429192505-xcuyxih","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429192505-xcuyxih","updated":"20240429192553"},"Children":[{"ID":"20240429192505-f84gkln","Type":"NodeParagraph","Properties":{"id":"20240429192505-f84gkln","updated":"20240429192553"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"片元链表"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"：对每个透明表面进行光栅化，并将生成的片元插入到一个长数组中。然后连同颜色信息和深度信息一起，会生成一个单独的指针结构，该结构会将每个片元与该像素的前一个片元相链接。然后会执行一个单独的pass，它会渲染一个填充屏幕的四边形，以便在每个屏幕像素位置上调用像素着色器，这个着色器会根据已有的指针链接，找到每个像素上所有的透明片元；检索到的每个透明片元，都会与前面的片元按照深度进行排序，然后将排序后的链表，按照从后往前的顺序进行混合，从而生成最终的颜色。"}]}]}]},{"ID":"20240429192658-hiqm7ar","Type":"NodeParagraph","Properties":{"id":"20240429192658-hiqm7ar","updated":"20240429192722"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"20230120214130"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/20230120214130-20240429192658-kflus49.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"左上角执行的是传统的、从后向前的alpha混合，由于错误的排序顺序，会导致渲染出错。右上角使用了A-buffer，给出了一个完美的，非交互式的结果。左下角使用了多层alpha混合的渲染结果。右下角展示了A-buffer和多层alpha混合之间的差异，为了便于观察，将结果颜色放大了四倍 \\[1532] 。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240429192722-2bptcbp","Type":"NodeParagraph","Properties":{"id":"20240429192722-2bptcbp","updated":"20240429192923"},"Children":[{"Type":"NodeText","Data":"GPU通常会有预先分配好的存储资源，例如缓冲区和数组，链表方法也不例外。可以由用户来决定到底使用多少内存，如果内存耗尽的话，则会造成一些很明显的瑕疵。"}]},{"ID":"20240429192927-vdv73a6","Type":"NodeList","ListData":{},"Properties":{"id":"20240429192927-vdv73a6","updated":"20240429193118"},"Children":[{"ID":"20240429192927-6p4519k","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429192927-6p4519k","updated":"20240429193118"},"Children":[{"ID":"20240429192927-hkp2ybl","Type":"NodeParagraph","Properties":{"id":"20240429192927-hkp2ybl","updated":"20240429193100"},"Children":[{"Type":"NodeText","Data":"一个解决方法叫"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"多层apha混合"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"，它使用了一个由intel引入的GPU特性（像素同步），如上图。这一特性可以用于实现可编程混合，并且开销要比原子操作小。他们的方法重新定义了存储和混合，以便能够在内存耗尽的时候，适当降低质量。"}]},{"ID":"20240429193009-e8uzrfp","Type":"NodeParagraph","Properties":{"id":"20240429193009-e8uzrfp","updated":"20240429193118"},"Children":[{"Type":"NodeText","Data":"然而这种机制也有一定的性能成本，因此这类算法的开销可能会很大[1931]。"}]}]}]},{"ID":"20240429193119-gtngwqk","Type":"NodeList","ListData":{},"Properties":{"id":"20240429193119-gtngwqk","updated":"20240429194859"},"Children":[{"ID":"20240429193132-5ojj8is","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429193132-5ojj8is","updated":"20240429194859"},"Children":[{"ID":"20240429193132-gh5cgnx","Type":"NodeParagraph","Properties":{"id":"20240429193132-gh5cgnx","updated":"20240429193232"},"Children":[{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"K-Buffer"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":": 该算法会保留前面若干个透明层，并对它们进行排序；而对于后续的透明层，会将多个层划分为一组，并使用加权平均的方式进行混合。基于加权求和和加权平均的透明技术，都是顺序无关的，并且都是单pass的，因此可以运行在几乎所有的GPU上。但是它们的问题都在于，没有考虑到物体的前后顺序。"}]},{"ID":"20240429193233-3palsox","Type":"NodeBlockquote","Properties":{"id":"20240429193233-3palsox","updated":"20240429193234"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240429193234-6dtyhww","Type":"NodeParagraph","Properties":{"id":"20240429193234-6dtyhww","updated":"20240429193251"},"Children":[{"Type":"NodeText","Data":"使用alpha来表示覆盖率，一条淡红色围巾叠加在一条淡蓝色围巾的上面，会给人一种紫罗兰色的感觉；而正确地结果是一条带有一些蓝色的红色围巾。虽然对于几乎不透明的物体而言，这种方法产生的效果会很差，但是这类算法对于可视化很有用，而且对于高度透明的表面和粒子也很有效，如下图："}]},{"ID":"20240429193306-n3cvg7e","Type":"NodeParagraph","Properties":{"id":"20240429193306-n3cvg7e","updated":"20240429193315"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"20230120214939"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/20230120214939-20240429193306-w9f5scv.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"随着不透明度的增加，物体之间的前后顺序会变得越来越重要。 "},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]}]},{"ID":"20240429193452-8k90trd","Type":"NodeParagraph","Properties":{"id":"20240429193452-8k90trd","updated":"20240429193509"},"Children":[{"Type":"NodeText","Data":"加权求和透明度方程为："}]},{"ID":"20240429193509-s2bw3fw","Type":"NodeMathBlock","Properties":{"id":"20240429193509-s2bw3fw","updated":"20240429193519"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\mathbf{c}_{o}=\\sum_{i=1}^{n}\\left(\\alpha_{i} \\mathbf{c}_{i}\\right)+\\mathbf{c}_{d}\\left(1-\\sum_{i=1}^{n} \\alpha_{i}\\right)\n\\tag{5.27}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240429193521-ld682u8","Type":"NodeParagraph","Properties":{"id":"20240429193521-ld682u8","updated":"20240429193602"},"Children":[{"Type":"NodeText","Data":"其中"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"n"},{"Type":"NodeText","Data":"代表透明物体数量，"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{c}_i"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\alpha_i"},{"Type":"NodeText","Data":"代表了第i个透明表面的颜色值和alpha值，"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{c}_d"},{"Type":"NodeText","Data":"是场景中不透明部分的颜色。"}]},{"ID":"20240429193623-oit0u95","Type":"NodeParagraph","Properties":{"id":"20240429193623-oit0u95","updated":"20240429193641"},"Children":[{"Type":"NodeText","Data":"当透明表面被渲染的时候，这两部分会被分别累加并存储；并且在透明pass的最后，每个像素都会对方程5.27进行计算。"}]},{"ID":"20240429194625-eyruiyl","Type":"NodeParagraph","Properties":{"id":"20240429194625-eyruiyl","updated":"20240429194625"},"Children":[{"Type":"NodeText","Data":"这个方法的问题由两个："}]},{"ID":"20240429193641-08buj2c","Type":"NodeList","ListData":{},"Properties":{"id":"20240429193641-08buj2c","updated":"20240429193643"},"Children":[{"ID":"20240429193643-klhrr5c","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429193643-klhrr5c","updated":"20240429193643"},"Children":[{"ID":"20240429193643-zrkqa05","Type":"NodeParagraph","Properties":{"id":"20240429193643-zrkqa05","updated":"20240429193700"},"Children":[{"Type":"NodeText","Data":"第一个求和式结果会饱和，即产生超过(1,1,1)的颜色"}]}]},{"ID":"20240429193700-ghf2wn3","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240429193700-ghf2wn3"},"Children":[{"ID":"20240429193700-aikeptc","Type":"NodeParagraph","Properties":{"id":"20240429193700-aikeptc","updated":"20240429193709"},"Children":[{"Type":"NodeText","Data":"第二个求和式也可能大于1"}]}]}]},{"ID":"20240429193738-gly679x","Type":"NodeParagraph","Properties":{"id":"20240429193738-gly679x","updated":"20240429193800"},"Children":[{"Type":"NodeText","Data":"因此通常使用加权平均方程："}]},{"ID":"20240429193801-w3de8y3","Type":"NodeMathBlock","Properties":{"id":"20240429193801-w3de8y3","updated":"20240429194633"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\begin{aligned} \\mathbf{c}_{\\mathrm{sum}} \u0026 =\\sum_{i=1}^{n}\\left(\\alpha_{i} \\mathbf{c}_{i}\\right), \\quad \\alpha_{\\mathrm{sum}}=\\sum_{i=1}^{n} \\alpha_{i}, \\\\ \\mathbf{c}_{\\mathrm{wavg}} \u0026 =\\frac{\\mathbf{c}_{\\mathrm{sum}}}{\\alpha_{\\mathrm{sum}}}, \\quad \\alpha_{\\mathrm{avg}}=\\frac{\\alpha_{\\mathrm{sum}}}{n}, \\\\ u \u0026 =\\left(1-\\alpha_{\\mathrm{avg}}\\right)^{n}, \\\\ \\mathbf{c}_{o} \u0026 =(1-u) \\mathbf{c}_{\\mathrm{wavg}}+u \\mathbf{c}_{d} .\\end{aligned}\n\\tag{5.28}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240429193836-qgl0ecu","Type":"NodeParagraph","Properties":{"id":"20240429193836-qgl0ecu","updated":"20240429193921"},"Children":[{"Type":"NodeText","Data":"第一行代表渲染过程中生成的两个独立缓冲区结果，每个透明度表面对"},{"Type":"NodeTextMark","TextMarkType":"strong inline-math","TextMarkInlineMathContent":"\\mathbf{c}_\\mathrm{sum}"},{"Type":"NodeText","Data":"的贡献，都会受到其alpha值的影响。"}]},{"ID":"20240429193921-msdxwbh","Type":"NodeParagraph","Properties":{"id":"20240429193921-msdxwbh","updated":"20240429193936"},"Children":[{"Type":"NodeText","Data":"第二行可以获得一个加权平均的透明颜色"}]},{"ID":"20240429193954-ewoty7f","Type":"NodeParagraph","Properties":{"id":"20240429193954-ewoty7f","updated":"20240429194042"},"Children":[{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"u"},{"Type":"NodeText","Data":"代表对于"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"n"},{"Type":"NodeText","Data":"个透明表面而言，将平均alpha应用"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"n"},{"Type":"NodeText","Data":"次后对目标可见性的估计（大约有"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"u%"},{"Type":"NodeText","Data":"%不可见）"}]},{"ID":"20240429194057-je869u4","Type":"NodeParagraph","Properties":{"id":"20240429194057-je869u4","updated":"20240429194304"},"Children":[{"Type":"NodeText","Data":"最后一行是over算符，"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"(1-u)"},{"Type":"NodeText","Data":"代表了源alpha值。"}]},{"ID":"20240429194309-abmw9o7","Type":"NodeParagraph","Properties":{"id":"20240429194309-abmw9o7","updated":"20240429194343"},"Children":[{"Type":"NodeText","Data":"此方法还有一个现在就是对应具有相同alpha值的透明表明而言，加权平均混合会均匀混合它们的颜色。"}]},{"ID":"20240429194356-lh2a1hd","Type":"NodeParagraph","Properties":{"id":"20240429194356-lh2a1hd","updated":"20240429194524"},"Children":[{"Type":"NodeText","Data":"因此剔除了加权混合的顺序无关透明度算法：表明到相机的距离也会对权重产生影响，越靠前的表面会产生越大的影响。此外"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"u"},{"Type":"NodeText","Data":"是"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"1-\\alpha_{i}"},{"Type":"NodeText","Data":"各项相乘的结果，这个方法视觉上可以得到更可信的结果，如图："}]},{"ID":"20240429194537-hu37ak7","Type":"NodeParagraph","Properties":{"id":"20240429194537-hu37ak7","updated":"20240429194818"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"20230120233740"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/20230120233740-20240429194536-i4eoebj.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"图中展示了在两个不同的相机位置上，观察同一个引擎模型的结果，它们都使用了加权混合的顺序无关透明度算法。按照距离进行加权，有助于弄清哪些表面更加靠近观察者 。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240429194846-9ekm1bv","Type":"NodeParagraph","Properties":{"id":"20240429194846-9ekm1bv","updated":"20240429194859"},"Children":[{"Type":"NodeText","Data":"这种按照距离进行加权的方法存在一个缺点，即在一个很大的场景中，彼此靠近的两个物体会拥有几乎相同的权重，这使得最终计算的结果与使用加权平均方法的结果相差不大。"}]}]}]},{"ID":"20240429193215-8676epv","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20240429193215-8676epv","updated":"20240429195429"},"Children":[{"Type":"NodeText","Data":"5.5.3 Alpha预乘与合成"}]},{"ID":"20240429194944-55o74ue","Type":"NodeParagraph","Properties":{"id":"20240429194944-55o74ue","updated":"20240429195429"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong inline-math","TextMarkInlineMathContent":"\\mathbf{over}"},{"Type":"NodeText","Data":"操作符也可以用于将照片或者物体的渲染图混合在一起，这个过程被称为"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"合成（compositing）"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"。"}]},{"ID":"20240429194953-qy5zevd","Type":"NodeParagraph","Properties":{"id":"20240429194953-qy5zevd","updated":"20240429195429"},"Children":[{"Type":"NodeText","Data":"在这种情况下，每个像素的alpha值会与物体的RGB值存储在一起，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"alpha通道所构成的图像有时候也被称为无光粗糙层（matte，也叫做哑光）"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"，它展示了物体的轮廓形状。"}]},{"ID":"20240429195140-69pza74","Type":"NodeParagraph","Properties":{"id":"20240429195140-69pza74","updated":"20240429195429"},"Children":[{"Type":"NodeText","Data":"使用合成RGBA数据的另一种方式是"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"alpha预乘"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"，它的意思是在使用这些RGB值之前，要先将它们与对应的alpha值相乘。在alpha预乘之后，会使得over方程变得更加高效："}]},{"ID":"20240429195023-t5hor7h","Type":"NodeMathBlock","Properties":{"id":"20240429195023-t5hor7h","updated":"20240429195429"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"\\mathbf{c}_{o}=\\mathbf{c}_{s}^{\\prime}+\\left(1-\\alpha_{s}\\right) \\mathbf{c}_{d}\n\\tag{5.29}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240429195230-1kg7k96","Type":"NodeParagraph","Properties":{"id":"20240429195230-1kg7k96","updated":"20240429195429"},"Children":[{"Type":"NodeText","Data":"其中"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{c}_{s}^{\\prime}"},{"Type":"NodeText","Data":"代表了已经alpha预乘过的源通道，它代替了方程5.25中的"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\alpha_{s} \\mathbf{c}_{s}"},{"Type":"NodeText","Data":"项。由于在混合期间已经叠加过了源颜色，因此alpha预乘还可以在不改变混合状态的情况下，直接使用"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\mathbf{over}"},{"Type":"NodeText","Data":"操作符和叠加混合。"}]},{"ID":"20240429195250-vmyonxd","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20240429195250-vmyonxd","updated":"20240429195420"},"Children":[{"Type":"NodeText","Data":"5.6 显示编码"}]},{"ID":"20240429195506-h2idpn6","Type":"NodeParagraph","Properties":{"id":"20240429195506-h2idpn6","updated":"20240429195516"},"Children":[{"Type":"NodeText","Data":"在计算光照，纹理效果或者是其他操作的时候，我们会假设所使用的值是"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"线性的（linear）。通俗来讲，线性意味着加法和乘法可以生成预期的效果。"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"但是为了避免各种视觉瑕疵，显示缓冲区和纹理中使用了非线性的编码方式，这是我们必须要考虑到的。一个简单粗略的答案是：将着色器输出的颜色范围设置为[0,1]，并将输出的结果缩放为原来的1/2.2次方倍，这个过程被称作为伽马矫正（gamma correction）；而对于输入的颜色和纹理则要进行相反的处理，即要乘以2.2次方。"}]},{"ID":"20240429195658-7xokewl","Type":"NodeParagraph","Properties":{"id":"20240429195658-7xokewl","updated":"20240429195711"},"Children":[{"Type":"NodeText","Data":"在数字成像的早期阶段，通常会使用CRT显示器来进行成像。这些设备的显示radiance和输入电压之间具有指数关系。当应用在一个像素上的能量增加时（电压增加），该像素的radiance并不会线性增长。"}]},{"ID":"20240429195711-j7za7pf","Type":"NodeBlockquote","Properties":{"id":"20240429195711-j7za7pf","updated":"20240429195728"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240429195718-a9g6l6o","Type":"NodeParagraph","Properties":{"id":"20240429195718-a9g6l6o","updated":"20240429195728"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"假设电压与发光强度之间的指数比为2，此时将应用于该像素上的电压设置为原来的50%，那么实际的发光强度为"},{"Type":"NodeText","Data":"0.5^2=0.25"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"，即原来的四分之一。虽然液晶和其他显示技术有着不同于CRT显示器的亮度响应曲线，但是由于它们都是通过转换电路制造的，因此可以模拟CRT显示器的响应方式。"}]}]},{"ID":"20240429195724-nvrvy55","Type":"NodeBlockquote","Properties":{"id":"20240429195724-nvrvy55","updated":"20240429195805"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240429195801-3hfjqr1","Type":"NodeParagraph","Properties":{"id":"20240429195801-3hfjqr1","updated":"20240429195805"},"Children":[{"Type":"NodeText","Data":"这个指数函数几乎与人类眼睛对亮度的敏感程度相反，这个幸运的巧合也使得这种编码方式符合人类的视觉感知[1431]。也就是说，在可显示范围内，一对相邻编码值 N  和 N+1  之间的感知差异大致是恒定的。使用和阈值对比度（threshold contrast）类似的方法进行测量，我们可以在很大范围的条件下，检测到大约1%的亮度差异（即将人眼对亮度的感知曲线以及CRT显示器的响应曲线进行对比）。当颜色存储在有限精度的显示缓冲区中时，这个近似最优的分布能够最大程度地减少条带瑕疵（章节23.6）。对使用相同编码方式的纹理，也可以起到同样的优化效果。"}]}]},{"ID":"20240429195807-sp18wmf","Type":"NodeParagraph","Properties":{"id":"20240429195807-sp18wmf","updated":"20240429195818"},"Children":[{"Type":"NodeText","Data":"显示转换函数（display transfer function）描述了显示缓冲区中的值与实际显示器发光强度之间的关系，因此它也被称为电光转换函数（electrical optical transfer function ，EOTF）。"}]},{"ID":"20240429195819-5f5s2k1","Type":"NodeParagraph","Properties":{"id":"20240429195819-5f5s2k1","updated":"20240429195825"},"Children":[{"Type":"NodeText","Data":"显示转换函数是硬件的一部分，对于不同类型的显示器而言（例如计算机显示器，电视以及电影放映机），具有不同的标准。"}]},{"ID":"20240429195837-re6he9k","Type":"NodeParagraph","Properties":{"id":"20240429195837-re6he9k","updated":"20240429195844"},"Children":[{"Type":"NodeText","Data":"对于这一过程的另一端（图像和视频捕获设备）也有一个相应的标准转换函数，它被称为光电转换函数（optical electric transfer function ，OETF）。"}]},{"ID":"20240429195845-hximgjb","Type":"NodeParagraph","Properties":{"id":"20240429195845-hximgjb","updated":"20240429195917"},"Children":[{"Type":"NodeText","Data":"当对用于显示的线性颜色值进行编码时，我们的目标是抵消显示转换函数的影响，这样计算出的任何颜色值才能发出相应水平的亮度，例如：如果我们计算出的结果翻倍了，那么我们希望显示器输出的亮度也能相应的翻倍。为了保证这种关系，我们需要应用显示转换函数的逆，来抵消其非线性效应，"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color5);"},"TextMarkType":"text","TextMarkTextContent":"这个消除显示器响应曲线的过程也被称作为伽马矫正"},{"Type":"NodeKramdownSpanIAL","Data":"{: style=\"color: var(--b3-font-color5);\"}"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240429195944-skcaegv","Type":"NodeParagraph","Properties":{"id":"20240429195944-skcaegv","updated":"20240429195952"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240429195944-zp90278.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"最左边，GPU着色器访问了一个PNG格式的彩色纹理，该纹理的非线性编码值（蓝色过程）被转换为了线性值。在进行着色和色调映射（ 章节8.2.2 ）之后，最终计算出的颜色值进行了编码（绿色过程），并存储在帧缓冲中。帧缓冲中的颜色值与显示转换函数（红色过程），最终决定了显示器上的发光强度。绿色的编码过程与红色的显示转换函数相抵消，因此显示器实际的发光强度与线性的计算值成正比。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240429195953-hlqw6v7","Type":"NodeParagraph","Properties":{"id":"20240429195953-hlqw6v7","updated":"20240429200101"},"Children":[{"Type":"NodeText","Data":"PC显示器的标准转换函数由一个被称为sRGB的颜色空间所定义。大部分控制GPU的API可以被设置为：当读取纹理和写入颜色缓冲时，自动完成适当的 "},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\rm sRGB "},{"Type":"NodeText","Data":" 转换[491]。"}]},{"ID":"20240429200100-jid59b1","Type":"NodeParagraph","Properties":{"id":"20240429200100-jid59b1","updated":"20240429200124"},"Children":[{"Type":"NodeText","Data":"在渲染的最后阶段，当颜色值被写入帧缓冲中并等待显示的时候，应用这个转换是十分重要的。如果在编码之后再进行一些其他的后处理操作，那么此时是在对非线性的颜色值进行处理，这通常是不正确的，会导致明显的瑕疵。"}]},{"ID":"20240429200154-udtvjjp","Type":"NodeParagraph","Properties":{"id":"20240429200154-udtvjjp","updated":"20240429200203"},"Children":[{"Type":"NodeText","Data":"为了将线性值 x  转换为 "},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\rm sRGB"},{"Type":"NodeText","Data":"  编码的非线性值y，我们需要对x应用"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":" \\rm sRGB "},{"Type":"NodeText","Data":" 显示转换函数的逆，即："}]},{"ID":"20240429200158-exdunpp","Type":"NodeMathBlock","Properties":{"id":"20240429200158-exdunpp","updated":"20240429200425"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"y=f_{\\text {sRGB }}^{-1}(x)=\\left\\{\\begin{array}{ll}1.055 x^{1 / 2.4}-0.055, \u0026 \\text { where } x\u003e0.0031308 \\\\ 12.92 x, \u0026 \\text { where } x \\leq 0.0031308\\end{array}\\right.\n\\tag{5.30}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240429200214-iuggtck","Type":"NodeParagraph","Properties":{"id":"20240429200214-iuggtck","updated":"20240429200224"},"Children":[{"Type":"NodeText","Data":"其中x代表了"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":" \\rm RGB"},{"Type":"NodeText","Data":"  值中的一个通道，我们会对每个通道的线性颜色值都应用这个方程，然后由生成的非线性值来驱动显示器。"}]},{"ID":"20240429200302-clrfhjx","Type":"NodeParagraph","Properties":{"id":"20240429200302-clrfhjx","updated":"20240429200325"},"Children":[{"Type":"NodeText","Data":"这个变换过程是一个两段函数，两个表达式实际上都是简单的乘法，因为硬件设备需要这个变换是完全可逆的。其中第一行表达式包含一个指数运算，它几乎适用于[0.0,1.0]的所有范围。考虑到偏移量和尺度，这个函数可以被近似为下面的简单形式："}]},{"ID":"20240429200302-2hd0hl6","Type":"NodeMathBlock","Properties":{"id":"20240429200302-2hd0hl6","updated":"20240429200307"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"y=f_{\\text {display }}^{-1}(x)=x^{1 / \\gamma} \\tag{5.31}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240429200302-53k4ei2","Type":"NodeParagraph","Properties":{"id":"20240429200302-53k4ei2","updated":"20240429200315"},"Children":[{"Type":"NodeText","Data":"其中"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\gamma = 2.2"},{"Type":"NodeText","Data":"，希腊字母"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\gamma"},{"Type":"NodeText","Data":"是“伽马矫正”的名称来源。"}]},{"ID":"20240429200316-o8g4w34","Type":"NodeParagraph","Properties":{"id":"20240429200316-o8g4w34","updated":"20240429200413"},"Children":[{"Type":"NodeText","Data":"计算出的数值结果需要进行编码才能正确显示，我们在屏幕上看到的任何图像，都是已经经过显示编码的数据；在使用这些颜色进行着色计算之前，我们都必须将其转换为线性值。将 "},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\rm sRGB"},{"Type":"NodeText","Data":"  格式解码为线性值的方程如下："}]},{"ID":"20240429200411-82k4j6g","Type":"NodeMathBlock","Properties":{"id":"20240429200411-82k4j6g","updated":"20240429200423"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"x=f_{\\mathrm{sRGB}}(y)=\\left\\{\\begin{array}{ll}\n\\left(\\dfrac{y+0.055}{1.055}\\right)^{2.4}, \u0026 \\text { where } y\u003e0.04045, \n\\\\[3mm] \n\\dfrac{y}{12.92}, \u0026 \\text { where } y \\leq 0.04045,\n\\end{array}\\right.\n\\tag{5.32}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240429200425-ktib20y","Type":"NodeParagraph","Properties":{"id":"20240429200425-ktib20y","updated":"20240429200505"},"Children":[{"Type":"NodeText","Data":"其中 "},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"y"},{"Type":"NodeText","Data":"  代表了归一化的显示通道值，即存储在图像或者帧缓冲中的值，其范围是[0.0,1.0]。这个解码函数刚好与之前的 "},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\rm sRGB"},{"Type":"NodeText","Data":"  编码方程相反，这意味着如果我们在一个着色器中读取了一张图片（解码过程），并且不对它进行任何处理直接输出（编码过程）的话，它将和处理之前的结果完全相同。​"}]},{"ID":"20240429200538-l9ptn35","Type":"NodeParagraph","Properties":{"id":"20240429200538-l9ptn35","updated":"20240429200546"},"Children":[{"Type":"NodeText","Data":"更加简单的伽马显示转换函数，是直接将方程5.31取逆"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"："}]},{"ID":"20240429200538-ewflana","Type":"NodeMathBlock","Properties":{"id":"20240429200538-ewflana","updated":"20240429200538"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"x=f_{\\text {display }}(y)=y^{\\gamma}. \\tag{5.33}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240429200538-bteet09","Type":"NodeParagraph","Properties":{"id":"20240429200538-bteet09","updated":"20240429200549"},"Children":[{"Type":"NodeText","Data":"有时我们会看到一组更加简洁的转换函数，特别是在移动和浏览器应用程序中[1666]"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"："}]},{"ID":"20240429200538-v37km7a","Type":"NodeMathBlock","Properties":{"id":"20240429200538-v37km7a","updated":"20240429200538"},"Children":[{"Type":"NodeMathBlockOpenMarker"},{"Type":"NodeMathBlockContent","Data":"y=f_{\\text {simpl }}^{-1}(x)=\\sqrt{x} \\\\[2mm] x=f_{\\operatorname{simpl}}(y)=y^{2} \\tag{5.34}"},{"Type":"NodeMathBlockCloseMarker"}]},{"ID":"20240429200538-tupcvjc","Type":"NodeParagraph","Properties":{"id":"20240429200538-tupcvjc","updated":"20240429200556"},"Children":[{"Type":"NodeText","Data":"也就是说，直接对线性值开平方就完成了编码过程，并直接用于显示；反过来，直接取编码值的平方根就完成了解码过程，二者互为反函数。这种转换仅仅是一个很粗略的近似，但是要比完全忽略伽马矫正的过程好上不少。"}]},{"ID":"20240429200556-3zavpbi","Type":"NodeParagraph","Properties":{"id":"20240429200556-3zavpbi","updated":"20240429200615"},"Children":[{"Type":"NodeText","Data":"如果我们不进行伽马矫正的话，那么数值较小的线性值在屏幕上会显得太暗，同时某些颜色的色调可能会发生改变。"}]},{"ID":"20240429200645-g5y0mmz","Type":"NodeBlockquote","Properties":{"id":"20240429200645-g5y0mmz","updated":"20240429200659"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240429200646-exdiy74","Type":"NodeParagraph","Properties":{"id":"20240429200646-exdiy74","updated":"20240429200659"},"Children":[{"Type":"NodeText","Data":"假设我们设置"},{"Type":"NodeTextMark","TextMarkType":"inline-math","TextMarkInlineMathContent":"\\gamma = 2.2"},{"Type":"NodeText","Data":"，如果我们希望屏幕上像素的发光强度与计算出来的线性值成正比的话，这意味着要必须要将这个线性值提升到原来的1/2.2次方倍。线性值0.1对应的发光强度为0.351，0.2对应0.481，0.5对应0.730。"}]}]},{"ID":"20240429200624-8bkuqky","Type":"NodeParagraph","Properties":{"id":"20240429200624-8bkuqky","updated":"20240429200707"},"Children":[{"Type":"NodeText","Data":"如果我们不进行编码的话，直接将这些线性值输入到显示器中，会导致显示器的发光强度低于所需要的值。"}]},{"ID":"20240429200721-6r8lut7","Type":"NodeParagraph","Properties":{"id":"20240429200721-6r8lut7","updated":"20240429200730"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240429200722-uf3kt0e.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"上图展示了两盏聚光灯照亮同一个平面的情况。左图中的两盏灯的亮度分别为0.6和0.4，中间重叠的部分直接将两盏灯的亮度相加，即0.6+0.4=1.0，并没有使用伽马矫正；对非线性值进行加法运算，会导致结果出错。我们可以观察到，左边的灯光要比右边的更亮，但是重叠的部分却出奇的亮。右图中的亮度值在相加之前进行了伽马矫正，两盏灯相较于左图都要更亮，但是中间重叠的部分会显得比较自然。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240429200731-jjkuka8","Type":"NodeParagraph","Properties":{"id":"20240429200731-jjkuka8","updated":"20240429200809"},"Children":[{"Type":"NodeText","Data":"忽略伽马矫正的另一个问题是，对基于物理的线性radiance的正确着色计算，是在非线性值上进行的，图5.40展示了这种情况的一个例子。"}]},{"ID":"20240429200824-7r92qzo","Type":"NodeParagraph","Properties":{"id":"20240429200824-7r92qzo","updated":"20240429200830"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240429200824-x6n5mv1.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"左图中，一个黑色背景（为了方便展示，图中显示的是灰色）上有一个白色三角形，其边缘覆盖了四个像素，像素内标注了真实的覆盖率。如果不进行伽马矫正的话，像素整体会偏暗，从而扭曲人眼对于边缘的感知，如右图所示。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]},{"ID":"20240429200831-t6933kx","Type":"NodeParagraph","Properties":{"id":"20240429200831-t6933kx","updated":"20240429200911"},"Children":[{"Type":"NodeText","Data":"忽略伽马矫正也会影响抗锯齿边缘的质量，如图"}]},{"ID":"20240429200914-n59qu2u","Type":"NodeParagraph","Properties":{"id":"20240429200914-n59qu2u","updated":"20240429200936"},"Children":[{"Type":"NodeImage","Data":"span","Properties":{"parent-style":"display: block;"},"Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240429200914-ptmhgw9.png"},{"Type":"NodeLinkSpace"},{"Type":"NodeLinkTitle","Data":"左边，在抗锯齿之后进行了伽马矫正。中间，在抗锯齿之后进行了部分 伽马 矫正。右边，没有进行伽马矫正。"},{"Type":"NodeCloseParen"}]},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"display: block;\"}"}]}]}